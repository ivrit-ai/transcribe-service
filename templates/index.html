<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="{{ url_for('static', path='favicon.png') }}" />
    <title>×ª××œ×•×œ ×‘×¢×–×¨×ª ivrit.ai</title>
    <script src="https://cdn.jsdelivr.net/npm/html-docx-js/dist/html-docx.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
      :root {
        --bg-color: #f5f5f5;
        --container-bg: #ffffff;
        --text-color: #333333;
        --border-color: #e0e0e0;
        --primary-color: #4caf50;
        --secondary-color: #f8f9fa;
        --input-bg: #ffffff;
      }

      [data-theme="dark"] {
        --bg-color: #1a1a1a;
        --container-bg: #2d2d2d;
        --text-color: #e0e0e0;
        --border-color: #555555;
        --primary-color: #66bb6a;
        --secondary-color: #3a3a3a;
        --input-bg: #1e1e1e;
      }

      body {
        font-family: Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
      }
      .container {
        background-color: var(--container-bg);
        padding: 2rem;
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        text-align: center;
        width: 80%;
        max-width: 600px;
        position: relative;
      }
      .settings-btn {
        position: absolute;
        top: 1rem;
        left: 1rem;
        background: none;
        border: none;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 50%;
        transition: background-color 0.2s;
      }
      .settings-btn:hover {
        background-color: #f0f0f0;
      }
      .settings-btn svg {
        width: 24px;
        height: 24px;
        color: #666;
      }
      .lang-menu {
        position: absolute;
        top: 1rem;
        left: 3.5rem;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
      }
      .lang-menu button {
        background: none;
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.45rem;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .lang-menu .dropdown {
        position: relative;
        display: inline-block;
      }
      .lang-menu .dropdown-content {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 0.25rem 0;
        min-width: 120px;
        z-index: 200;
      }
      .lang-menu .dropdown:hover .dropdown-content {
        display: block;
      }
      .lang-menu .dropdown-content button {
        display: block;
        width: 100%;
        background: none;
        border: none;
        text-align: right;
        padding: 0.4rem 0.75rem;
        cursor: pointer;
        color: var(--text-color);
      }
      .lang-menu .dropdown-content button:hover {
        background: var(--secondary-color);
        color: var(--primary-color);
      }
      .theme-toggle {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: none;
        border: none;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 50%;
        transition: background-color 0.2s;
      }
      .theme-toggle:hover {
        background-color: #f0f0f0;
      }
      .theme-toggle svg,
      .theme-toggle i[data-lucide] {
        width: 24px;
        height: 24px;
        color: #666;
      }
      .balance-container {
        display: none;
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 0.75rem 1rem;
        font-size: 14px;
        color: #495057;
        text-align: right;
        z-index: 10;
      }
      .balance-container.visible {
        display: block;
      }
      .balance-label {
        font-weight: bold;
        margin-bottom: 0.25rem;
      }
      .balance-amount {
        color: #28a745;
        font-weight: bold;
      }
      .balance-loading {
        color: #6c757d;
        font-style: italic;
      }
      .modal .balance-container {
        position: relative;
        top: 0;
        right: 0;
        margin-top: 0.9rem;
        z-index: 1;
        background: linear-gradient(
          135deg,
          var(--input-bg) 0%,
          rgba(0, 0, 0, 0) 100%
        );
        border: 1px solid var(--border-color);
        display: none;
        padding: 0.65rem 0.85rem;
        border-radius: 10px;
        font-size: 0.9rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        direction: rtl;
        text-align: right;
      }
      .modal .balance-container.visible {
        display: inline-flex;
        align-items: center;
        gap: 0.6rem;
        width: fit-content;
        white-space: nowrap;
      }
      .balance-icon svg {
        width: 20px;
        height: 20px;
        color: var(--primary-color);
      }
      .balance-text {
        display: flex;
        align-items: baseline;
        gap: 0.4rem;
      }
      .modal .balance-label {
        margin: 0;
        font-weight: 600;
        color: var(--text-color);
      }
      .modal .balance-amount {
        font-size: 0.95rem;
      }
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }
      .modal.show {
        display: block;
      }
      .modal-content {
        background-color: var(--container-bg);
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 1.5rem;
        border-radius: 12px;
        width: 90%;
        max-width: 480px;
        max-height: 90vh;
        overflow-y: auto;
        text-align: right;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.25rem;
        padding-bottom: 0.75rem;
      }
      .modal-header h2 {
        margin: 0;
        font-size: 1.4rem;
        color: var(--text-color);
      }
      .close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        color: var(--text-color);
      }
      .close:hover {
        color: var(--primary-color);
      }
      .form-group {
        margin-bottom: 1rem;
        text-align: left;
      }
      .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: bold;
        color: var(--text-color);
      }
      .form-group input {
        width: 100%;
        padding: 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 1rem;
        box-sizing: border-box;
        text-align: left;
        direction: ltr;
        background-color: var(--input-bg);
        color: var(--text-color);
      }
      .form-group input:focus {
        outline: none;
        border-color: var(--primary-color);
      }
      .form-help a {
        color: var(--primary-color);
        text-decoration: none;
        font-weight: 600;
      }
      .form-help a:hover {
        text-decoration: underline;
      }
      .modal-buttons {
        display: flex;
        justify-content: flex-start;
        gap: 0.75rem;
        margin-top: 1.5rem;
        padding-top: 1rem;
      }
      .btn {
        padding: 0.6rem 1.2rem;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: all 0.2s ease;
        min-height: 40px;
      }
      .btn-primary {
        background-color: var(--primary-color);
        color: white;
      }
      .btn-secondary {
        background-color: var(--secondary-color);
        color: var(--text-color);
        border: 1px solid var(--border-color);
      }
      .btn-secondary:hover {
        background-color: var(--container-bg);
        border-color: var(--primary-color);
        opacity: 1;
      }
      .btn:hover {
        opacity: 0.85;
      }
      .btn-primary:hover {
        opacity: 0.9;
      }

      .settings-section {
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
      }
      .settings-section:last-of-type {
        border-bottom: none;
        margin-bottom: 0.5rem;
      }
      .settings-section h3 {
        font-size: 1.1rem;
        color: var(--text-color);
        margin: 0 0 0.75rem 0;
        font-weight: 600;
        text-align: right;
      }
      .form-label {
        display: block;
        font-weight: 500;
        color: var(--text-color);
        margin-bottom: 0.5rem;
        text-align: right;
        font-size: 0.95rem;
      }
      .form-help {
        display: block;
        font-size: 0.8rem;
        color: var(--text-color);
        opacity: 0.65;
        margin-top: 0.25rem;
        text-align: right;
        line-height: 1.3;
      }
      .radio-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .radio-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.6rem 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        background-color: var(--secondary-color);
        direction: rtl;
        min-height: 44px;
        position: relative;
      }
      .radio-option:hover {
        border-color: var(--primary-color);
        background-color: var(--container-bg);
      }
      .radio-option input[type="radio"] {
        margin: 0;
        width: 16px;
        height: 16px;
        accent-color: var(--primary-color);
        flex-shrink: 0;
        position: absolute;
        left: 0.75rem;
      }
      .radio-option .radio-content {
        flex: 1;
        text-align: right;
        direction: rtl;
        padding-left: 2rem;
      }
      .radio-option .radio-text {
        font-weight: 500;
        color: var(--text-color);
        font-size: 0.9rem;
        display: block;
        margin-bottom: 0.1rem;
        text-align: right;
        direction: rtl;
      }
      .radio-option small {
        font-size: 0.75rem;
        color: var(--text-color);
        opacity: 0.6;
        line-height: 1.2;
        text-align: right;
        direction: rtl;
      }
      .radio-option input[type="radio"]:checked ~ .radio-content .radio-text {
        color: var(--primary-color);
        font-weight: 600;
      }
      h1 {
        margin-bottom: 2rem;
      }
      #drop-area {
        border: 2px dashed var(--border-color);
        border-radius: 12px;
        padding: 2rem;
        cursor: pointer;
        margin-bottom: 1rem;
        background: linear-gradient(
          135deg,
          var(--secondary-color) 0%,
          rgba(76, 175, 80, 0.12) 50%,
          var(--secondary-color) 100%
        );
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }
      #drop-area::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          45deg,
          transparent 40%,
          rgba(76, 175, 80, 0.03) 50%,
          transparent 60%
        );
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      #drop-area:hover::before {
        opacity: 1;
      }
      #drop-area:hover {
        border-color: var(--primary-color);
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.08) 0%,
          rgba(76, 175, 80, 0.15) 50%,
          rgba(76, 175, 80, 0.08) 100%
        );
        transform: translateY(-2px);
      }
      #drop-area.highlight {
        border-color: var(--primary-color);
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.1) 0%,
          rgba(76, 175, 80, 0.2) 50%,
          rgba(76, 175, 80, 0.1) 100%
        );
        transform: translateY(-3px);
      }
      #file-input {
        display: none;
      }
      #file-name {
        margin-top: 1rem;
        font-weight: bold;
      }
      #transcribe-btn {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        font-size: 1rem;
        cursor: pointer;
        border-radius: 8px;
        margin-top: 1rem;
        transition: all 0.3s ease;
      }
      #transcribe-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
      }
      #transcribe-btn:disabled {
        background-color: var(--border-color);
        cursor: not-allowed;
      }
      /* Ensure perfect alignment of language select and transcribe button */
      .transcribe-controls #transcribe-btn {
        margin-top: 0;
        height: 40px;
        padding: 0 1rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .transcribe-controls {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 1rem;
      }
      #language-select {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        height: 40px;
        padding: 0 0.75rem; /* ~12px to match button's horizontal padding scale */
        color: var(--text-color);
        font-size: 1rem;
      }
      #progress-container {
        width: 100%;
        background-color: #f0f0f0;
        border-radius: 4px;
        margin-top: 1rem;
        display: none;
      }
      #progress-bar {
        width: 0;
        height: 20px;
        background-color: #4caf50;
        border-radius: 4px;
        transition: width 0.3s;
      }
      #transcription-container {
        position: relative;
        margin: 1rem auto 0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #transcription {
        width: 100%;
        height: 200px;
        border: 2px solid var(--border-color);
        padding: 1rem;
        text-align: right;
        white-space: pre-wrap;
        overflow-y: auto;
        resize: vertical;
        font-size: 1rem;
        border-radius: 8px;
        background-color: var(--input-bg);
        color: var(--text-color);
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        line-height: 1.5;
      }
      .speaker {
        font-weight: bold;
      }
      .speaker-1 { color: #2196F3; } /* Blue */
      .speaker-2 { color: #4CAF50; } /* Green */
      .speaker-3 { color: #FF9800; } /* Orange */
      .speaker-4 { color: #E91E63; } /* Pink */
      .speaker-5 { color: #9C27B0; } /* Purple */
      .speaker-6 { color: #F44336; } /* Red */
      .speaker-7 { color: #00BCD4; } /* Cyan */
      .speaker-8 { color: #8BC34A; } /* Light Green */
      .speaker-9 { color: #FFC107; } /* Amber */
      .speaker-10 { color: #607D8B; } /* Blue Grey */
      /* Dark theme speaker colors */
      [data-theme="dark"] .speaker-1 { color: #64B5F6; }
      [data-theme="dark"] .speaker-2 { color: #81C784; }
      [data-theme="dark"] .speaker-3 { color: #FFB74D; }
      [data-theme="dark"] .speaker-4 { color: #F06292; }
      [data-theme="dark"] .speaker-5 { color: #BA68C8; }
      [data-theme="dark"] .speaker-6 { color: #EF5350; }
      [data-theme="dark"] .speaker-7 { color: #4DD0E1; }
      [data-theme="dark"] .speaker-8 { color: #AED581; }
      [data-theme="dark"] .speaker-9 { color: #FFD54F; }
      [data-theme="dark"] .speaker-10 { color: #90A4AE; }
      .action-buttons {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
      }
      .actions-right,
      .actions-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .action-buttons button {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .action-buttons button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .download-menu {
        position: relative;
      }
      .download-menu > button#download-menu-btn {
        position: relative;
      }
      .download-menu > button#download-menu-btn:disabled {
        cursor: not-allowed;
      }
      .download-menu {
        display: inline-block;
      }
      .download-menu::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        height: 6px;
      }
      .download-dropdown {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 0;
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 0.4rem 0;
        min-width: 160px;
        z-index: 200;
        direction: rtl;
        pointer-events: auto;
      }
      .download-menu:hover {
        overflow: visible;
      }
      .download-menu:hover .download-dropdown {
        display: block;
      }
      .download-menu:hover .download-dropdown {
        display: block;
      }
      .download-dropdown button {
        background: none;
        border: none;
        width: 100%;
        text-align: right;
        padding: 0.45rem 0.9rem;
        cursor: pointer;
        font-size: 0.8rem;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 0.4rem;
        direction: rtl;
      }
      .download-dropdown-header {
        font-size: 0.7rem;
        font-weight: 600;
        letter-spacing: 0.5px;
        padding: 0.35rem 0.9rem 0.25rem;
        color: var(--text-color);
        opacity: 0.7;
        pointer-events: none;
        border-bottom: 1px solid var(--border-color);
        margin-bottom: 0.2rem;
      }
      .download-dropdown button:hover {
        background: var(--secondary-color);
        color: var(--primary-color);
      }
      .download-dropdown button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .hidden-download-original {
        display: none !important;
      }
      /* Standard inline SVG sizing inside action buttons */
      .action-buttons button svg {
        width: 20px;
        height: 20px;
      }
      /* Active indication for text-format toggle */
      .action-buttons button.toggle-active {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
        color: #ffffff;
      }
      .action-buttons button.toggle-active i[data-lucide] {
        color: #ffffff;
      }
      .action-buttons button.toggle-active svg {
        color: #ffffff;
      }
      /* Toggle emojis sizing */
      #timestamps-toggle, #diarization-toggle {
        font-size: 18px;
        line-height: 1;
      }
      #copy-btn {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #copy-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #copy-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      #download-menu-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      #download-btn {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
      }
      #download-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #download-docx-btn {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #download-docx-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #download-docx-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      .support-link {
        margin-top: 0.5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        text-decoration: none;
        color: #000000;
        font-weight: bold;
        transition: opacity 0.2s;
        flex-direction: row-reverse;
      }
      .support-link:hover {
        opacity: 0.8;
      }
      .support-link img {
        width: 24px;
        height: 24px;
      }
      .links-container {
        margin-top: 1.5rem;
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        flex-direction: column;
        align-items: center;
      }
      .contact-link {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        text-decoration: none;
        color: #2196f3;
        font-weight: bold;
        transition: opacity 0.2s;
        flex-direction: row-reverse;
      }
      .contact-link:hover {
        opacity: 0.8;
      }
      .contact-link svg {
        width: 24px;
        height: 24px;
      }
      .divider {
        width: 80%;
        height: 1px;
        background-color: #e0e0e0;
        margin: 1rem 0;
      }
      .display-options {
        margin-top: 1rem;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 1rem;
      }
      .slider-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .switch {
        position: relative;
        display: inline-block;
        width: 48px;
        height: 24px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 24px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: #4caf50;
      }
      input:checked + .slider:before {
        transform: translateX(24px);
      }

      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 2000;
      }
      .toast {
        background-color: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem 1.5rem;
        margin-bottom: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transform: translateX(400px);
        opacity: 0;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        min-width: 300px;
        max-width: 420px;
        direction: rtl;
        text-align: right;
        line-height: 1.4;
        white-space: normal;
      }
      .toast.show {
        transform: translateX(0);
        opacity: 1;
      }
      .toast.success {
        border-left: 4px solid var(--primary-color);
      }
      .toast.error {
        border-left: 4px solid #f44336;
      }
      .toast-message {
        flex: 1;
        color: var(--text-color);
        white-space: normal;
      }

      .file-preview {
        display: none;
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1rem;
        text-align: right;
      }
      .file-preview.show {
        display: block;
      }
      .file-info {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        flex-direction: row-reverse;
      }
      .file-details {
        flex: 1;
        text-align: left;
      }
      .file-details strong {
        display: block;
        margin-bottom: 0.5rem;
        color: var(--text-color);
      }
      .file-size {
        font-size: 0.9rem;
        color: var(--text-color);
        opacity: 0.7;
      }
      .remove-file-btn {
        background-color: #f2554a;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 0.5rem 1rem;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.3s ease;
      }
      .remove-file-btn:hover {
        background-color: #f6463a;
        transform: translateY(-1px);
      }
      .site-footer {
        margin-top: 2rem;
        font-size: 0.75rem;
        color: #777;
        text-align: center;
        direction: rtl;
      }
      [data-theme="dark"] .site-footer {
        color: #aaa;
      }
      .site-footer a {
        color: var(--primary-color);
        text-decoration: none;
        font-weight: 600;
      }
      .site-footer a:hover {
        text-decoration: underline;
      }

      /* Tab navigation styles */
      .tabs {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
        border-bottom: 2px solid var(--border-color);
      }
      .tab-button {
        padding: 0.75rem 1.5rem;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 500;
        color: var(--text-color);
        opacity: 0.6;
        transition: all 0.2s ease;
        border-bottom: 3px solid transparent;
        margin-bottom: -2px;
      }
      .tab-button:hover {
        opacity: 0.8;
      }
      .tab-button.active {
        opacity: 1;
        border-bottom-color: var(--primary-color);
        color: var(--primary-color);
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }

      /* Files list styles */
      .files-list {
        margin-top: 1rem;
      }
      .file-item {
        background: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 0.75rem;
        transition: all 0.2s ease;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
      }
      .file-item-status {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        flex-shrink: 0;
      }
      .status-queued {
        background-color: #9e9e9e;
      }
      .status-being-processed {
        background-color: #2196f3;
        animation: pulse 2s ease-in-out infinite;
      }
      .status-ready {
        background-color: #4caf50;
      }
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
      .file-item-info {
        flex: 1;
        text-align: right;
        cursor: pointer;
      }
      .file-item-info:hover {
        color: var(--primary-color);
      }
      .file-item-name {
        font-weight: 600;
        color: var(--text-color);
        margin-bottom: 0.25rem;
      }
      .file-item-meta {
        font-size: 0.85rem;
        color: var(--text-color);
        opacity: 0.6;
      }
      .file-item-actions {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        margin-left: 1rem;
      }
      .file-item-icon {
        cursor: pointer;
      }
      .file-item-icon svg {
        width: 24px;
        height: 24px;
        color: var(--primary-color);
      }
      .file-item-download-menu {
        position: relative;
        display: inline-block;
      }
      .file-item-download-menu .download-dropdown {
        display: none;
        position: absolute;
        bottom: 100%;
        right: 0;
        margin-bottom: 0.25rem;
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 0.4rem 0;
        min-width: 140px;
        z-index: 200;
        direction: rtl;
      }
      .file-item-download-menu.open .download-dropdown {
        display: block;
      }
      .file-item-download-btn {
        background: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }
      .file-item-download-btn:hover {
        background: var(--container-bg);
        border-color: var(--primary-color);
      }
      .file-item-download-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      .files-loading {
        text-align: center;
        padding: 2rem;
        color: var(--text-color);
        opacity: 0.6;
      }
      .files-empty {
        text-align: center;
        padding: 3rem 2rem;
        color: var(--text-color);
        opacity: 0.6;
      }
      .files-error {
        text-align: center;
        padding: 2rem;
        color: #f44336;
        background: rgba(244, 67, 54, 0.1);
        border-radius: 8px;
        margin-top: 1rem;
      }

      /* Localization layout adjustments */
      html[dir] .modal-content {
        text-align: start;
      }
      html[dir] .modal .form-group {
        text-align: start;
      }
      html[dir] .modal .radio-content,
      html[dir] .modal .radio-option .radio-text,
      html[dir] .modal .form-help {
        text-align: start;
        direction: inherit;
      }
      html[dir] .modal .radio-option {
        direction: inherit;
      }
      html[dir] .modal .balance-container {
        direction: inherit;
        text-align: start;
      }
      /* Keep RunPod token input LTR regardless of UI language */
      #runpod-token {
        direction: ltr;
        text-align: left;
      }
    </style>
  </head>
  <body>
    <div class="toast-container" id="toast-container"></div>

    <div class="container">
      <button
        class="theme-toggle"
        id="theme-toggle"
        onclick="toggleTheme()"
        data-i18n-title="themeToggle"
      >
        <i data-lucide="sun" id="sun-icon"></i>
        <i data-lucide="moon" id="moon-icon" style="display: none"></i>
      </button>
      <button
        class="settings-btn"
        id="settings-btn"
        data-i18n-title="settings"
      >
        <i data-lucide="settings"></i>
      </button>
      <div class="lang-menu" id="lang-menu">
        <div class="dropdown">
          <button id="lang-btn" title="×©×¤×”" aria-label="×©×¤×”">
            <i data-lucide="globe"></i>
          </button>
          <div class="dropdown-content">
            <button type="button" data-lang="he">×¢×‘×¨×™×ª</button>
            <button type="button" data-lang="yi">×™×™Ö´×“×™×©</button>
            <button type="button" data-lang="en">English</button>
          </div>
        </div>
      </div>
      <h1 data-i18n="title">×ª××œ×•×œ ×‘×¢×–×¨×ª ivrit.ai</h1>
      
      <!-- Tab Navigation -->
      <div class="tabs">
        <button class="tab-button active" data-tab="transcribe" data-i18n="tabTranscribe">×ª××œ×•×œ ×—×“×©</button>
        <button class="tab-button" data-tab="files" data-i18n="tabMyFiles">×”×§×‘×¦×™× ×©×œ×™</button>
        <button class="tab-button" data-tab="viewer" id="viewer-tab-btn" style="display: none;" data-i18n="tabViewer">×¦×¤×™×™×”</button>
      </div>

      <!-- Transcribe Tab Content -->
      <div id="tab-transcribe" class="tab-content active">
      <div id="drop-area">
        <p data-i18n="dropPrompt">×’×¨×•×¨ ×§×•×‘×¥ ×œ×›××Ÿ ××• ×œ×—×¥ ×œ×‘×—×™×¨×ª ×§×•×‘×¥</p>
        <input type="file" id="file-input" accept="audio/*,video/*" />
      </div>

      <div class="file-preview" id="file-preview">
        <div class="file-info">
          <div class="file-details">
            <strong id="preview-file-name" data-i18n="fileSelected">×§×•×‘×¥ × ×‘×—×¨</strong>
          <div class="file-size" id="preview-file-size" dir="ltr">
              <span data-i18n="fileSize">×’×•×“×œ ×§×•×‘×¥</span>
            </div>
          </div>
          <button class="remove-file-btn" onclick="removeFile()" data-i18n="removeFile">×”×¡×¨ ×§×•×‘×¥</button>
        </div>
      </div>

      <div id="file-name"></div>
      <div class="transcribe-controls">
        <button id="transcribe-btn" disabled data-i18n="transcribe">×ª××œ×œ</button>
        <select id="language-select" title="×©×¤×ª ×ª××œ×•×œ" aria-label="×©×¤×ª ×ª××œ×•×œ"></select>
      </div>
      <div id="progress-container">
        <div id="progress-bar"></div>
      </div>
      </div>
      <!-- End Transcribe Tab -->

      <!-- My Files Tab Content -->
      <div id="tab-files" class="tab-content">
        <div id="files-container">
          <div class="files-loading" id="files-loading">
            <p data-i18n="filesLoading">×˜×•×¢×Ÿ ×§×‘×¦×™×...</p>
          </div>
          <div class="files-error" id="files-error" style="display: none;">
            <p id="files-error-message"></p>
          </div>
          <div class="files-empty" id="files-empty" style="display: none;">
            <i data-lucide="inbox" style="width: 48px; height: 48px; margin-bottom: 1rem;"></i>
            <p data-i18n="filesEmpty">×¢×“×™×™×Ÿ ×œ× ×©××¨×ª ×ª××œ×•×œ×™×</p>
          </div>
          <div class="files-list" id="files-list"></div>
        </div>
      </div>
      <!-- End My Files Tab -->

      <!-- Viewer Tab Content -->
      <div id="tab-viewer" class="tab-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <button id="back-to-files-btn" class="btn btn-secondary" style="padding: 0.5rem 1rem;">
            <i data-lucide="arrow-right" style="width: 16px; height: 16px; margin-left: 0.25rem;"></i>
            <span data-i18n="backToFiles">×—×–×¨×” ×œ×¨×©×™××”</span>
          </button>
          <h2 id="viewer-file-name" style="margin: 0; font-size: 1.2rem; color: var(--text-color);"></h2>
        </div>

        <div class="action-buttons">
          <div class="actions-right">
            <button id="viewer-text-format-toggle" title="×¤×•×¨××˜ ×”×˜×§×¡×˜" aria-label="×¤×•×¨××˜ ×”×˜×§×¡×˜">
              <svg id="viewer-text-format-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M4 6h16M10 12h10M4 18h16"/>
              </svg>
            </button>
            <button id="viewer-timestamps-toggle" title="×§×•×“×™ ×–××Ÿ" aria-label="×§×•×“×™ ×–××Ÿ">ğŸ•’</button>
            <button id="viewer-diarization-toggle" title="×“×•×‘×¨×™×" aria-label="×“×•×‘×¨×™×">ğŸ—£ï¸</button>
          </div>

          <div class="actions-left">
            <button id="viewer-copy-btn" data-i18n-title="copyText">
              <i data-lucide="copy"></i>
            </button>

            <div class="download-menu">
              <button id="viewer-download-menu-btn" data-i18n-title="downloads">
                <i data-lucide="download"></i>
              </button>
              <div class="download-dropdown">
                <div class="download-dropdown-header" data-i18n="downloadAs">×”×•×¨×“ ×›...</div>
                <button type="button" data-action="vtt" id="viewer-menu-vtt">VTT</button>
                <button type="button" data-action="srt" id="viewer-menu-srt">SRT</button>
                <button type="button" data-action="docx" id="viewer-menu-docx">
                  <span data-i18n="wordDocx">Word DOCX</span>
                </button>
                <button type="button" data-action="json" id="viewer-menu-json">JSON</button>
              </div>
            </div>
          </div>
        </div>

        <div id="viewer-transcription-container">
          <div id="viewer-transcription" contenteditable="false"></div>
        </div>
      </div>
      <!-- End Viewer Tab -->

      <div class="links-container">
        <a href="mailto:info@ivrit.ai" class="contact-link">
          <i data-lucide="mail"></i>
          <span data-i18n="contactUs">×¨×•×¦×™× ×œ×™×¦×•×¨ ×§×©×¨? ×× ×—× ×• ×›××Ÿ</span>
        </a>
        <a
          href="https://www.patreon.com/ivrit_ai/membership"
          target="_blank"
          class="support-link"
        >
          <img
            src="{{ url_for('static', path='patreon.png') }}"
            alt="Patreon"
          />
          <span data-i18n="donateAsk">×¨×•×¦×™× ×œ×ª×¨×•× ×œ× ×•?</span>
        </a>
      </div>
      <div class="site-footer">
        <a
          href="https://www.ivrit.ai/en/privacy/"
          target="_blank"
          rel="noopener"
          ><span data-i18n="privacyTos">××“×™× ×™×•×ª ×¤×¨×˜×™×•×ª ×•×ª× ××™ ×©×™××•×©</span></a
        >
      </div>
    </div>

    <div id="settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 data-i18n="settingsHeader">×”×’×“×¨×•×ª</h2>
          <button class="close" id="close-settings">&times;</button>
        </div>
        <form id="settings-form">
          <div class="settings-section">
            <h3 data-i18n="settingsRunpod">×”×’×“×¨×•×ª RunPod</h3>
            <div class="form-group">
              <label for="runpod-token" dir="ltr" data-i18n="runpodKeyLabel">RunPod API Key:</label>
              <input
                type="password"
                id="runpod-token"
                name="runpod-token"
                data-i18n="runpodKeyPlaceholder"
                placeholder="×”×›× ×¡ ××ª ×”-API Key ×©×œ×š"
              />
              <small class="form-help"
                ><span data-i18n="runpodHelpText">×”×–× ×ª ××¤×ª×— ×¤×¨×˜×™ ×××¤×©×¨×ª ×©×™××•×© ×‘××©××‘×™× ×¤×¨×˜×™×™× ×œ×¢×™×‘×•×“ ××”×™×¨ ×™×•×ª×¨.</span><br />
                <a
                  href="https://youtu.be/xr8RQRFERLs?si=ibHcP6m0wdUh-gHU"
                  target="_blank"
                  rel="noopener"
                  data-i18n="runpodHelpWatch">×œ×¦×¤×™×™×” ×‘×¡×¨×˜×•×Ÿ ×”×¡×‘×¨</a
                ></small
              >
            </div>
            <div
              class="balance-container"
              id="balance-container"
              aria-live="polite"
            >
              <div class="balance-icon" aria-hidden="true">
                <i data-lucide="credit-card"></i>
              </div>
              <div class="balance-text">
                <span class="balance-label" data-i18n="balanceLabel">×™×ª×¨×”</span>
                <span class="balance-amount" id="balance-amount">â€”</span>
              </div>
            </div>
          </div>

          

          <div class="modal-buttons">
            <button type="submit" class="btn btn-primary" data-i18n="save">×©××•×¨</button>
            <button
              type="button"
              class="btn btn-secondary"
              id="cancel-settings"
            >
              <span data-i18n="cancel">×‘×™×˜×•×œ</span>
            </button>
            <button type="button" class="btn btn-secondary" id="clear-settings">
              <span data-i18n="clear">× ×§×” ×”×’×“×¨×•×ª</span>
            </button>
          </div>
        </form>
      </div>
    </div>

    <script src="{{ url_for('static', path='i18n.js') }}"></script>
    <script>
      // Initialize Lucide icons after DOM is parsed
      document.addEventListener("DOMContentLoaded", () => {
        if (window.lucide && typeof window.lucide.createIcons === "function") {
          window.lucide.createIcons()
        }
        if (window.I18N) {
          window.I18N.apply()
          const langBtn = document.getElementById('lang-btn')
          if (langBtn) {
            langBtn.title = window.I18N.t('language')
            langBtn.setAttribute('aria-label', window.I18N.t('language'))
          }
        }
        initTranscriptionLanguages()
        // Toggle UI initialization removed - toggles only in Viewer tab
        // Initialize default diarization setting
        if (!displaySettings.diarizationDisplay) {
          displaySettings.diarizationDisplay = 'enabled'
          localStorage.setItem('displaySettings', JSON.stringify(displaySettings))
        }
        updateTranscriptionDirectionUI()
        // Initialize tab switching
        initTabs()
      })
      const dropArea = document.getElementById("drop-area")
      const fileInput = document.getElementById("file-input")
      const fileName = document.getElementById("file-name")
      const transcribeBtn = document.getElementById("transcribe-btn")
      const progressContainer = document.getElementById("progress-container")
      const progressBar = document.getElementById("progress-bar")
      const transcriptionArea = document.getElementById("transcription")
      const languageSelect = document.getElementById("language-select")
      const copyBtn = document.getElementById("copy-btn")
      const downloadBtn = document.getElementById("download-btn")
      const downloadDocxBtn = document.getElementById("download-docx-btn")
      const exportWordsBtn = document.getElementById("export-words-btn")
      const textFormatToggleBtn = document.getElementById("text-format-toggle")
      const timestampsToggleBtn = document.getElementById("timestamps-toggle")
      const diarizationToggleBtn = document.getElementById("diarization-toggle")
      // New unified download menu elements
      const downloadMenuBtn = document.getElementById("download-menu-btn")
      const menuVttBtn = document.getElementById("menu-vtt")
      const menuSrtBtn = document.getElementById("menu-srt")
      const menuDocxBtn = document.getElementById("menu-docx")
      const menuJsonBtn = document.getElementById("menu-json")
      const settingsBtn = document.getElementById("settings-btn")
      const langMenu = document.getElementById("lang-menu")
      // Language selection handlers
      if (langMenu && window.I18N) {
        langMenu.addEventListener('click', (e) => {
          const btn = e.target.closest('button[data-lang]')
          if (!btn) return
          const lang = btn.getAttribute('data-lang')
          window.I18N.setLanguage(lang)
          window.I18N.apply()
          if (window.lucide && typeof window.lucide.createIcons === 'function') {
            window.lucide.createIcons()
          }
          // Keep transcription language default aligned with UI language when user changes UI language
          if (languageSelect) {
            if ([...languageSelect.options].some(o => o.value === lang)) {
              languageSelect.value = lang
            }
          }
          updateTranscriptionDirectionUI()
        })
      }
      const settingsModal = document.getElementById("settings-modal")
      const closeSettings = document.getElementById("close-settings")
      const cancelSettings = document.getElementById("cancel-settings")
      const clearSettings = document.getElementById("clear-settings")
      const settingsForm = document.getElementById("settings-form")
      const runpodTokenInput = document.getElementById("runpod-token")

      async function initTranscriptionLanguages() {
        try {
          const resp = await fetch('/languages')
          const data = await resp.json()
          const langs = (data && data.languages) ? data.languages : {}
          if (!languageSelect) return
          languageSelect.innerHTML = ''
          const KNOWN = [
            { key: 'he', label: '×¢×‘×¨×™×ª' },
            { key: 'en', label: 'English' },
            { key: 'fr', label: 'FranÃ§ais' },
            { key: 'es', label: 'EspaÃ±ol' },
            { key: 'de', label: 'Deutsch' },
            { key: 'zh', label: 'ä¸­æ–‡' },
          ]
          const addIfEnabled = ({ key, label }) => {
            const cfg = langs[key]
            if (cfg && cfg.enabled) {
              const opt = document.createElement('option')
              opt.value = key
              opt.textContent = label
              languageSelect.appendChild(opt)
            }
          }
          KNOWN.forEach(addIfEnabled)
          const uiLang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
          if ([...languageSelect.options].some(o => o.value === uiLang)) {
            languageSelect.value = uiLang
          } else if (languageSelect.options.length > 0) {
            languageSelect.selectedIndex = 0
          }
          updateTranscriptionDirectionUI()
        } catch (e) {
          if (!languageSelect) return
          if (languageSelect.options.length === 0) {
            ;[
              { key: 'he', label: '×¢×‘×¨×™×ª' },
              { key: 'en', label: 'English' },
              { key: 'fr', label: 'FranÃ§ais' },
              { key: 'es', label: 'EspaÃ±ol' },
              { key: 'de', label: 'Deutsch' },
              { key: 'zh', label: 'ä¸­æ–‡' },
            ].forEach(({ key, label }) => {
              const opt = document.createElement('option')
              opt.value = key
              opt.textContent = label
              languageSelect.appendChild(opt)
            })
            const uiLang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
            if ([...languageSelect.options].some(o => o.value === uiLang)) {
              languageSelect.value = uiLang
            }
            updateTranscriptionDirectionUI()
          }
        }
      }

      let selectedFile = null
      let selectedFiles = []
      let batchMode = false
      const MAX_FILE_SIZE_REGULAR = 300 * 1024 * 1024 // 300MB in bytes
      const MAX_FILE_SIZE_PRIVATE = 3 * 1024 * 1024 * 1024 // 3GB in bytes
      let transcriptionSegments = []
      let activeTranscription = false
      let currentJobId = null

      // Function to get current max file size based on private key usage
      function getMaxFileSize() {
        const runpodToken = runpodTokenInput.value.trim()
        return runpodToken ? MAX_FILE_SIZE_PRIVATE : MAX_FILE_SIZE_REGULAR
      }

      // Function to get max file size text for display
      function getMaxFileSizeText() {
        const runpodToken = runpodTokenInput.value.trim()
        return runpodToken ? "3GB" : "300MB"
      }

      let displaySettings = {
        textFormat: "continuous",
        timestampFormat: "none",
        diarizationDisplay: "enabled",
      }

      function showToast(message, type = "success") {
        const toastContainer = document.getElementById("toast-container")
        const toast = document.createElement("div")
        toast.className = `toast ${type}`

        // Support multi-line messages using \n
        const formatted = (message || "").toString().replace(/\n/g, "<br />")
        toast.innerHTML = `
          <span class="toast-message">${formatted}</span>
        `

        toastContainer.appendChild(toast)

        setTimeout(() => toast.classList.add("show"), 10)

        // Duration: errors stay longer
        const duration = type === "error" ? 10000 : 3000
        setTimeout(() => {
          toast.classList.remove("show")
          setTimeout(() => toast.remove(), 300)
        }, duration)
      }

      function showFilePreview(file) {
        const preview = document.getElementById("file-preview")
        const fileName = document.getElementById("preview-file-name")
        const fileSize = document.getElementById("preview-file-size")

        fileName.textContent = file.name
        fileSize.textContent = formatFileSize(file.size)

        preview.classList.add("show")
        document.getElementById("file-name").style.display = "none"
      }

      function removeFile() {
        selectedFile = null
        transcribeBtn.disabled = true
        document.getElementById("file-preview").classList.remove("show")
        document.getElementById("file-name").style.display = "block"
        document.getElementById("file-name").textContent = ""
        fileInput.value = ""
        showToast(window.I18N.t('fileRemovedSuccess'), "success")
      }

      function formatFileSize(bytes) {
        if (bytes === 0) return "0 Bytes"
        const k = 1024
        const sizes = [
          window.I18N.t('unitBytes'),
          window.I18N.t('unitKB'),
          window.I18N.t('unitMB'),
          window.I18N.t('unitGB')
        ]
        const i = Math.floor(Math.log(bytes) / Math.log(k))
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
      }

      function toggleTheme() {
        const currentTheme = document.documentElement.getAttribute("data-theme")
        const newTheme = currentTheme === "dark" ? "light" : "dark"
        document.documentElement.setAttribute("data-theme", newTheme)
        localStorage.setItem("theme", newTheme)
        updateThemeIcon(newTheme)
      }

      function updateThemeIcon(theme) {
        const sunIcon = document.getElementById("sun-icon")
        const moonIcon = document.getElementById("moon-icon")
        const isDark = theme === "dark"
        sunIcon.style.display = isDark ? "none" : "inline-block"
        moonIcon.style.display = isDark ? "inline-block" : "none"
      }

      // Load saved theme
      const savedTheme = localStorage.getItem("theme") || "light"
      document.documentElement.setAttribute("data-theme", savedTheme)
      updateThemeIcon(savedTheme)

      // Load saved display settings
      const savedDisplaySettings = localStorage.getItem("displaySettings")
      if (savedDisplaySettings) {
        displaySettings = {
          ...displaySettings,
          ...JSON.parse(savedDisplaySettings),
        }
        // Ensure diarization is enabled by default when not present
        if (!displaySettings.diarizationDisplay) {
          displaySettings.diarizationDisplay = "enabled"
        }
      }

      // Load settings from cookies and localStorage
      function loadSettings() {
        // Load RunPod token
        const token = getCookie("runpod_token")
        if (token) runpodTokenInput.value = token

        // Load display settings from localStorage
        const savedSettings = localStorage.getItem("displaySettings")
        if (savedSettings) {
          displaySettings = { ...displaySettings, ...JSON.parse(savedSettings) }
          // Ensure diarizationDisplay has a default value if not present in saved settings
          if (!displaySettings.diarizationDisplay) {
            displaySettings.diarizationDisplay = "enabled"
          }
        }

        // Toggle UI update removed - toggles only in Viewer tab

        // Update settings button appearance if credentials are saved
        updateSettingsButtonIndicator()
      }

      // Update settings button to show if credentials are saved
      function updateSettingsButtonIndicator() {
        const token = getCookie("runpod_token")
        const hasCredentials = token

        if (hasCredentials) {
          settingsBtn.style.color = "#4CAF50"
          settingsBtn.title = window.I18N.t('settingsWithRunpodSaved')
        } else {
          settingsBtn.style.color = "#666"
          settingsBtn.title = window.I18N.t('settings')
        }
      }

      // Save settings to cookies and localStorage
      async function saveSettings() {
        // Save display settings
        const textFormat = displaySettings.textFormat || "continuous"
        const timestampFormat = displaySettings.timestampFormat || "none"
        const diarizationDisplay = displaySettings.diarizationDisplay || "enabled"

        displaySettings.textFormat = textFormat
        displaySettings.timestampFormat = timestampFormat
        displaySettings.diarizationDisplay = diarizationDisplay
        localStorage.setItem("displaySettings", JSON.stringify(displaySettings))

        // Update transcription display if there are results
        if (transcriptionSegments.length > 0) {
          updateTranscriptionDisplay()
        }

        const token = runpodTokenInput.value.trim()

        // If token is empty, just clear the RunPod credentials but keep display settings
        if (!token) {
          deleteCookie("runpod_token")
          settingsModal.style.display = "none"
          settingsModal.classList.remove("show")
          updateSettingsButtonIndicator()
          showToast(window.I18N.t('settingsSaved'), "success")
          return
        }

        // Show loading state
        const saveBtn = document.querySelector(
          '#settings-form button[type="submit"]'
        )
        const originalText = saveBtn.textContent
        saveBtn.textContent = window.I18N.t('verifyChecking')
        saveBtn.disabled = true

        try {
          // Verify credentials by checking balance
          const response = await fetch(
            `/balance?runpod_token=${encodeURIComponent(token)}`
          )
          const data = await response.json()

          if (!response.ok) {
            showToast(
              `×©×’×™××” ×‘×‘×“×™×§×ª ×”×’×“×¨×•×ª RunPod:\n${response.status}: ${data.error}`,
              "error"
            )
          } else {
            // Credentials are valid, check endpoint
            const endpointResult = await checkAndCreateEndpoint(token)

            if (endpointResult.success) {
              // Save credentials
              setCookie("runpod_token", token, 365 * 24 * 60 * 60) // 1 year

              let successMessage = window.I18N.t('runpodSettingsSaved')
              if (endpointResult.needsWait) {
                successMessage += ' ' + window.I18N.t('runpodEndpointWait')
              }
              showToast(successMessage, "success")
              settingsModal.style.display = "none"
              settingsModal.classList.remove("show")
              updateSettingsButtonIndicator()
              checkBalance() // Update balance display
            } else {
              showToast(`${window.I18N.t('endpointCheckError')}\n${endpointResult.error || ''}`.trim(), "error")
            }
          }
        } catch (error) {
          console.error("Error verifying credentials:", error)
          if (
            error.name === "TypeError" &&
            error.message.includes("Failed to fetch")
          ) {
            showToast(
              "×©×’×™××”: ×œ× × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨ ×œ×©×¨×ª RunPod.\n×× × ×‘×“×•×§ ××ª ×”×—×™×‘×•×¨ ×œ××™× ×˜×¨× ×˜ ×•× ×¡×” ×©×•×‘.",
              "error"
            )
          } else {
            showToast(`×©×’×™××” ×‘×‘×“×™×§×ª ×”×’×“×¨×•×ª RunPod.\n ${error.message}`, "error")
          }
        } finally {
          // Restore button state
          saveBtn.textContent = originalText
          saveBtn.disabled = false
        }
      }

      // Clear all settings
      function clearAllSettings() {
        // Clear RunPod settings
        deleteCookie("runpod_token")
        runpodTokenInput.value = ""

        // Clear display settings
        displaySettings = {
          textFormat: "continuous",
          timestampFormat: "none",
        }
        localStorage.removeItem("displaySettings")

        // Reset form controls to defaults
        displaySettings.textFormat = "continuous"
        displaySettings.timestampFormat = "none"
        displaySettings.diarizationDisplay = "enabled"

        // Toggle UI and display updates removed - only in Viewer tab

        showToast("×›×œ ×”×”×’×“×¨×•×ª × ××—×§×• ×‘×”×¦×œ×—×”", "success")
        settingsModal.style.display = "none"
        settingsModal.classList.remove("show")
        updateSettingsButtonIndicator()

        // Hide balance container when credentials are cleared
        const balanceContainer = document.getElementById("balance-container")
        balanceContainer.classList.remove("visible")
      }

      // Cookie utility functions
      function setCookie(name, value, days) {
        const expires = new Date()
        expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000)
        document.cookie =
          name + "=" + value + ";expires=" + expires.toUTCString() + ";path=/"
      }

      function getCookie(name) {
        const nameEQ = name + "="
        const ca = document.cookie.split(";")
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i]
          while (c.charAt(0) === " ") c = c.substring(1, c.length)
          if (c.indexOf(nameEQ) === 0)
            return c.substring(nameEQ.length, c.length)
        }
        return null
      }

      function deleteCookie(name) {
        document.cookie =
          name + "=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/;"
      }

      // Check for RunPod credentials and fetch balance via backend API
      async function checkBalance() {
        const token = getCookie("runpod_token")

        if (token) {
          const balanceContainer = document.getElementById("balance-container")
          const balanceAmount = document.getElementById("balance-amount")

          balanceContainer.classList.add("visible")
          balanceAmount.textContent = window.I18N.t('loading')
          balanceAmount.className = "balance-amount balance-loading"

          try {
            const response = await fetch(
              `/balance?runpod_token=${encodeURIComponent(token)}`
            )
            const data = await response.json()

            if (response.ok && data.clientBalance !== "N/A") {
              const formattedBalance = parseFloat(data.clientBalance).toFixed(2)
              balanceAmount.textContent = `$${formattedBalance}`
              balanceAmount.className = "balance-amount"
            } else {
              balanceAmount.textContent = window.I18N.t('balanceLoadingError')
              balanceAmount.className = "balance-amount"
            }
          } catch (error) {
            console.error("Balance fetch error:", error)
            balanceAmount.textContent = window.I18N.t('balanceLoadingError')
            balanceAmount.className = "balance-amount"
          }
        }
      }

      // Check and create endpoint if needed (called automatically when saving settings)
      async function checkAndCreateEndpoint(token) {
        try {
          const response = await fetch("/check_endpoint", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              runpod_token: token,
            }),
          })

          const data = await response.json()

          if (response.ok) {
            if (data.action === "up_to_date") {
              console.log("Endpoint is up to date")
              return { success: true, needsWait: false }
            } else if (data.action === "updated") {
              console.log("Endpoint was updated")
              return { success: true, needsWait: true }
            } else if (data.action === "created") {
              console.log("New endpoint was created")
              return { success: true, needsWait: true }
            }
          } else {
            console.error("Endpoint check failed:", data.error)
            return { success: false, error: data.error }
          }
        } catch (error) {
          console.error("Error checking endpoint:", error)
          return { success: false, error: "×©×’×™××” ×‘×‘×“×™×§×ª ×”-endpoint" }
        }
      }

      // Initialize settings button indicator on page load
      updateSettingsButtonIndicator()

      // Check balance on page load
      checkBalance()

      // Settings modal handlers
      settingsBtn.addEventListener("click", () => {
        settingsModal.style.display = "block"
        settingsModal.classList.add("show")
        loadSettings()
      })

      closeSettings.addEventListener("click", () => {
        settingsModal.style.display = "none"
        settingsModal.classList.remove("show")
      })

      cancelSettings.addEventListener("click", () => {
        settingsModal.style.display = "none"
        settingsModal.classList.remove("show")
      })

      clearSettings.addEventListener("click", clearAllSettings)

      settingsForm.addEventListener("submit", async (e) => {
        e.preventDefault()
        await saveSettings()
      })

      // Close modal when clicking outside
      window.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
          settingsModal.style.display = "none"
          settingsModal.classList.remove("show")
        }
      })
      
      // Close download menus when clicking outside
      document.addEventListener("click", (e) => {
        // Check if click is outside any download menu
        const downloadMenu = e.target.closest('.file-item-download-menu')
        if (!downloadMenu) {
          // Close all open download menus
          document.querySelectorAll('.file-item-download-menu.open').forEach(menu => {
            menu.classList.remove('open')
          })
        }
      })
      ;["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        dropArea.addEventListener(eventName, preventDefaults, false)
      })

      function preventDefaults(e) {
        e.preventDefault()
        e.stopPropagation()
      }

      ;["dragenter", "dragover"].forEach((eventName) => {
        dropArea.addEventListener(eventName, highlight, false)
      })
      ;["dragleave", "drop"].forEach((eventName) => {
        dropArea.addEventListener(eventName, unhighlight, false)
      })

      function highlight() {
        dropArea.classList.add("highlight")
      }

      function unhighlight() {
        dropArea.classList.remove("highlight")
      }

      dropArea.addEventListener("drop", handleDrop, false)

      async function handleDrop(e) {
        const dt = e.dataTransfer
        // Allow dropping multiple files/folders only with private key
        const isPrivate = (runpodTokenInput && runpodTokenInput.value.trim()) || getCookie("runpod_token")
        if (isPrivate && dt.items && dt.items.length) {
          const files = await extractFilesFromDataTransfer(dt)
          handleFiles(files)
        } else {
          handleFiles(dt.files)
        }
      }

      async function extractFilesFromDataTransfer(dt) {
        const out = []
        const items = dt.items
        if (!items || !items.length) return Array.from(dt.files || [])

        const traverseEntry = async (entry) => {
          return new Promise((resolve) => {
            try {
              if (entry.isFile) {
                entry.file((file) => resolve([file]))
              } else if (entry.isDirectory) {
                const dirReader = entry.createReader()
                const all = []
                const readAll = () => {
                  dirReader.readEntries(async (entries) => {
                    if (!entries.length) {
                      resolve(all)
                      return
                    }
                    const promises = entries.map((ent) => traverseEntry(ent))
                    Promise.all(promises).then((nested) => {
                      nested.forEach((arr) => all.push(...arr))
                      readAll()
                    })
                  })
                }
                readAll()
              } else {
                resolve([])
              }
            } catch (err) {
              resolve([])
            }
          })
        }

        const entryPromises = []
        for (let i = 0; i < items.length; i++) {
          const item = items[i]
          if (item.webkitGetAsEntry) {
            const entry = item.webkitGetAsEntry()
            if (entry) entryPromises.push(traverseEntry(entry))
          } else if (item.kind === "file") {
            const f = item.getAsFile()
            if (f) out.push(f)
          }
        }

        const nested = await Promise.all(entryPromises)
        nested.forEach((arr) => out.push(...arr))
        return out
      }

      fileInput.addEventListener("change", function () {
        handleFiles(this.files)
      })

      function handleFiles(files) {
        const isPrivate = (runpodTokenInput && runpodTokenInput.value.trim()) || getCookie("runpod_token")
        const list = Array.from(files || [])
        if (!list.length) return

        if (isPrivate && list.length > 1) {
          // Multi-file mode (private key only)
          const maxSize = getMaxFileSize()
          const maxText = getMaxFileSizeText()
          const valid = []
          for (const f of list) {
            if (f.size > maxSize) {
              showToast((window.I18N ? window.I18N.t('fileTooLarge', { size: maxText }) : `×”×§×•×‘×¥ ×’×“×•×œ ××“×™. ×”×’×•×“×œ ×”××§×¡×™××œ×™ ×”××•×ª×¨ ×”×•× ${maxText}`) + `: ${f.name}`, "error")
              continue
            }
            valid.push(f)
          }
          if (!valid.length) {
            selectedFiles = []
            batchMode = false
            transcribeBtn.disabled = true
            return
          }
          selectedFiles = valid
          selectedFile = null
          batchMode = true
          transcribeBtn.disabled = false
          document.getElementById("file-preview").classList.remove("show")
          document.getElementById("file-name").style.display = "block"
          document.getElementById("file-name").textContent = (window.I18N ? window.I18N.t('filesSelectedCount', { count: valid.length }) : `${valid.length} ×§×‘×¦×™× × ×‘×—×¨×•`)
          showToast((window.I18N ? window.I18N.t('filesSelectedSuccess', { count: valid.length }) : `${valid.length} ×§×‘×¦×™× × ×‘×—×¨×• ×‘×”×¦×œ×—×”`), "success")
        } else {
          // Single-file mode
          selectedFile = list[0]
          const maxFileSize = getMaxFileSize()
          const maxFileSizeText = getMaxFileSizeText()
          if (selectedFile.size > maxFileSize) {
            showToast((window.I18N ? window.I18N.t('fileTooLarge', { size: maxFileSizeText }) : `×”×§×•×‘×¥ ×’×“×•×œ ××“×™. ×”×’×•×“×œ ×”××§×¡×™××œ×™ ×”××•×ª×¨ ×”×•× ${maxFileSizeText}`), "error")
            selectedFile = null
            transcribeBtn.disabled = true
            fileName.textContent = ""
          } else {
            selectedFiles = []
            batchMode = false
            transcribeBtn.disabled = false
            showFilePreview(selectedFile)
            showToast((window.I18N ? window.I18N.t('fileSelectedSuccess') : "×§×•×‘×¥ × ×‘×—×¨ ×‘×”×¦×œ×—×”"), "success")
          }
        }
      }

      dropArea.addEventListener("click", () => {
        const isPrivate = (runpodTokenInput && runpodTokenInput.value.trim()) || getCookie("runpod_token")
        if (isPrivate) {
          fileInput.setAttribute("multiple", "multiple")
        } else {
          fileInput.removeAttribute("multiple")
        }
        // Keep chooser as files-only; folders are supported via drag & drop
        fileInput.click()
      })

      transcribeBtn.addEventListener("click", function () {
        if (batchMode && selectedFiles.length > 0) {
          uploadBatch()
        } else {
          uploadFile()
        }
      })

      function uploadFile() {
        if (!selectedFile) return

        const formData = new FormData()
        formData.append("file", selectedFile)

        // Add RunPod credentials if available
        const token = getCookie("runpod_token")
        if (token) {
          formData.append("runpod_token", token)
        }

        // Include selected transcription language for backend
        try {
          const selectedLang = (languageSelect && languageSelect.value) ? languageSelect.value : ((window.I18N && window.I18N.current) ? window.I18N.current : 'he')
          formData.append('language', selectedLang)
        } catch {}

        transcribeBtn.disabled = true
        progressContainer.style.display = "block"
        progressBar.style.width = "0%"
        transcriptionSegments = []
        currentJobId = null

        const xhr = new XMLHttpRequest()
        xhr.open("POST", "/upload", true)

        xhr.upload.onprogress = function (event) {
          if (event.lengthComputable) {
            const percentComplete = (event.loaded / event.total) * 100
            progressBar.style.width = percentComplete + "%"
          }
        }

        xhr.onload = function () {
          if (xhr.status === 200) {
            const response = JSON.parse(xhr.responseText)
            if (response.error) {
              showError(response.error)
            } else {
              // Job queued successfully
              resetUploadState()
              activeTranscription = false
              showToast((window.I18N ? window.I18N.t('transcriptionQueued') : '×”×§×•×‘×¥ × ×©×œ×— ×œ×ª××œ×•×œ ×‘×”×¦×œ×—×”. ×”×ª×•×¦××•×ª ×™×•×¤×™×¢×• ×‘"×”×§×‘×¦×™× ×©×œ×™" ×›×©×™×¡×ª×™×™××•.'), 'success')
              // Switch to My Files tab
              switchTab('files')
            }
          } else {
            let errorMessage = undefined
            try {
              const response = JSON.parse(xhr.responseText)
              if (response.error) {
                errorMessage = response.error
              }
            } catch (e) {
              // If parsing fails, use statusText as fallback
            }

            let reportMessage = `${errorMessage}`

            if (!errorMessage) {
              const currentTime = new Date().toISOString()
              reportMessage = window.I18N.t('errorReportTemplate', { time: currentTime, details: xhr.statusText })
            }

            showError(reportMessage)
          }
        }

        xhr.onerror = function () {
          showError(window.I18N.t('uploadError'))
        }

        xhr.send(formData)
      }

      async function uploadBatch() {
        if (!selectedFiles || selectedFiles.length === 0) return

        transcribeBtn.disabled = true
        progressContainer.style.display = "block"
        progressBar.style.width = "0%"

        const token = getCookie("runpod_token")
        const selectedLang = (languageSelect && languageSelect.value) ? languageSelect.value : ((window.I18N && window.I18N.current) ? window.I18N.current : 'he')

        let successCount = 0
        for (let i = 0; i < selectedFiles.length; i++) {
          const file = selectedFiles[i]

          const formData = new FormData()
          formData.append("file", file)
          formData.append('language', selectedLang)
          if (token) formData.append("runpod_token", token)

          try {
            const resp = await fetch("/upload", { method: "POST", body: formData })
            const data = await resp.json()
            if (!resp.ok || data.error) {
              const err = data && data.error ? data.error : (window.I18N ? window.I18N.t('uploadError') : '×©×’×™××ª ×”×¢×œ××”')
              showToast(`${file.name}: ${err}`, "error")
              continue
            }
            successCount++
            // Update progress
            progressBar.style.width = `${(i + 1) / selectedFiles.length * 100}%`
          } catch (err) {
            showToast(`${file.name}: ${(window.I18N ? window.I18N.t('uploadError') : '×©×’×™××ª ×”×¢×œ××”')}`, "error")
            continue
          }
        }

        resetUploadState()
        activeTranscription = false
        if (successCount > 0) {
          showToast((window.I18N ? window.I18N.t('batchQueued', { count: successCount }) : `${successCount} ×§×‘×¦×™× × ×©×œ×—×• ×œ×ª××œ×•×œ ×‘×”×¦×œ×—×”. ×”×ª×•×¦××•×ª ×™×•×¤×™×¢×• ×‘"×”×§×‘×¦×™× ×©×œ×™" ×›×©×™×¡×ª×™×™××•.`), 'success')
          // Switch to My Files tab
          switchTab('files')
        } else {
          showToast((window.I18N ? window.I18N.t('batchFailed') : '×›×œ ×”×§×‘×¦×™× × ×›×©×œ×•'), 'error')
        }
      }

      function buildDocxHTMLFromSegmentsParam(segments, language) {
        const docLang = language || getTranscriptionLanguage()
        const diarizationEnabled = displaySettings.diarizationDisplay !== "disabled"
        const speakerColors = {
          1: "#2196F3",
          2: "#4CAF50",
          3: "#FF9800",
          4: "#9C27B0",
          5: "#009688",
          6: "#E91E63",
          7: "#3F51B5",
          8: "#795548",
          9: "#607D8B",
          10: "#8BC34A"
        }
        const esc = (text) => String(text || '').replace(/[&<>]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]))

        const lines = []
        const isRTL = ['he', 'yi'].includes(docLang)
        lines.push('<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40">')
        lines.push('<head><meta charset="utf-8"><title>Transcript</title></head>')
        lines.push('<body style="font-family:\'Arial\', \'Helvetica\', sans-serif; font-size:12pt; direction:' + (isRTL ? 'rtl' : 'ltr') + '; text-align:' + (isRTL ? 'right' : 'left') + '">')

        if (displaySettings.timestampFormat === "segments") {
          for (let i = 0; i < segments.length; i++) {
            const seg = segments[i]
            const text = esc((seg.text || '').trim())
            const start = formatTimeForDisplay(seg.start || 0)
            const end = formatTimeForDisplay(seg.end || 0)
            if (diarizationEnabled) {
              if (seg.speakers && seg.speakers.length > 0) {
                const speakerNumber = parseInt(seg.speakers[0].replace('SPEAKER_', '')) || 0
                const colorIndex = ((speakerNumber - 1) % 10) + 1
                const color = speakerColors[colorIndex] || '#000000'
                const label = (typeof translateSpeakerLabelText === 'function' ? translateSpeakerLabelText(docLang, speakerNumber) : ('Speaker ' + speakerNumber)) + ': '
                lines.push('<p>[' + start + '-' + end + '] ' + '<span style="color:' + color + '; font-weight:700">' + label + '</span>' + text + '</p>')
              } else {
                const unknownText = (typeof translateSpeakerUnknownText === 'function' ? translateSpeakerUnknownText(docLang) : 'Unknown speaker')
                lines.push('<p>[' + start + '-' + end + '] ' + '<span style="font-weight:700">' + unknownText + ': </span>' + text + '</p>')
              }
            } else {
              lines.push('<p>[' + start + '-' + end + '] ' + text + '</p>')
            }
          }
        } else {
          let currentSpeaker = undefined
          let bufferParts = []
          let currentLabelHTML = ''

          const flushParagraph = () => {
            if (bufferParts.length === 0) return
            const content = bufferParts.join(' ').trim()
            if (currentLabelHTML) {
              lines.push('<p>' + currentLabelHTML + content + '</p>')
            } else {
              lines.push('<p>' + content + '</p>')
            }
            bufferParts = []
            currentLabelHTML = ''
          }

          for (let i = 0; i < segments.length; i++) {
            const seg = segments[i]
            const rawSpeaker = seg.speakers && seg.speakers.length > 0 ? seg.speakers[0] : null
            const segText = esc((seg.text || '').trim())
            const speakerChanged = i === 0 ? true : rawSpeaker !== currentSpeaker
            if (speakerChanged) {
              flushParagraph()
              if (diarizationEnabled) {
                if (rawSpeaker) {
                  const speakerNumber = parseInt(rawSpeaker.replace('SPEAKER_', '')) || 0
                  const colorIndex = ((speakerNumber - 1) % 10) + 1
                  const color = speakerColors[colorIndex] || '#000000'
                  const label = (typeof translateSpeakerLabelText === 'function' ? translateSpeakerLabelText(docLang, speakerNumber) : ('Speaker ' + speakerNumber)) + ': '
                  currentLabelHTML = '<span style="color:' + color + '; font-weight:700">' + label + '</span>'
                } else {
                  const unknownText = (typeof translateSpeakerUnknownText === 'function' ? translateSpeakerUnknownText(docLang) : 'Unknown speaker')
                  currentLabelHTML = '<span style="font-weight:700">' + unknownText + ': </span>'
                }
              } else {
                currentLabelHTML = ''
              }
              currentSpeaker = rawSpeaker
            }
            if (segText) bufferParts.push(segText)
          }
          flushParagraph()
        }

        lines.push('<p style="color:#666; font-size:10pt; margin-top:16pt">' + (window.I18N ? window.I18N.t('transcriptFooter') : '×ª×•××œ×œ ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×”×ª××œ×•×œ ×©×œ ivrit.ai') + '</p>')
        lines.push('</body>')
        lines.push('</html>')
        return lines.join('\n')
      }


      function formatWithTimecodes(segments) {
        if (!segments || segments.length === 0) return ""

        const separator =
          displaySettings.textFormat === "continuous" ? " " : "<br>"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30 // Start with 30 seconds

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          // Check if this segment should end the current group
          const shouldEndGroup =
            (segment.start <= currentTimeMarker &&
              segment.end >= currentTimeMarker) ||
            i === segments.length - 1 || // Last segment
            (i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            // Get start time of first segment and end time of last segment in group
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            const groupText = displaySettings.diarizationDisplay === "enabled"
              ? joinSegmentsWithSpeakerChanges(currentGroup, separator, "<br>", true)
              : currentGroup.map((seg) => seg.text.trim()).join(separator)

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push(
              "[" +
                formattedStartTime +
                "-" +
                formattedEndTime +
                "]<br>" +
                groupText
            )

            // Reset for next group
            currentGroup = []
            currentTimeMarker += 30

            // Handle case where we need to advance time marker further
            while (
              i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker
            ) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("<br><br>")
      }

      function formatTimeForDisplay(seconds) {
        const hours = Math.floor(seconds / 3600)
        const minutes = Math.floor((seconds % 3600) / 60)
        const secs = Math.floor(seconds % 60)

        if (hours > 0) {
          return `${hours}:${String(minutes).padStart(2, "0")}:${String(
            secs
          ).padStart(2, "0")}`
        } else {
          return `${minutes}:${String(secs).padStart(2, "0")}`
        }
      }

      // Update transcription area direction and alignment based on selected language
      function updateTranscriptionDirectionUI() {
        // No-op: transcription display removed from new transcript tab
        // Viewer tab handles its own direction
      }

      // Speaker label localization should follow the transcription target language, not UI language
      function getTranscriptionLanguage() {
        try {
          if (languageSelect && languageSelect.value) return languageSelect.value
        } catch {}
        return (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
      }

      const SPEAKER_I18N = {
        he: { speaker: '×“×•×‘×¨ {num}', unknown: '×“×•×‘×¨ ×œ× ××–×•×”×”' },
        yi: { speaker: '×¨×¢×“× ×“×™×§×¢×¨ {num}', unknown: '× ×™×˜Ö¾×™×“×¢× ×˜×™×¤Ö¿×™×¦×™×¨×˜×¢×¨ ×¨×¢×“× ×“×™×§×¢×¨' },
        en: { speaker: 'Speaker {num}', unknown: 'Unknown speaker' },
        fr: { speaker: 'Locuteur {num}', unknown: 'Locuteur inconnu' },
        es: { speaker: 'Hablante {num}', unknown: 'Hablante desconocido' },
        de: { speaker: 'Sprecher {num}', unknown: 'Unbekannter Sprecher' },
        zh: { speaker: 'è¯´è¯è€… {num}', unknown: 'æœªçŸ¥è¯´è¯è€…' }
      }

      function translateSpeakerLabelText(lang, num) {
        const entry = SPEAKER_I18N[lang] || SPEAKER_I18N['en']
        const template = entry.speaker || 'Speaker {num}'
        return String(template).replace('{num}', String(num))
      }

      function translateSpeakerUnknownText(lang) {
        const entry = SPEAKER_I18N[lang] || SPEAKER_I18N['en']
        return entry.unknown || 'Unknown speaker'
      }

      function getSpeakerLabel(segment) {
        const lang = getTranscriptionLanguage()
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(segment.speakers[0].replace("SPEAKER_", ""))
          const speakerLabelText = translateSpeakerLabelText(lang, speakerNumber)
          return `<span class="speaker speaker-${speakerNumber}">${speakerLabelText}: </span>`
        }
        return `<span class="speaker">${translateSpeakerUnknownText(lang)}: </span>`
      }
      
      function getSpeakerLabelPlain(segment) {
        const lang = getTranscriptionLanguage()
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(segment.speakers[0].replace("SPEAKER_", ""))
          return `${translateSpeakerLabelText(lang, speakerNumber)}: `
        }
        return `${translateSpeakerUnknownText(lang)}: `
      }
      
      function getPlainTextFromSegments() {
        if (!transcriptionSegments || transcriptionSegments.length === 0) {
          return ""
        }
        
        let result
        if (displaySettings.timestampFormat === "segments") {
          result = formatWithTimecodesPlain(transcriptionSegments)
        } else {
          const continuousSeparator = displaySettings.textFormat === "continuous" ? " " : "\n"
          const segmentSeparator = "\n"
          result = joinSegmentsWithSpeakerChanges(transcriptionSegments, continuousSeparator, segmentSeparator, false)
        }
        
        return result + "\n\n" + (window.I18N ? window.I18N.t('transcriptFooter') : "×ª×•××œ×œ ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×”×ª××œ×•×œ ×©×œ ivrit.ai")
      }
      
      function formatWithTimecodesPlain(segments) {
        if (!segments || segments.length === 0) return ""

        const separator =
          displaySettings.textFormat === "continuous" ? " " : "\n"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30 // Start with 30 seconds

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          // Check if this segment should end the current group
          const shouldEndGroup =
            (segment.start <= currentTimeMarker &&
              segment.end >= currentTimeMarker) ||
            i === segments.length - 1 || // Last segment
            (i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            // Get start time of first segment and end time of last segment in group
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            const groupText = displaySettings.diarizationDisplay === "enabled"
              ? joinSegmentsWithSpeakerChanges(currentGroup, separator, "\n", false)
              : currentGroup.map((seg) => seg.text.trim()).join(separator)

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push(
              "[" +
                formattedStartTime +
                "-" +
                formattedEndTime +
                "]\n" +
                groupText
            )

            // Reset for next group
            currentGroup = []
            currentTimeMarker += 30

            // Handle case where we need to advance time marker further
            while (
              i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker
            ) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("\n\n")
      }

      function showError(message) {
        showToast(`${window.I18N.t('errorPrefix')}: ${message}`, 'error')
        resetAllState()
      }

      function joinSegmentsWithSpeakerChanges(segments, continuousSeparator, segmentSeparator, isHTML = true) {
        if (!segments || segments.length === 0) return ""
        
        const result = []
        let currentSpeaker = null
        const diarizationEnabled = displaySettings.diarizationDisplay === "enabled"
        
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          const segmentSpeaker = segment.speakers && segment.speakers.length > 0 ? segment.speakers[0] : null
          
          // Determine if we should show the speaker label (only if diarization is enabled)
          const showSpeakerLabel = diarizationEnabled && segmentSpeaker !== currentSpeaker
          
          // Get segment text with or without speaker label
          const segmentText = showSpeakerLabel 
            ? (isHTML ? getSpeakerLabel(segment) + segment.text.trim() : getSpeakerLabelPlain(segment) + segment.text.trim())
            : segment.text.trim()
          
          if (i === 0) {
            // First segment
            result.push(segmentText)
            currentSpeaker = segmentSpeaker
          } else if (diarizationEnabled && segmentSpeaker !== currentSpeaker) {
            // Speaker changed and diarization enabled - use double line break
            result.push('<br><br>' + segmentText)
            currentSpeaker = segmentSpeaker
          } else {
            // Same speaker OR diarization disabled - use the appropriate separator based on format
            result.push(continuousSeparator + segmentText)
            if (diarizationEnabled) {
              currentSpeaker = segmentSpeaker
            }
          }
        }
        
        return result.join("")
      }

      // updateTranscriptionDisplay and toggle UI functions removed
      // Display and controls only exist in Viewer tab

      function resetUploadState() {
        transcribeBtn.disabled = true
        selectedFile = null
        selectedFiles = []
        batchMode = false
        fileName.textContent = ""
        const filePreview = document.getElementById("file-preview")
        if (filePreview) {
          filePreview.classList.remove("show")
        }
        const fileInput = document.getElementById("file-input")
        if (fileInput) {
          fileInput.value = ""
        }
        const fileNameElement = document.getElementById("file-name")
        if (fileNameElement) {
          fileNameElement.style.display = "block"
        }
        progressContainer.style.display = "none"
        progressBar.style.width = "0%"
      }

      function resetAllState() {
        transcribeBtn.disabled = false
        selectedFile = null
        fileName.textContent = ""
        progressContainer.style.display = "none"
        progressBar.style.width = "0%"
        currentJobId = null
        transcriptionSegments = []
      }

      // Event listeners for new transcript tab buttons removed
      // All viewing and download functionality is now in the Viewer tab

      function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600)
        const minutes = Math.floor((seconds % 3600) / 60)
        const secs = Math.floor(seconds % 60)
        const ms = Math.floor((seconds % 1) * 1000)
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
          2,
          "0"
        )}:${String(secs).padStart(2, "0")}.${String(ms).padStart(3, "0")}`
      }

      // Custom confirmation dialog
      function showExitWarning() {
        return confirm(
          window.I18N.t('exitWarning')
        )
      }

      window.addEventListener("beforeunload", function (e) {
        if (activeTranscription) {
          // Show confirmation dialog
          e.preventDefault()
          e.returnValue = window.I18N.t('exitWarning')
          return e.returnValue
        }
      })

      // Handle refresh key combinations
      window.addEventListener("keydown", function (e) {
        if (
          activeTranscription &&
          (e.key === "F5" || (e.key === "r" && (e.ctrlKey || e.metaKey)))
        ) {
          if (!showExitWarning()) {
            e.preventDefault()
            return false
          }
        }
      })

      // Handle clicks on links
      document.addEventListener("click", function (e) {
        if (!activeTranscription) return

        const link = e.target.closest("a")
        if (link && !link.hasAttribute("download")) {
          if (!showExitWarning()) {
            e.preventDefault()
            return false
          }
        }
      })

      // Tab switching functionality
      function initTabs() {
        const tabButtons = document.querySelectorAll('.tab-button')
        
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const tabName = button.getAttribute('data-tab')
            switchTab(tabName)
          })
        })
      }

      function switchTab(tabName) {
        // Update button states
        document.querySelectorAll('.tab-button').forEach(btn => {
          if (btn.getAttribute('data-tab') === tabName) {
            btn.classList.add('active')
          } else {
            btn.classList.remove('active')
          }
        })

        // Update content visibility
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active')
        })
        document.getElementById(`tab-${tabName}`).classList.add('active')

        // Load files when switching to files tab
        if (tabName === 'files') {
          lastKnownEntries = null  // Reset cache for fresh load
          loadSavedFiles(true)  // Show loading on tab switch
        } else {
          // Cancel auto-refresh when leaving files tab
          if (filesRefreshTimeout) {
            clearTimeout(filesRefreshTimeout)
            filesRefreshTimeout = null
          }
        }

        // Refresh Lucide icons after tab switch
        if (window.lucide && typeof window.lucide.createIcons === 'function') {
          window.lucide.createIcons()
        }
      }

      // Store last known entries for comparison
      let lastKnownEntries = null

      // Load saved files from Google Drive TOC
      async function loadSavedFiles(showLoading = true) {
        const filesLoading = document.getElementById('files-loading')
        const filesError = document.getElementById('files-error')
        const filesEmpty = document.getElementById('files-empty')
        const filesList = document.getElementById('files-list')
        const filesErrorMessage = document.getElementById('files-error-message')

        // Show loading state only on initial load
        if (showLoading) {
          filesLoading.style.display = 'block'
          filesError.style.display = 'none'
          filesEmpty.style.display = 'none'
          filesList.innerHTML = ''
        }

        try {
          const response = await fetch('/appdata/toc')
          const data = await response.json()

          if (showLoading) {
            filesLoading.style.display = 'none'
          }

          if (!response.ok) {
            if (showLoading) {
              filesError.style.display = 'block'
              filesErrorMessage.textContent = data.error || (window.I18N ? window.I18N.t('filesLoadError') : '×©×’×™××” ×‘×˜×¢×™× ×ª ×”×§×‘×¦×™×')
            }
            // Silent failure for background refresh
            return
          }

          const entries = data.entries || []

          // Check if data actually changed
          const entriesChanged = !lastKnownEntries || 
            JSON.stringify(entries) !== JSON.stringify(lastKnownEntries)
          
          if (!entriesChanged && !showLoading) {
            // No changes, just schedule next refresh
            scheduleFilesRefresh(entries)
            return
          }

          // Update last known entries
          lastKnownEntries = entries

          if (entries.length === 0) {
            if (showLoading) {
              filesEmpty.style.display = 'block'
            }
            scheduleFilesRefresh(entries)
            return
          }

          // Sort entries: active jobs first (Queued, Being processed), then by time
          entries.sort((a, b) => {
            const statusOrder = { 'Queued': 0, 'Being processed': 1, 'Ready': 2 }
            const statusA = statusOrder[a.status] !== undefined ? statusOrder[a.status] : 3
            const statusB = statusOrder[b.status] !== undefined ? statusOrder[b.status] : 3
            
            if (statusA !== statusB) {
              return statusA - statusB
            }
            
            // Within same status, sort by time (newest first)
            const dateA = new Date(a.completed_at || a.submitted_at)
            const dateB = new Date(b.completed_at || b.submitted_at)
            return dateB - dateA
          })

          // Only re-render if data changed or it's initial load
          if (entriesChanged || showLoading) {
            filesList.innerHTML = ''
            entries.forEach(entry => {
              const fileItem = createFileItemFromTOC(entry)
              filesList.appendChild(fileItem)
            })

            // Refresh Lucide icons
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
              window.lucide.createIcons()
            }
          }

          // Schedule next refresh based on job status
          scheduleFilesRefresh(entries)

        } catch (error) {
          console.error('Error loading files:', error)
          if (showLoading) {
            filesLoading.style.display = 'none'
            filesError.style.display = 'block'
            filesErrorMessage.textContent = (window.I18N ? window.I18N.t('filesLoadError') : '×©×’×™××” ×‘×˜×¢×™× ×ª ×”×§×‘×¦×™×')
          }
          // Silent failure for background refresh - still schedule next attempt
          scheduleFilesRefresh([])
        }
      }

      // Auto-refresh with adaptive polling frequency
      let filesRefreshTimeout = null
      function scheduleFilesRefresh(entries = []) {
        // Clear any existing timeout
        if (filesRefreshTimeout) {
          clearTimeout(filesRefreshTimeout)
          filesRefreshTimeout = null
        }
        
        // Check if there are active jobs
        const hasActiveJobs = entries.some(e => e.status === 'Queued' || e.status === 'Being processed')
        
        // Only poll if there are active jobs - stop polling when all done
        if (!hasActiveJobs) {
          return
        }
        
        // Poll every 5 seconds when jobs are in flight
        filesRefreshTimeout = setTimeout(() => {
          const filesTab = document.getElementById('tab-files')
          if (filesTab && filesTab.classList.contains('active')) {
            // Silent refresh (no loading indicator)
            loadSavedFiles(false)
          }
        }, 5000)
      }

      // Get localized status text
      function getStatusText(status) {
        const statusTexts = {
          'he': {
            'Queued': '×××ª×™×Ÿ ×‘×ª×•×¨',
            'Being processed': '×‘×ª×”×œ×™×š ×ª××œ×•×œ',
            'Ready': '××•×›×Ÿ'
          },
          'en': {
            'Queued': 'Queued',
            'Being processed': 'Being processed',
            'Ready': 'Ready'
          }
        }
        const lang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
        const langTexts = statusTexts[lang] || statusTexts['en']
        return langTexts[status] || status
      }

      // Format ETA seconds into human-readable string
      function formatETA(seconds) {
        if (seconds === null || seconds === undefined || seconds < 0) {
          return ''
        }
        
        const hours = Math.floor(seconds / 3600)
        const minutes = Math.floor((seconds % 3600) / 60)
        const secs = Math.floor(seconds % 60)
        
        const lang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
        
        if (hours > 0) {
          if (lang === 'he' || lang === 'yi') {
            return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`
          } else {
            return `${hours}h ${minutes}m`
          }
        } else if (minutes > 0) {
          if (lang === 'he' || lang === 'yi') {
            return `${minutes}:${String(secs).padStart(2, '0')}`
          } else {
            return `${minutes}m ${secs}s`
          }
        } else {
          if (lang === 'he' || lang === 'yi') {
            return `${secs} ×©× ×™×•×ª`
          } else {
            return `${secs}s`
          }
        }
      }

      // Store current viewer data
      let currentViewerData = null
      let currentViewerLanguage = 'he'
      let currentViewerEntry = null

      // Create file item element from TOC entry
      function createFileItemFromTOC(entry) {
        const div = document.createElement('div')
        div.className = 'file-item'

        // Status indicator
        const statusDot = document.createElement('div')
        statusDot.className = 'file-item-status'
        const status = entry.status || 'Ready'
        const statusClass = status.toLowerCase().replace(/\s+/g, '-')
        statusDot.classList.add(`status-${statusClass}`)
        statusDot.title = status

        const info = document.createElement('div')
        info.className = 'file-item-info'
        
        // Only allow clicking for ready items
        const isReady = status === 'Ready' && entry.results_id
        if (isReady) {
          info.onclick = () => viewSavedFileFromTOC(entry)
        } else {
          info.style.cursor = 'default'
        }

        const name = document.createElement('div')
        name.className = 'file-item-name'
        name.textContent = entry.source_filename || 'Untitled'

        const meta = document.createElement('div')
        meta.className = 'file-item-meta'
        
        // Show appropriate date and status text
        let dateStr = ''
        if (entry.completed_at) {
          const date = new Date(entry.completed_at)
          dateStr = date.toLocaleDateString('he-IL', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          })
        } else if (entry.submitted_at) {
          const date = new Date(entry.submitted_at)
          dateStr = date.toLocaleDateString('he-IL', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          })
        }
        
        // Add status text and ETA for non-ready items
        if (status !== 'Ready') {
          const statusText = getStatusText(status)
          let metaText = `${dateStr} (${statusText})`
          
          // Add ETA if available
          if (entry.eta_seconds !== undefined && entry.eta_seconds !== null) {
            const etaFormatted = formatETA(entry.eta_seconds)
            if (etaFormatted) {
              const lang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
              const etaLabel = lang === 'he' || lang === 'yi' ? 'ETA: ' : 'ETA: '
              metaText += ` â€¢ ${etaLabel}${etaFormatted}`
            }
          }
          
          meta.textContent = metaText
        } else {
          meta.textContent = dateStr
        }

        info.appendChild(name)
        info.appendChild(meta)

        const actions = document.createElement('div')
        actions.className = 'file-item-actions'

        // Only show download menu for ready items
        if (isReady) {
          const downloadMenu = document.createElement('div')
          downloadMenu.className = 'file-item-download-menu'
          
          const downloadBtn = document.createElement('button')
          downloadBtn.className = 'file-item-download-btn'
          downloadBtn.innerHTML = '<i data-lucide="download"></i>'
          downloadBtn.title = (window.I18N ? window.I18N.t('downloads') : '×”×•×¨×“×•×ª')
          
          const downloadDropdown = document.createElement('div')
          downloadDropdown.className = 'download-dropdown'
          
          downloadDropdown.innerHTML = `
            <div class="download-dropdown-header" data-i18n="downloadAs">×”×•×¨×“ ×›...</div>
            <button type="button" onclick="event.stopPropagation(); downloadFileFromTOC('${entry.results_id}', '${entry.source_filename}', '${entry.language}', 'vtt')">VTT</button>
            <button type="button" onclick="event.stopPropagation(); downloadFileFromTOC('${entry.results_id}', '${entry.source_filename}', '${entry.language}', 'srt')">SRT</button>
            <button type="button" onclick="event.stopPropagation(); downloadFileFromTOC('${entry.results_id}', '${entry.source_filename}', '${entry.language}', 'docx')"><span data-i18n="wordDocx">Word DOCX</span></button>
            <button type="button" onclick="event.stopPropagation(); downloadFileFromTOC('${entry.results_id}', '${entry.source_filename}', '${entry.language}', 'json')">JSON</button>
          `
          
          // Handle click on download button to toggle menu
          downloadBtn.addEventListener('click', (e) => {
            e.stopPropagation()
            // Close all other download menus
            document.querySelectorAll('.file-item-download-menu.open').forEach(menu => {
              if (menu !== downloadMenu) {
                menu.classList.remove('open')
              }
            })
            // Toggle this menu
            downloadMenu.classList.toggle('open')
          })
          
          // Close menu when clicking on dropdown items (after download)
          downloadDropdown.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
              downloadMenu.classList.remove('open')
            })
          })
          
          downloadMenu.appendChild(downloadBtn)
          downloadMenu.appendChild(downloadDropdown)
          actions.appendChild(downloadMenu)
        }

        div.appendChild(statusDot)
        div.appendChild(info)
        div.appendChild(actions)

        return div
      }

      // Helper function to decompress gzipped data
      async function decompressGzip(arrayBuffer) {
        const stream = new DecompressionStream('gzip')
        const writer = stream.writable.getWriter()
        writer.write(new Uint8Array(arrayBuffer))
        writer.close()
        
        const reader = stream.readable.getReader()
        const chunks = []
        while (true) {
          const { done, value } = await reader.read()
          if (done) break
          chunks.push(value)
        }
        
        const decompressed = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0))
        let offset = 0
        for (const chunk of chunks) {
          decompressed.set(chunk, offset)
          offset += chunk.length
        }
        
        return new TextDecoder().decode(decompressed)
      }

      // View saved file from TOC entry
      async function viewSavedFileFromTOC(entry) {
        try {
          // Fetch results (gzipped)
          const response = await fetch(`/appdata/results/${entry.results_id}`)
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }))
            showToast(errorData.error || (window.I18N ? window.I18N.t('filesLoadError') : '×©×’×™××” ×‘×˜×¢×™× ×ª ×”×§×•×‘×¥'), 'error')
            return
          }
          
          // Decompress gzipped data
          const arrayBuffer = await response.arrayBuffer()
          const decompressed = await decompressGzip(arrayBuffer)
          const data = JSON.parse(decompressed)

          // Store data for viewer (results file now contains full payload)
          currentViewerData = { results: data.results || [] }
          currentViewerLanguage = data.language || entry.language || 'he'
          currentViewerEntry = entry

          // Set filename in viewer
          document.getElementById('viewer-file-name').textContent = entry.source_filename

          // Update transcription display
          updateViewerTranscriptionDisplay()

          // Update viewer toggle UI states
          updateViewerTextFormatToggleUI()
          updateViewerTimestampsToggleUI()
          updateViewerDiarizationToggleUI()

          // Show viewer tab
          document.getElementById('viewer-tab-btn').style.display = 'block'
          switchTab('viewer')

          // Refresh Lucide icons
          if (window.lucide && typeof window.lucide.createIcons === 'function') {
            window.lucide.createIcons()
          }

        } catch (error) {
          console.error('Error viewing file:', error)
          showToast((window.I18N ? window.I18N.t('filesLoadError') : '×©×’×™××” ×‘×˜×¢×™× ×ª ×”×§×•×‘×¥'), 'error')
        }
      }

      // Download file from TOC in specific format
      async function downloadFileFromTOC(resultsId, fileName, language, format) {
        try {
          const response = await fetch(`/appdata/results/${resultsId}`)
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }))
            showToast(errorData.error || (window.I18N ? window.I18N.t('filesDownloadError') : '×©×’×™××” ×‘×”×•×¨×“×ª ×”×§×•×‘×¥'), 'error')
            return
          }
          
          // Decompress gzipped data
          const arrayBuffer = await response.arrayBuffer()
          const decompressed = await decompressGzip(arrayBuffer)
          const data = JSON.parse(decompressed)

          // Results file now contains full payload with metadata + results
          const segments = data.results || []
          const lang = data.language || language || 'he'
          downloadInFormat(segments, fileName, format, lang)

        } catch (error) {
          console.error('Error downloading file:', error)
          showToast((window.I18N ? window.I18N.t('filesDownloadError') : '×©×’×™××” ×‘×”×•×¨×“×ª ×”×§×•×‘×¥'), 'error')
        }
      }

      // Download in specified format
      function downloadInFormat(segments, originalFileName, format, language) {
        const baseName = originalFileName.replace(/\.[^/.]+$/, '')
        
        if (format === 'json') {
          const blob = new Blob([JSON.stringify(segments, null, 2)], { type: 'application/json' })
          triggerDownload(blob, `${baseName}.json`)
        } else if (format === 'vtt') {
          let vttContent = "WEBVTT\n\n"
          segments.forEach((segment, index) => {
            const startTime = formatTime(segment.start)
            const endTime = formatTime(segment.end)
            vttContent += `${index + 1}\n${startTime} --> ${endTime}\n${segment.text.trim()}\n\n`
          })
          const blob = new Blob([vttContent], { type: 'text/vtt' })
          triggerDownload(blob, `${baseName}.vtt`)
        } else if (format === 'srt') {
          let srtContent = ""
          segments.forEach((segment, index) => {
            const start = formatTime(segment.start).replace(".", ",")
            const end = formatTime(segment.end).replace(".", ",")
            srtContent += `${index + 1}\n${start} --> ${end}\n${segment.text.trim()}\n\n`
          })
          const blob = new Blob([srtContent], { type: 'text/plain' })
          triggerDownload(blob, `${baseName}.srt`)
        } else if (format === 'docx') {
          if (!window.htmlDocx || typeof window.htmlDocx.asBlob !== "function") {
            showToast((window.I18N ? window.I18N.t('docxLibMissing') : '×¡×¤×¨×™×™×ª ×™×¦×™×¨×ª ×”××¡××š ×œ× × ×˜×¢× ×”'), 'error')
            return
          }
          const html = buildDocxHTMLFromSegmentsParam(segments, language)
          const blob = window.htmlDocx.asBlob(html)
          triggerDownload(blob, `${baseName}.docx`)
        }

        showToast((window.I18N ? window.I18N.t('filesDownloadSuccess') : '×”×§×•×‘×¥ ×”×•×¨×“ ×‘×”×¦×œ×—×”'), 'success')
      }

      function triggerDownload(blob, filename) {
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = filename
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
      }

      // Update viewer transcription display
      function updateViewerTranscriptionDisplay() {
        if (!currentViewerData || !currentViewerData.results) return

        const viewerTranscription = document.getElementById('viewer-transcription')
        const segments = currentViewerData.results

        // Use same display logic as main transcription
        let result
        if (displaySettings.timestampFormat === "segments") {
          result = formatWithTimecodesForSegments(segments)
        } else {
          const continuousSeparator = displaySettings.textFormat === "continuous" ? " " : "<br>"
          const segmentSeparator = "<br>"
          result = joinSegmentsWithSpeakerChangesForSegments(segments, continuousSeparator, segmentSeparator, true)
        }

        result = result + "<br><br>" + (window.I18N ? window.I18N.t('transcriptFooter') : "×ª×•××œ×œ ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×”×ª××œ×•×œ ×©×œ ivrit.ai")

        viewerTranscription.innerHTML = result
        updateViewerTranscriptionDirectionUI()
      }

      function formatWithTimecodesForSegments(segments) {
        if (!segments || segments.length === 0) return ""

        const separator = displaySettings.textFormat === "continuous" ? " " : "<br>"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          const shouldEndGroup =
            (segment.start <= currentTimeMarker && segment.end >= currentTimeMarker) ||
            i === segments.length - 1 ||
            (i < segments.length - 1 && segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            const groupText = displaySettings.diarizationDisplay === "enabled"
              ? joinSegmentsWithSpeakerChangesForSegments(currentGroup, separator, "<br>", true)
              : currentGroup.map((seg) => seg.text.trim()).join(separator)

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push("[" + formattedStartTime + "-" + formattedEndTime + "]<br>" + groupText)

            currentGroup = []
            currentTimeMarker += 30

            while (i < segments.length - 1 && segments[i + 1].start > currentTimeMarker) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("<br><br>")
      }

      function joinSegmentsWithSpeakerChangesForSegments(segments, continuousSeparator, segmentSeparator, isHTML = true) {
        if (!segments || segments.length === 0) return ""
        
        const result = []
        let currentSpeaker = null
        const diarizationEnabled = displaySettings.diarizationDisplay === "enabled"
        
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          const segmentSpeaker = segment.speakers && segment.speakers.length > 0 ? segment.speakers[0] : null
          
          const showSpeakerLabel = diarizationEnabled && segmentSpeaker !== currentSpeaker
          
          const segmentText = showSpeakerLabel 
            ? (isHTML ? getSpeakerLabelForLanguage(segment, currentViewerLanguage) + segment.text.trim() : getSpeakerLabelPlainForLanguage(segment, currentViewerLanguage) + segment.text.trim())
            : segment.text.trim()
          
          if (i === 0) {
            result.push(segmentText)
            currentSpeaker = segmentSpeaker
          } else if (diarizationEnabled && segmentSpeaker !== currentSpeaker) {
            result.push('<br><br>' + segmentText)
            currentSpeaker = segmentSpeaker
          } else {
            result.push(continuousSeparator + segmentText)
            if (diarizationEnabled) {
              currentSpeaker = segmentSpeaker
            }
          }
        }
        
        return result.join("")
      }

      function getSpeakerLabelForLanguage(segment, lang) {
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(segment.speakers[0].replace("SPEAKER_", ""))
          const speakerLabelText = translateSpeakerLabelText(lang, speakerNumber)
          return `<span class="speaker speaker-${speakerNumber}">${speakerLabelText}: </span>`
        }
        return `<span class="speaker">${translateSpeakerUnknownText(lang)}: </span>`
      }

      function getSpeakerLabelPlainForLanguage(segment, lang) {
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(segment.speakers[0].replace("SPEAKER_", ""))
          return `${translateSpeakerLabelText(lang, speakerNumber)}: `
        }
        return `${translateSpeakerUnknownText(lang)}: `
      }

      function updateViewerTranscriptionDirectionUI() {
        const lang = currentViewerLanguage
        const rtlLangs = ['he', 'yi']
        const isRTL = rtlLangs.includes(lang)
        const viewerTranscription = document.getElementById('viewer-transcription')
        if (viewerTranscription) {
          viewerTranscription.style.direction = isRTL ? 'rtl' : 'ltr'
          viewerTranscription.style.textAlign = isRTL ? 'right' : 'left'
        }
      }

      // Wire up viewer controls
      document.getElementById('back-to-files-btn').addEventListener('click', () => {
        document.getElementById('viewer-tab-btn').style.display = 'none'
        switchTab('files')
      })

      document.getElementById('viewer-text-format-toggle').addEventListener('click', () => {
        displaySettings.textFormat = displaySettings.textFormat === "segments" ? "continuous" : "segments"
        localStorage.setItem("displaySettings", JSON.stringify(displaySettings))
        updateViewerTextFormatToggleUI()
        updateViewerTranscriptionDisplay()
      })

      document.getElementById('viewer-timestamps-toggle').addEventListener('click', () => {
        displaySettings.timestampFormat = displaySettings.timestampFormat === 'segments' ? 'none' : 'segments'
        localStorage.setItem('displaySettings', JSON.stringify(displaySettings))
        updateViewerTimestampsToggleUI()
        updateViewerTranscriptionDisplay()
      })

      document.getElementById('viewer-diarization-toggle').addEventListener('click', () => {
        displaySettings.diarizationDisplay = displaySettings.diarizationDisplay === 'enabled' ? 'disabled' : 'enabled'
        localStorage.setItem('displaySettings', JSON.stringify(displaySettings))
        updateViewerDiarizationToggleUI()
        updateViewerTranscriptionDisplay()
      })

      function updateViewerTextFormatToggleUI() {
        const btn = document.getElementById('viewer-text-format-toggle')
        const svg = document.getElementById('viewer-text-format-icon')
        const isSegments = displaySettings.textFormat === "segments"
        
        if (svg) {
          while (svg.firstChild) svg.removeChild(svg.firstChild)
          if (isSegments) {
            svg.insertAdjacentHTML("afterbegin",
              '<circle cx="20" cy="6" r="2" fill="currentColor" stroke="none" />\n' +
              '<circle cx="20" cy="12" r="2" fill="currentColor" stroke="none" />\n' +
              '<circle cx="20" cy="18" r="2" fill="currentColor" stroke="none" />\n' +
              '<path d="M17 6H4" />\n' +
              '<path d="M17 12H7" />\n' +
              '<path d="M17 18H4" />'
            )
          } else {
            svg.insertAdjacentHTML("afterbegin",
              '<path d="M4 6h16"/>\n' + '<path d="M10 12h10"/>\n' + '<path d="M4 18h16"/>'
            )
          }
        }
        
        btn.title = isSegments ? (window.I18N ? window.I18N.t('textFormatSegmentsTitle') : '×¤×•×¨××˜ ×”×˜×§×¡×˜: ×¤×¡×§××•×ª × ×¤×¨×“×•×ª') : (window.I18N ? window.I18N.t('textFormatContinuousTitle') : '×¤×•×¨××˜ ×”×˜×§×¡×˜: ×˜×§×¡×˜ ×¨×¦×™×£')
        btn.classList.toggle('toggle-active', isSegments)
      }

      function updateViewerTimestampsToggleUI() {
        const btn = document.getElementById('viewer-timestamps-toggle')
        const enabled = displaySettings.timestampFormat === "segments"
        btn.classList.toggle('toggle-active', enabled)
        btn.title = enabled ? (window.I18N ? window.I18N.t('timestampsSegments') : '×›×•×œ×œ ×§×•×“×™ ×–××Ÿ') : (window.I18N ? window.I18N.t('timestampsNone') : '×œ×œ× ×§×•×“×™ ×–××Ÿ')
      }

      function updateViewerDiarizationToggleUI() {
        const btn = document.getElementById('viewer-diarization-toggle')
        const enabled = displaySettings.diarizationDisplay === "enabled"
        btn.classList.toggle('toggle-active', enabled)
        btn.title = enabled ? (window.I18N ? window.I18N.t('diarizationEnabled') : '×”×¦×’ ×“×•×‘×¨×™×') : (window.I18N ? window.I18N.t('diarizationDisabled') : '×”×¡×ª×¨ ×“×•×‘×¨×™×')
      }

      // Copy button in viewer
      document.getElementById('viewer-copy-btn').addEventListener('click', () => {
        if (!currentViewerData || !currentViewerData.results) return
        const plainText = getPlainTextFromSegmentsForViewer(currentViewerData.results)
        navigator.clipboard.writeText(plainText).then(() => {
          showToast((window.I18N ? window.I18N.t('copySuccess') : "×”×˜×§×¡×˜ ×”×•×¢×ª×§ ×œ×œ×•×— ×‘×”×¦×œ×—×”"), "success")
        }).catch(() => {
          showToast((window.I18N ? window.I18N.t('copySuccess') : "×”×˜×§×¡×˜ ×”×•×¢×ª×§ ×œ×œ×•×— ×‘×”×¦×œ×—×”"), "success")
        })
      })

      function getPlainTextFromSegmentsForViewer(segments) {
        let result
        if (displaySettings.timestampFormat === "segments") {
          result = formatWithTimecodesPlainForViewer(segments)
        } else {
          const continuousSeparator = displaySettings.textFormat === "continuous" ? " " : "\n"
          const segmentSeparator = "\n"
          result = joinSegmentsWithSpeakerChangesForSegments(segments, continuousSeparator, segmentSeparator, false)
        }
        return result + "\n\n" + (window.I18N ? window.I18N.t('transcriptFooter') : "×ª×•××œ×œ ×‘×××¦×¢×•×ª ×©×™×¨×•×ª ×”×ª××œ×•×œ ×©×œ ivrit.ai")
      }

      function formatWithTimecodesPlainForViewer(segments) {
        if (!segments || segments.length === 0) return ""

        const separator = displaySettings.textFormat === "continuous" ? " " : "\n"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          const shouldEndGroup =
            (segment.start <= currentTimeMarker && segment.end >= currentTimeMarker) ||
            i === segments.length - 1 ||
            (i < segments.length - 1 && segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            const groupText = displaySettings.diarizationDisplay === "enabled"
              ? joinSegmentsWithSpeakerChangesForSegments(currentGroup, separator, "\n", false)
              : currentGroup.map((seg) => seg.text.trim()).join(separator)

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push("[" + formattedStartTime + "-" + formattedEndTime + "]\n" + groupText)

            currentGroup = []
            currentTimeMarker += 30

            while (i < segments.length - 1 && segments[i + 1].start > currentTimeMarker) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("\n\n")
      }

      // Viewer download menu
      document.getElementById('viewer-menu-vtt').addEventListener('click', () => {
        if (!currentViewerData) return
        const fileName = document.getElementById('viewer-file-name').textContent
        downloadInFormat(currentViewerData.results, fileName, 'vtt', currentViewerLanguage)
      })

      document.getElementById('viewer-menu-srt').addEventListener('click', () => {
        if (!currentViewerData) return
        const fileName = document.getElementById('viewer-file-name').textContent
        downloadInFormat(currentViewerData.results, fileName, 'srt', currentViewerLanguage)
      })

      document.getElementById('viewer-menu-docx').addEventListener('click', () => {
        if (!currentViewerData) return
        const fileName = document.getElementById('viewer-file-name').textContent
        downloadInFormat(currentViewerData.results, fileName, 'docx', currentViewerLanguage)
      })

      document.getElementById('viewer-menu-json').addEventListener('click', () => {
        if (!currentViewerData) return
        const fileName = document.getElementById('viewer-file-name').textContent
        downloadInFormat(currentViewerData.results, fileName, 'json', currentViewerLanguage)
      })
    </script>
  </body>
</html>
