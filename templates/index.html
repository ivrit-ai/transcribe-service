<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="{{ url_for('static', path='favicon.png') }}" />
    <title>תמלול בעזרת ivrit.ai</title>
    <script src="https://cdn.jsdelivr.net/npm/html-docx-js/dist/html-docx.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/diff@5.1.0/dist/diff.min.js"></script>
    <style>
      :root {
        --bg-color: #f5f5f5;
        --container-bg: #ffffff;
        --text-color: #333333;
        --border-color: #e0e0e0;
        --primary-color: #4caf50;
        --secondary-color: #f8f9fa;
        --input-bg: #ffffff;
      }

      [data-theme="dark"] {
        --bg-color: #1a1a1a;
        --container-bg: #2d2d2d;
        --text-color: #e0e0e0;
        --border-color: #555555;
        --primary-color: #66bb6a;
        --secondary-color: #3a3a3a;
        --input-bg: #1e1e1e;
      }

      body {
        font-family: Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
      }
      .container {
        background-color: var(--container-bg);
        padding: 2rem;
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        text-align: center;
        width: 80%;
        max-width: 600px;
        position: relative;
      }
      .settings-btn {
        position: absolute;
        top: 1rem;
        left: 1rem;
        background: none;
        border: none;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 50%;
        transition: background-color 0.2s;
      }
      .settings-btn:hover {
        background-color: #f0f0f0;
      }
      .settings-btn svg {
        width: 24px;
        height: 24px;
        color: #666;
      }
      .lang-menu {
        position: absolute;
        top: 1rem;
        left: 3.5rem;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
      }
      .lang-menu button {
        background: none;
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.45rem;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .lang-menu .dropdown {
        position: relative;
        display: inline-block;
      }
      .lang-menu .dropdown-content {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 0.25rem 0;
        min-width: 120px;
        z-index: 200;
      }
      .lang-menu .dropdown:hover .dropdown-content {
        display: block;
      }
      .lang-menu .dropdown-content button {
        display: block;
        width: 100%;
        background: none;
        border: none;
        text-align: right;
        padding: 0.4rem 0.75rem;
        cursor: pointer;
        color: var(--text-color);
      }
      .lang-menu .dropdown-content button:hover {
        background: var(--secondary-color);
        color: var(--primary-color);
      }
      .theme-toggle {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: none;
        border: none;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 50%;
        transition: background-color 0.2s;
      }
      .theme-toggle:hover {
        background-color: #f0f0f0;
      }
      .theme-toggle svg,
      .theme-toggle i[data-lucide] {
        width: 24px;
        height: 24px;
        color: #666;
      }
      .balance-container {
        display: none;
      }
      .balance-container.visible {
        display: flex;
      }
      .balance-container.compact-balance {
        position: absolute;
        top: 3.5rem;
        left: 1rem;
        background: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.5rem 0.7rem;
        font-size: 0.85rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.06);
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
        z-index: 10;
        min-width: fit-content;
      }
      .balance-container.compact-balance .balance-icon {
        display: none;
      }
      .balance-container.compact-balance a {
        font-size: 0.8rem;
        text-decoration: underline;
      }
      .balance-label {
        font-weight: bold;
        margin-bottom: 0.25rem;
      }
      .balance-amount {
        color: #28a745;
        font-weight: bold;
      }
      .balance-loading {
        color: #6c757d;
        font-style: italic;
      }
      .balance-icon svg {
        width: 18px;
        height: 18px;
        color: var(--primary-color);
        flex-shrink: 0;
      }
      .balance-text {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
        white-space: nowrap;
      }
      .balance-label {
        font-weight: 600;
        color: var(--text-color);
        font-size: 0.8rem;
      }
      .balance-amount {
        color: var(--primary-color);
        font-weight: 700;
        font-size: 0.95rem;
      }
      .balance-text {
        display: flex;
        align-items: baseline;
        gap: 0.4rem;
      }
      .modal .balance-label {
        margin: 0;
        font-weight: 600;
        color: var(--text-color);
      }
      .modal .balance-amount {
        font-size: 0.95rem;
      }
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }
      .modal.show {
        display: block;
      }
      .modal-content {
        background-color: var(--container-bg);
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 1.5rem;
        border-radius: 12px;
        width: 90%;
        max-width: 480px;
        max-height: 90vh;
        overflow-y: auto;
        text-align: right;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.25rem;
        padding-bottom: 0.75rem;
      }
      .modal-header h2 {
        margin: 0;
        font-size: 1.4rem;
        color: var(--text-color);
      }
      .close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        color: var(--text-color);
      }
      .close:hover {
        color: var(--primary-color);
      }
      .form-group {
        margin-bottom: 1rem;
        text-align: left;
      }
      .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: bold;
        color: var(--text-color);
      }
      .form-group input {
        width: 100%;
        padding: 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 1rem;
        box-sizing: border-box;
        text-align: left;
        direction: ltr;
        background-color: var(--input-bg);
        color: var(--text-color);
      }
      .form-group input:focus {
        outline: none;
        border-color: var(--primary-color);
      }
      .form-help a {
        color: var(--primary-color);
        text-decoration: none;
        font-weight: 600;
      }
      .form-help a:hover {
        text-decoration: underline;
      }
      .modal-buttons {
        display: flex;
        justify-content: flex-start;
        gap: 0.75rem;
        margin-top: 1.5rem;
        padding-top: 1rem;
      }
      .btn {
        padding: 0.6rem 1.2rem;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: all 0.2s ease;
        min-height: 40px;
      }
      .btn-primary {
        background-color: var(--primary-color);
        color: white;
      }
      .btn-secondary {
        background-color: var(--secondary-color);
        color: var(--text-color);
        border: 1px solid var(--border-color);
      }
      .btn-secondary:hover {
        background-color: var(--container-bg);
        border-color: var(--primary-color);
        opacity: 1;
      }
      .btn:hover {
        opacity: 0.85;
      }
      .btn-primary:hover {
        opacity: 0.9;
      }

      .settings-section {
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
      }
      .settings-section:last-of-type {
        border-bottom: none;
        margin-bottom: 0.5rem;
      }
      .settings-section h3 {
        font-size: 1.1rem;
        color: var(--text-color);
        margin: 0 0 0.75rem 0;
        font-weight: 600;
        text-align: right;
      }
      .form-label {
        display: block;
        font-weight: 500;
        color: var(--text-color);
        margin-bottom: 0.5rem;
        text-align: right;
        font-size: 0.95rem;
      }
      .form-help {
        display: block;
        font-size: 0.8rem;
        color: var(--text-color);
        opacity: 0.65;
        margin-top: 0.25rem;
        text-align: right;
        line-height: 1.3;
      }
      .radio-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .radio-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.6rem 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        background-color: var(--secondary-color);
        direction: rtl;
        min-height: 44px;
        position: relative;
      }
      .radio-option:hover {
        border-color: var(--primary-color);
        background-color: var(--container-bg);
      }
      .radio-option input[type="radio"] {
        margin: 0;
        width: 16px;
        height: 16px;
        accent-color: var(--primary-color);
        flex-shrink: 0;
        position: absolute;
        left: 0.75rem;
      }
      .radio-option .radio-content {
        flex: 1;
        text-align: right;
        direction: rtl;
        padding-left: 2rem;
      }
      .radio-option .radio-text {
        font-weight: 500;
        color: var(--text-color);
        font-size: 0.9rem;
        display: block;
        margin-bottom: 0.1rem;
        text-align: right;
        direction: rtl;
      }
      .radio-option small {
        font-size: 0.75rem;
        color: var(--text-color);
        opacity: 0.6;
        line-height: 1.2;
        text-align: right;
        direction: rtl;
      }
      .radio-option input[type="radio"]:checked ~ .radio-content .radio-text {
        color: var(--primary-color);
        font-weight: 600;
      }
      h1 {
        margin-bottom: 2rem;
      }
      #drop-area {
        border: 2px dashed var(--border-color);
        border-radius: 12px;
        padding: 2rem;
        cursor: pointer;
        margin-bottom: 1rem;
        background: linear-gradient(
          135deg,
          var(--secondary-color) 0%,
          rgba(76, 175, 80, 0.12) 50%,
          var(--secondary-color) 100%
        );
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }
      #drop-area::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          45deg,
          transparent 40%,
          rgba(76, 175, 80, 0.03) 50%,
          transparent 60%
        );
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      #drop-area:hover::before {
        opacity: 1;
      }
      #drop-area:hover {
        border-color: var(--primary-color);
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.08) 0%,
          rgba(76, 175, 80, 0.15) 50%,
          rgba(76, 175, 80, 0.08) 100%
        );
        transform: translateY(-2px);
      }
      #drop-area.highlight {
        border-color: var(--primary-color);
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.1) 0%,
          rgba(76, 175, 80, 0.2) 50%,
          rgba(76, 175, 80, 0.1) 100%
        );
        transform: translateY(-3px);
      }
      #file-input {
        display: none;
      }
      #file-name {
        margin-top: 1rem;
        font-weight: bold;
      }
      #transcribe-btn {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        font-size: 1rem;
        cursor: pointer;
        border-radius: 8px;
        margin-top: 1rem;
        transition: all 0.3s ease;
      }
      #transcribe-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
      }
      #transcribe-btn:disabled {
        background-color: var(--border-color);
        cursor: not-allowed;
      }
      /* Ensure perfect alignment of language select and transcribe button */
      .transcribe-controls #transcribe-btn {
        margin-top: 0;
        height: 40px;
        padding: 0 1rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .transcribe-controls {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 1rem;
      }
      #language-select {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        height: 40px;
        padding: 0 0.75rem; /* ~12px to match button's horizontal padding scale */
        color: var(--text-color);
        font-size: 1rem;
      }
      #progress-container {
        width: 100%;
        background-color: #f0f0f0;
        border-radius: 4px;
        margin-top: 1rem;
        display: none;
      }
      #progress-bar {
        width: 0;
        height: 20px;
        background-color: #4caf50;
        border-radius: 4px;
        transition: width 0.3s;
      }
      #progress-status {
        display: none;
        margin-top: 0.4rem;
        text-align: center;
        font-size: 0.9rem;
        color: var(--text-color);
        opacity: 0.8;
      }
      #transcription-container {
        position: relative;
        margin: 1rem auto 0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #transcription {
        width: 100%;
        height: 200px;
        border: 2px solid var(--border-color);
        padding: 1rem;
        text-align: right;
        white-space: pre-wrap;
        overflow-y: auto;
        resize: vertical;
        font-size: 1rem;
        border-radius: 8px;
        background-color: var(--input-bg);
        color: var(--text-color);
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        line-height: 1.5;
      }
      .speaker {
        font-weight: bold;
        cursor: default;
      }
      .edit-mode-active .speaker {
        cursor: pointer;
      }
      .speaker-1 { color: #2196F3; } /* Blue */
      .speaker-2 { color: #4CAF50; } /* Green */
      .speaker-3 { color: #FF9800; } /* Orange */
      .speaker-4 { color: #E91E63; } /* Pink */
      .speaker-5 { color: #9C27B0; } /* Purple */
      .speaker-6 { color: #F44336; } /* Red */
      .speaker-7 { color: #00BCD4; } /* Cyan */
      .speaker-8 { color: #8BC34A; } /* Light Green */
      .speaker-9 { color: #FFC107; } /* Amber */
      .speaker-10 { color: #607D8B; } /* Blue Grey */
      /* Dark theme speaker colors */
      [data-theme="dark"] .speaker-1 { color: #64B5F6; }
      [data-theme="dark"] .speaker-2 { color: #81C784; }
      [data-theme="dark"] .speaker-3 { color: #FFB74D; }
      [data-theme="dark"] .speaker-4 { color: #F06292; }
      [data-theme="dark"] .speaker-5 { color: #BA68C8; }
      [data-theme="dark"] .speaker-6 { color: #EF5350; }
      [data-theme="dark"] .speaker-7 { color: #4DD0E1; }
      [data-theme="dark"] .speaker-8 { color: #AED581; }
      [data-theme="dark"] .speaker-9 { color: #FFD54F; }
      [data-theme="dark"] .speaker-10 { color: #90A4AE; }
      .transcript-segment {
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .transcript-segment:hover {
        text-decoration: underline;
        text-decoration-thickness: 2px;
      }
      .transcript-segment.playing {
        text-decoration: underline;
        text-decoration-thickness: 2px;
        text-decoration-color: var(--primary-color);
        text-underline-offset: 2px;
      }
      /* In edit mode, show text cursor on hover */
      .edit-mode-active .transcript-segment {
        cursor: text;
      }
      .transcript-segment.editing {
        text-decoration: underline;
        text-decoration-color: rgb(33, 150, 243);
        text-decoration-thickness: 2px;
        outline: none;
        border: none;
        box-shadow: none;
      }
      [data-theme="dark"] .transcript-segment.editing {
        text-decoration: underline;
        text-decoration-color: rgb(33, 150, 243);
        text-decoration-thickness: 2px;
        outline: none;
        border: none;
        box-shadow: none;
      }
      /* Remove any default contentEditable outline/border */
      .transcript-segment[contenteditable="true"]:focus {
        outline: none;
        border: none;
        box-shadow: none;
      }
      /* Speaker edit area styling */
      .speaker-edit-area {
        display: inline;
        outline: none;
        border: none;
        box-shadow: none;
        cursor: text;
        white-space: pre-wrap;
        word-wrap: break-word;
        direction: ltr !important;
        unicode-bidi: plaintext;
      }
      .speaker-edit-area:focus {
        outline: none;
        border: none;
        box-shadow: none;
      }
      .speaker-edit-area.highlighted {
        background-color: rgba(255, 193, 7, 0.3);
        border-radius: 2px;
        padding: 2px 4px;
        margin: -2px -4px;
      }
      [data-theme="dark"] .speaker-edit-area.highlighted {
        background-color: rgba(255, 193, 7, 0.2);
      }
      /* Individual segment spans within edit areas */
      .edit-segment {
        display: inline;
        cursor: text;
      }
      .edit-segment.highlighted {
        background-color: rgba(255, 193, 7, 0.3);
        border-radius: 2px;
        padding: 0px 2px;
      }
      [data-theme="dark"] .edit-segment.highlighted {
        background-color: rgba(255, 193, 7, 0.2);
      }
      /* TipTap Editor Styles */
      .tiptap-editor {
        outline: none;
        white-space: pre-wrap;
        word-wrap: break-word;
        line-height: 1.6;
      }
      .tiptap-editor[dir="rtl"] {
        direction: rtl;
        text-align: right;
      }
      .tiptap-editor[dir="ltr"] {
        direction: ltr;
        text-align: left;
      }
      .tiptap-editor:focus {
        outline: none;
      }
      .tiptap-editor .ProseMirror {
        outline: none;
      }
      .tiptap-editor .ProseMirror:focus {
        outline: none;
      }
      .tiptap-speaker-block {
        display: block;
      }
      .tiptap-speaker-block + .tiptap-speaker-block {
        margin-top: 1.2em;
      }
      .tiptap-segment {
        display: inline;
        cursor: text;
      }
      .tiptap-segment.highlighted {
        background-color: rgba(255, 193, 7, 0.3);
        border-radius: 2px;
        padding: 0px 2px;
      }
      [data-theme="dark"] .tiptap-segment.highlighted {
        background-color: rgba(255, 193, 7, 0.2);
      }
      .tiptap-segment.underlined {
        text-decoration: underline;
        text-decoration-thickness: 2px;
        text-decoration-color: rgba(255, 193, 7, 0.8);
      }
      .tiptap-segment.playing {
        text-decoration: underline;
        text-decoration-thickness: 2px;
        text-decoration-color: var(--primary-color);
        text-underline-offset: 2px;
      }
      /* Speaker label in TipTap - styled but not editable */
      .tiptap-editor [data-speaker-label] {
        cursor: pointer;
        user-select: none;
      }
      .tiptap-editor [data-speaker-label]:hover {
        text-decoration: underline;
      }
      .transcript-segment.highlighted {
        background-color: rgba(255, 193, 7, 0.3);
        border-radius: 2px;
        padding: 2px 4px;
        margin: -2px -4px;
      }
      [data-theme="dark"] .transcript-segment.highlighted {
        background-color: rgba(255, 193, 7, 0.2);
      }
      .action-buttons {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-top: 0.5rem;
        margin-bottom: 0;
      }
      .actions-right,
      .actions-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .action-buttons button {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .action-buttons button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .download-menu {
        position: relative;
      }
      .download-menu > button#download-menu-btn {
        position: relative;
      }
      .download-menu > button#download-menu-btn:disabled {
        cursor: not-allowed;
      }
      .download-menu {
        display: inline-block;
      }
      .download-menu::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        height: 6px;
      }
      .download-dropdown {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 0;
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 0.4rem 0;
        min-width: 160px;
        z-index: 200;
        direction: rtl;
        pointer-events: auto;
      }
      .download-menu:hover {
        overflow: visible;
      }
      .download-menu:hover .download-dropdown {
        display: block;
      }
      .download-menu:hover .download-dropdown {
        display: block;
      }
      .download-dropdown button {
        background: none;
        border: none;
        width: 100%;
        text-align: right;
        padding: 0.45rem 0.9rem;
        cursor: pointer;
        font-size: 0.8rem;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 0.4rem;
        direction: rtl;
      }
      .download-dropdown-header {
        font-size: 0.7rem;
        font-weight: 600;
        letter-spacing: 0.5px;
        padding: 0.35rem 0.9rem 0.25rem;
        color: var(--text-color);
        opacity: 0.7;
        pointer-events: none;
        border-bottom: 1px solid var(--border-color);
        margin-bottom: 0.2rem;
      }
      .download-dropdown button:hover {
        background: var(--secondary-color);
        color: var(--primary-color);
      }
      .download-dropdown button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .hidden-download-original {
        display: none !important;
      }
      /* Standard inline SVG sizing inside action buttons */
      .action-buttons button svg {
        width: 20px;
        height: 20px;
      }
      /* Active indication for text-format toggle */
      .action-buttons button.toggle-active {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
        color: #ffffff;
      }
      .action-buttons button.toggle-active i[data-lucide] {
        color: #ffffff;
      }
      .action-buttons button.toggle-active svg {
        color: #ffffff;
      }
      /* Toggle emojis sizing */
      #timestamps-toggle, #diarization-toggle {
        font-size: 18px;
        line-height: 1;
      }
      #copy-btn {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #copy-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #copy-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      #download-menu-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      #download-btn {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
      }
      #download-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #download-docx-btn {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #download-docx-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      /* Sticky header for viewer tab (audio player + controls) */
      #viewer-sticky-header {
        position: sticky;
        top: 0;
        z-index: 100;
        background-color: var(--container-bg);
        padding: 1rem 0;
        margin-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
      }
      
      /* Audio player in viewer tab */
      #viewer-audio-player-container {
        margin-bottom: 0.75rem;
        display: none;
      }
      #viewer-audio-player-container.visible {
        display: block;
      }
      #viewer-audio-player {
        width: 100%;
        max-width: 100%;
        outline: none;
      }
      
      /* Viewer processing state */
      #viewer-processing-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 4rem 2rem;
        text-align: center;
      }
      .processing-state-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
      }
      .processing-spinner {
        width: 48px;
        height: 48px;
        border: 4px solid var(--border-color);
        border-top-color: var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      #viewer-processing-title {
        color: var(--text-color);
        margin: 0;
        font-size: 1.5rem;
      }
      .processing-status {
        color: var(--text-color);
        opacity: 0.8;
        margin: 0;
        font-size: 1rem;
      }
      .processing-eta {
        color: var(--primary-color);
        font-weight: 600;
        margin: 0;
        font-size: 1.1rem;
      }
      
      #download-docx-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      .support-link {
        margin-top: 0.5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        text-decoration: none;
        color: #000000;
        font-weight: bold;
        transition: opacity 0.2s;
        flex-direction: row-reverse;
      }
      .support-link:hover {
        opacity: 0.8;
      }
      .support-link img {
        width: 24px;
        height: 24px;
      }
      .links-container {
        margin-top: 1.5rem;
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        flex-direction: column;
        align-items: center;
      }
      .contact-link {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        text-decoration: none;
        color: #2196f3;
        font-weight: bold;
        transition: opacity 0.2s;
        flex-direction: row-reverse;
      }
      .contact-link:hover {
        opacity: 0.8;
      }
      .contact-link svg {
        width: 24px;
        height: 24px;
      }
      .divider {
        width: 80%;
        height: 1px;
        background-color: #e0e0e0;
        margin: 1rem 0;
      }
      .display-options {
        margin-top: 1rem;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 1rem;
      }
      .slider-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .switch {
        position: relative;
        display: inline-block;
        width: 48px;
        height: 24px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 24px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: #4caf50;
      }
      input:checked + .slider:before {
        transform: translateX(24px);
      }

      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 2000;
      }
      .toast {
        background-color: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem 1.5rem;
        margin-bottom: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transform: translateX(400px);
        opacity: 0;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        min-width: 300px;
        max-width: 420px;
        direction: rtl;
        text-align: right;
        line-height: 1.4;
        white-space: normal;
      }
      .toast.show {
        transform: translateX(0);
        opacity: 1;
      }
      .toast.success {
        border-left: 4px solid var(--primary-color);
      }
      .toast.error {
        border-left: 4px solid #f44336;
      }
      .toast-message {
        flex: 1;
        color: var(--text-color);
        white-space: normal;
      }
      .toast-close:hover {
        opacity: 1;
      }

      .spinner-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 3000;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        gap: 1rem;
      }
      .spinner-overlay.show {
        display: flex;
      }
      .spinner {
        width: 48px;
        height: 48px;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top-color: #ffffff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .spinner-message {
        color: #ffffff;
        font-size: 1.1rem;
        font-weight: 500;
        text-align: center;
      }

      .file-preview {
        display: none;
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1rem;
        text-align: right;
      }
      .file-preview.show {
        display: block;
      }
      .file-info {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        flex-direction: row-reverse;
      }
      .file-details {
        flex: 1;
        text-align: left;
      }
      .file-details strong {
        display: block;
        margin-bottom: 0.5rem;
        color: var(--text-color);
      }
      .file-size {
        font-size: 0.9rem;
        color: var(--text-color);
        opacity: 0.7;
      }
      .remove-file-btn {
        background-color: #f2554a;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 0.5rem 1rem;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.3s ease;
      }
      .remove-file-btn:hover {
        background-color: #f6463a;
        transform: translateY(-1px);
      }
      .site-footer {
        margin-top: 2rem;
        font-size: 0.75rem;
        color: #777;
        direction: rtl;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        text-align: center;
      }
      [data-theme="dark"] .site-footer {
        color: #aaa;
      }
      .site-footer a {
        color: var(--primary-color);
        text-decoration: none;
        font-weight: 600;
      }
      .site-footer a:hover {
        text-decoration: underline;
      }

      /* Tab navigation styles */
      .tabs {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
        border-bottom: 2px solid var(--border-color);
      }
      .tab-button {
        padding: 0.75rem 1.5rem;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 500;
        color: var(--text-color);
        opacity: 0.6;
        transition: all 0.2s ease;
        border-bottom: 3px solid transparent;
        margin-bottom: -2px;
      }
      .tab-button:hover {
        opacity: 0.8;
      }
      .tab-button.active {
        opacity: 1;
        border-bottom-color: var(--primary-color);
        color: var(--primary-color);
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }

      /* Files list styles */
      .files-list {
        margin-top: 1rem;
      }
      .file-item {
        background: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 0.75rem;
        transition: all 0.2s ease;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
      }
      .file-item-status {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        flex-shrink: 0;
      }
      .status-queued {
        background-color: #9e9e9e;
      }
      .status-being-processed {
        background-color: #2196f3;
        animation: pulse 2s ease-in-out infinite;
      }
      .status-transcoding--- {
        background-color: #2196f3;
        animation: pulse 2s ease-in-out infinite;
      }
      .status-ready {
        background-color: #4caf50;
      }
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
      .file-item-info {
        flex: 1;
        text-align: right;
        cursor: pointer;
      }
      .file-item-info:hover {
        color: var(--primary-color);
      }
      .file-item-name {
        font-weight: 600;
        color: var(--text-color);
        margin-bottom: 0.25rem;
      }
      .file-item-meta {
        font-size: 0.85rem;
        color: var(--text-color);
        opacity: 0.6;
      }
      .file-item-actions {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        margin-left: 1rem;
      }
      .file-item-icon {
        cursor: pointer;
      }
      .file-item-icon svg {
        width: 24px;
        height: 24px;
        color: var(--primary-color);
      }
      .file-item-download-menu {
        position: relative;
        display: inline-block;
      }
      .file-item-download-menu .download-dropdown {
        display: none;
        position: absolute;
        bottom: 100%;
        right: 0;
        margin-bottom: 0.25rem;
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 0.4rem 0;
        min-width: 140px;
        z-index: 200;
        direction: rtl;
      }
      .file-item-download-menu.open .download-dropdown {
        display: block;
      }
      .file-item-download-btn {
        background: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }
      .file-item-download-btn:hover {
        background: var(--container-bg);
        border-color: var(--primary-color);
      }
      .file-item-download-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      .file-item-edit-btn {
        background: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }
      .file-item-edit-btn:hover {
        background: var(--container-bg);
        border-color: var(--primary-color);
      }
      .file-item-edit-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      .file-item-delete-btn {
        background: #ffebee;
        border: 1px solid #ef9a9a;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }
      .file-item-delete-btn:hover {
        background: #f44336;
        border-color: #d32f2f;
      }
      .file-item-delete-btn svg {
        width: 20px;
        height: 20px;
        color: #c62828;
      }
      .file-item-delete-btn:hover svg {
        color: #ffffff;
      }
      [data-theme="dark"] .file-item-delete-btn {
        background: #5d1f1f;
        border-color: #8b3030;
      }
      [data-theme="dark"] .file-item-delete-btn:hover {
        background: #c62828;
        border-color: #d32f2f;
      }
      [data-theme="dark"] .file-item-delete-btn svg {
        color: #ef9a9a;
      }
      .file-item-name-input {
        width: 100%;
        padding: 0.25rem 0.5rem;
        border: 2px solid var(--primary-color);
        border-radius: 4px;
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-color);
        background-color: var(--input-bg);
        box-sizing: border-box;
        font-family: inherit;
      }
      .file-item-name-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
      }
      .info-link-btn {
        background: none;
        border: none;
        color: var(--primary-color);
        cursor: pointer;
        font-size: 0.85rem;
        text-decoration: underline;
        padding: 0;
        transition: opacity 0.2s;
      }
      .info-link-btn:hover {
        opacity: 0.8;
      }
      .info-tooltip {
        position: fixed;
        z-index: 2500;
        background-color: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        max-width: 400px;
        min-width: 300px;
        direction: rtl;
        text-align: right;
      }
      .tooltip-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        border-bottom: 1px solid var(--border-color);
        font-weight: 600;
        font-size: 1rem;
        color: var(--text-color);
      }
      .tooltip-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        color: var(--text-color);
        line-height: 1;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s;
      }
      .tooltip-close:hover {
        color: var(--primary-color);
      }
      .tooltip-content {
        padding: 1rem 1.25rem;
        color: var(--text-color);
        font-size: 0.9rem;
        line-height: 1.6;
        white-space: pre-line;
      }
      .files-loading {
        text-align: center;
        padding: 2rem;
        color: var(--text-color);
        opacity: 0.6;
      }
      .files-empty {
        text-align: center;
        padding: 3rem 2rem;
        color: var(--text-color);
        opacity: 0.6;
      }
      .files-error {
        text-align: center;
        padding: 2rem;
        color: #f44336;
        background: rgba(244, 67, 54, 0.1);
        border-radius: 8px;
        margin-top: 1rem;
      }

      /* Localization layout adjustments */
      html[dir] .modal-content {
        text-align: start;
      }
      html[dir] .modal .form-group {
        text-align: start;
      }
      html[dir] .modal .radio-content,
      html[dir] .modal .radio-option .radio-text,
      html[dir] .modal .form-help {
        text-align: start;
        direction: inherit;
      }
      html[dir] .modal .radio-option {
        direction: inherit;
      }
      /* Keep RunPod token input LTR regardless of UI language */
      #runpod-token {
        direction: ltr;
        text-align: left;
      }
      /* Red mic button hover effect */
      .record-mic-only-btn:hover {
        background-color: #c82333 !important;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
      }
      /* Dropdown menu item hover effect */
      .record-dropdown button:hover {
        background-color: var(--hover-bg);
      }

      #tab-stats {
        direction: ltr;
        text-align: left;
      }
      #tab-stats .stats-card {
        text-align: left;
      }
      .stats-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
      }
      .stats-row-label {
        flex: 1;
        text-align: left;
      }
      .stats-row-value {
        min-width: 80px;
        text-align: right;
        font-variant-numeric: tabular-nums;
      }
      .stats-footer-link {
        background: none;
        border: none;
        color: var(--primary-color);
        cursor: pointer;
        font-weight: 600;
        margin-top: 0.5rem;
      }
      .stats-footer-link:hover {
        text-decoration: underline;
      }
      
      /* Context Menu Styles */
      .context-menu {
        display: none;
        position: fixed;
        z-index: 2000;
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        min-width: 150px;
        padding: 4px 0;
      }
      .context-menu.show {
        display: block;
      }
      .context-menu-item {
        padding: 8px 16px;
        cursor: pointer;
        font-size: 0.9rem;
        color: var(--text-color);
        transition: background 0.15s;
        position: relative;
      }
      .context-menu-item:hover {
        background: var(--secondary-color);
      }
      .context-menu-item.has-submenu::after {
        content: '◄';
        position: absolute;
        left: 8px;
        font-size: 0.7rem;
      }
      .context-submenu {
        display: none;
        position: absolute;
        right: 100%;
        top: 0;
        margin-right: 2px;
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        min-width: 120px;
        padding: 4px 0;
        max-height: 300px;
        overflow-y: auto;
      }
      .context-menu-item:hover > .context-submenu {
        display: block;
      }
      .context-submenu-item {
        padding: 6px 12px;
        cursor: pointer;
        font-size: 0.85rem;
        color: var(--text-color);
        transition: background 0.15s;
        white-space: nowrap;
      }
      .context-submenu-item:hover {
        background: var(--secondary-color);
      }

      /* Transcription Statistics Styles */
      #transcription-stats {
        margin: 0 0 0.75rem 0;
        display: none;
      }
      #transcription-stats.show {
        display: block;
      }
      .stats-toggle {
        background: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 0.5rem 0.75rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition: background 0.2s;
        user-select: none;
      }
      .stats-toggle:hover {
        background: var(--border-color);
      }
      .stats-toggle.expanded {
        border-radius: 6px 6px 0 0;
      }
      .stats-toggle-icon {
        transition: transform 0.2s;
        font-size: 0.9rem;
      }
      .stats-toggle.expanded .stats-toggle-icon {
        transform: rotate(90deg);
      }
      .stats-toggle-text {
        font-size: 0.95rem;
        font-weight: 600;
        color: var(--text-color);
      }
      .stats-content {
        display: none;
        background: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-top: none;
        border-radius: 0 0 6px 6px;
        padding: 0.75rem;
      }
      .stats-content.show {
        display: block;
      }
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }
      .stat-card {
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 0.5rem 0.6rem;
      }
      .stat-label {
        font-size: 0.75rem;
        color: var(--text-color);
        opacity: 0.7;
        margin-bottom: 0.25rem;
        line-height: 1.2;
      }
      .stat-value {
        font-size: 1.1rem;
        font-weight: bold;
        color: var(--primary-color);
      }
      .chart-container {
        position: relative;
        height: 220px;
        margin: 0.5rem 0;
      }
    </style>
  </head>
  <body>
    <div class="toast-container" id="toast-container"></div>
    <div class="spinner-overlay" id="spinner-overlay">
      <div class="spinner"></div>
      <div class="spinner-message" id="spinner-message"></div>
    </div>
    <div class="info-tooltip" id="save-audio-tooltip" style="display: none;">
      <div class="tooltip-header">
        <span data-i18n="whatDoesThisMean">מה זה אומר?</span>
        <button type="button" class="tooltip-close" aria-label="Close">&times;</button>
      </div>
      <div class="tooltip-content">
        <span data-i18n="saveAudioInfoText"></span>
      </div>
    </div>

    <div class="container">
      <button
        class="theme-toggle"
        id="theme-toggle"
        onclick="toggleTheme()"
        data-i18n-title="themeToggle"
      >
        <i data-lucide="sun" id="sun-icon"></i>
        <i data-lucide="moon" id="moon-icon" style="display: none"></i>
      </button>
      <button
        class="settings-btn"
        id="settings-btn"
        data-i18n-title="settings"
      >
        <i data-lucide="settings"></i>
      </button>
      <div class="lang-menu" id="lang-menu">
        <div class="dropdown">
          <button id="lang-btn" title="שפה" aria-label="שפה">
            <i data-lucide="globe"></i>
          </button>
          <div class="dropdown-content">
            <button type="button" data-lang="he">עברית</button>
            <button type="button" data-lang="yi">ייִדיש</button>
            <button type="button" data-lang="en">English</button>
          </div>
        </div>
      </div>
      
      <!-- Balance/Quota Display (Compact) -->
      {% if not in_local_mode %}
      <div
        class="balance-container compact-balance"
        id="main-balance-container"
        aria-live="polite"
      >
        <div class="balance-icon" aria-hidden="true">
          <i data-lucide="credit-card"></i>
        </div>
        <div class="balance-text">
          <span class="balance-label" id="main-balance-label">—</span>
          <span class="balance-amount" id="main-balance-amount">—</span>
        </div>
        <a href="{{ quota_increase_url }}" target="_blank" rel="noopener" id="quota-info-link" style="display: none;" data-i18n="howToGetMoreQuota">הגדלת מכסה</a>
      </div>
      {% endif %}
      
      <h1 data-i18n="title">תמלול בעזרת ivrit.ai</h1>
      
      <!-- Tab Navigation -->
      <div class="tabs">
        <button class="tab-button active" data-tab="transcribe" data-i18n="tabTranscribe">תמלול חדש</button>
        <button class="tab-button" data-tab="files" data-i18n="tabMyFiles">הקבצים שלי</button>
        <button class="tab-button" data-tab="viewer" id="viewer-tab-btn" style="display: none;" data-i18n="tabViewer">צפייה</button>
        <button class="tab-button" data-tab="stats" id="stats-tab-btn" style="display: none;">Stats for Nerds</button>
      </div>

      <!-- Transcribe Tab Content -->
      <div id="tab-transcribe" class="tab-content active">
      
      <!-- Recording Interface -->
      <div id="recording-interface" style="display: none;">
        <div style="text-align: center; padding: 2rem;">
          <canvas id="waveform-canvas" width="500" height="150" style="border: 2px solid var(--border-color); border-radius: 12px; background: var(--secondary-color); max-width: 100%;"></canvas>
          <div id="recording-timer" style="font-size: 2rem; font-weight: bold; margin: 1rem 0; color: var(--primary-color);">00:00</div>
          <button id="stop-recording-btn" class="btn btn-primary" style="padding: 0.75rem 1.5rem; font-size: 1rem;">
            <i data-lucide="square" style="width: 16px; height: 16px; margin-left: 0.5rem;"></i>
            <span data-i18n="stopRecording">עצור הקלטה</span>
          </button>
        </div>
      </div>

      <!-- Recorded Audio Preview -->
      <div id="recorded-audio-preview" style="display: none;">
        <div style="background: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem;">
          <div style="text-align: center; margin-bottom: 1rem;">
            <i data-lucide="mic" style="width: 48px; height: 48px; color: var(--primary-color);"></i>
          </div>
          <audio id="recorded-audio-player" controls style="width: 100%;"></audio>
        </div>
      </div>

      <div id="drop-area">
        <p data-i18n="dropPrompt">גרור קובץ לכאן או לחץ לבחירת קובץ</p>
        <input type="file" id="file-input" accept="audio/*,video/*" />
      </div>
      
      <!-- Record Audio Button with Menu -->
      <div style="text-align: center; margin-top: 1rem;">
        <div class="record-menu" style="display: inline-block; position: relative;">
          <button id="record-menu-btn" class="btn record-mic-only-btn" style="display: inline-flex; align-items: center; justify-content: center; width: 48px; height: 48px; border-radius: 50%; background-color: #dc3545; border: none; padding: 0; transition: all 0.2s ease;" data-i18n-title="recordAudio">
            <i data-lucide="mic" style="width: 24px; height: 24px; color: white;"></i>
          </button>
          <div class="record-dropdown" style="display: none; position: absolute; top: 100%; left: 50%; transform: translateX(-50%); margin-top: 0.5rem; background: var(--container-bg); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); padding: 0.4rem 0; min-width: 200px; z-index: 200;">
            <button type="button" id="record-mic-only-btn" style="background: none; border: none; width: 100%; padding: 0.6rem 1rem; cursor: pointer; font-size: 0.9rem; color: var(--text-color); display: flex; align-items: center; gap: 0.5rem;">
              <span style="display: inline-flex; align-items: center; gap: 0.25rem; width: 52px; flex-shrink: 0;">
                <i data-lucide="mic" style="width: 18px; height: 18px;"></i>
              </span>
              <span data-i18n="recordMicOnly">הקלט ממיקרופון בלבד</span>
            </button>
            <button type="button" id="record-mic-screen-btn" style="background: none; border: none; width: 100%; padding: 0.6rem 1rem; cursor: pointer; font-size: 0.9rem; color: var(--text-color); display: flex; align-items: center; gap: 0.5rem;">
              <span style="display: inline-flex; align-items: center; gap: 0.25rem; width: 52px; flex-shrink: 0;">
                <i data-lucide="mic" style="width: 16px; height: 16px;"></i>
                <span style="font-size: 0.9rem;">+</span>
                <i data-lucide="monitor" style="width: 16px; height: 16px;"></i>
              </span>
              <span data-i18n="recordMicAndScreen">הקלט מיקרופון + מסך</span>
            </button>
            <button type="button" id="record-screen-only-btn" style="background: none; border: none; width: 100%; padding: 0.6rem 1rem; cursor: pointer; font-size: 0.9rem; color: var(--text-color); display: flex; align-items: center; gap: 0.5rem;">
              <span style="display: inline-flex; align-items: center; gap: 0.25rem; width: 52px; flex-shrink: 0;">
                <i data-lucide="monitor" style="width: 18px; height: 18px;"></i>
              </span>
              <span data-i18n="recordScreenOnly">הקלט ממסך בלבד</span>
            </button>
          </div>
        </div>
      </div>

      <div class="file-preview" id="file-preview">
        <div class="file-info">
          <div class="file-details">
            <strong id="preview-file-name" data-i18n="fileSelected">קובץ נבחר</strong>
          <div class="file-size" id="preview-file-size" dir="ltr">
              <span data-i18n="fileSize">גודל קובץ</span>
            </div>
          </div>
          <button class="remove-file-btn" onclick="removeFile()" data-i18n="removeFile">הסר קובץ</button>
        </div>
      </div>

      <div id="file-name"></div>
      
      <div class="transcribe-options" style="margin-bottom: 1rem; text-align: right;">
        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; color: var(--text-color);">
          <input type="checkbox" id="save-audio-checkbox" checked style="width: 18px; height: 18px; accent-color: var(--primary-color); cursor: pointer;">
          <span data-i18n="{% if in_local_mode %}saveAudio{% else %}saveAudioInDrive{% endif %}">{% if in_local_mode %}שמור אודיו{% else %}שמור אודיו ל-Google Drive{% endif %}</span>
        </label>
        <div style="margin-top: 0.5rem; margin-right: 1.75rem; position: relative;">
          <button type="button" id="save-audio-info-btn" class="info-link-btn" data-i18n="whatDoesThisMean">מה זה אומר?</button>
        </div>
      </div>
      <div class="transcribe-controls">
        <button id="transcribe-btn" disabled data-i18n="transcribe">תמלל</button>
        <select id="language-select" title="שפת תמלול" aria-label="שפת תמלול"></select>
      </div>
      <div id="progress-container">
        <div id="progress-bar"></div>
      </div>
      <div id="progress-status" aria-live="polite"></div>
      </div>
      <!-- End Transcribe Tab -->

      <!-- My Files Tab Content -->
      <div id="tab-files" class="tab-content">
        <div id="files-container">
          <div class="files-loading" id="files-loading">
            <p data-i18n="filesLoading">טוען קבצים...</p>
          </div>
          <div class="files-error" id="files-error" style="display: none;">
            <p id="files-error-message"></p>
          </div>
          <div class="files-empty" id="files-empty" style="display: none;">
            <i data-lucide="inbox" style="width: 48px; height: 48px; margin-bottom: 1rem;"></i>
            <p data-i18n="filesEmpty">עדיין לא שמרת תמלולים</p>
          </div>
          <div class="files-list" id="files-list"></div>
        </div>
      </div>
      <!-- End My Files Tab -->

      <!-- Viewer Tab Content -->
      <div id="tab-viewer" class="tab-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <button id="back-to-files-btn" class="btn btn-secondary" style="padding: 0.5rem 1rem;">
            <i data-lucide="arrow-right" style="width: 16px; height: 16px; margin-left: 0.25rem;"></i>
            <span data-i18n="backToFiles">חזרה לרשימה</span>
          </button>
          <h2 id="viewer-file-name" style="margin: 0; font-size: 1.2rem; color: var(--text-color);"></h2>
        </div>

        <!-- Sticky header with audio player and controls -->
        <div id="viewer-sticky-header">
          <!-- Audio Player (hidden by default, shown when audio available) -->
          <div id="viewer-audio-player-container">
            <audio id="viewer-audio-player" controls preload="metadata">
              <source id="viewer-audio-source" type="audio/ogg">
            </audio>
          </div>

          <div class="action-buttons">
            <div class="actions-right">
              <button id="viewer-edit-mode-toggle" title="מצב תצוגה" aria-label="מצב תצוגה" style="display: none;">
                <i data-lucide="eye"></i>
              </button>

              <button id="viewer-text-format-toggle" title="פורמט הטקסט" aria-label="פורמט הטקסט">
                <svg id="viewer-text-format-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                  <path d="M4 6h16M10 12h10M4 18h16"/>
                </svg>
              </button>
              <button id="viewer-timestamps-toggle" title="קודי זמן" aria-label="קודי זמן">🕒</button>
              <button id="viewer-diarization-toggle" title="דוברים" aria-label="דוברים">🗣️</button>
            </div>

            <div class="actions-left">
              <button id="viewer-edit-toggle-btn" title="ערוך" aria-label="ערוך">
                <i data-lucide="pen"></i>
              </button>
              
              <button id="viewer-save-edit-btn" title="שמור" aria-label="שמור" style="display: none;">
                <i data-lucide="save"></i>
              </button>

              <button id="viewer-copy-btn" data-i18n-title="copyText">
                <i data-lucide="copy"></i>
              </button>

              <div class="download-menu">
                <button id="viewer-download-menu-btn" data-i18n-title="downloads">
                  <i data-lucide="download"></i>
                </button>
                <div class="download-dropdown">
                  <div class="download-dropdown-header" data-i18n="downloadAs">הורד כ...</div>
                  <button type="button" data-action="vtt" id="viewer-menu-vtt">VTT</button>
                  <button type="button" data-action="srt" id="viewer-menu-srt">SRT</button>
                  <button type="button" data-action="docx" id="viewer-menu-docx">
                    <span data-i18n="wordDocx">Word DOCX</span>
                  </button>
                  <button type="button" data-action="json" id="viewer-menu-json">JSON</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div id="viewer-transcription-container">
          <!-- Transcription Statistics -->
          <div id="transcription-stats">
            <div class="stats-toggle" id="stats-toggle">
              <span class="stats-toggle-icon">▶</span>
              <span class="stats-toggle-text" data-i18n="transcriptionStatistics">סטטיסטיקות תמלול</span>
            </div>
            <div class="stats-content" id="stats-content">
              <div class="stats-grid">
                <div class="stat-card">
                  <div class="stat-label" data-i18n="totalTime">זמן כולל</div>
                  <div class="stat-value" id="stat-total-time">--:--</div>
                </div>
                
                <div class="stat-card">
                  <div class="stat-label" data-i18n="totalWords">מילים</div>
                  <div class="stat-value" id="stat-total-words">0</div>
                </div>
                
                <div class="stat-card">
                  <div class="stat-label" data-i18n="totalLetters">אותיות</div>
                  <div class="stat-value" id="stat-total-letters">0</div>
                </div>
                
                <div class="stat-card">
                  <div class="stat-label" data-i18n="wordsPerMinute">מילים לדקה</div>
                  <div class="stat-value" id="stat-wpm">0</div>
                </div>
                
                <div class="stat-card">
                  <div class="stat-label" data-i18n="lettersPerMinute">אותיות לדקה</div>
                  <div class="stat-value" id="stat-lpm">0</div>
                </div>
                
                <div class="stat-card">
                  <div class="stat-label" data-i18n="avgTimeBetweenSpeakers">זמן ממוצע בין דוברים (שניות)</div>
                  <div class="stat-value" id="stat-avg-gap">0.0</div>
                </div>
              </div>
              
              <div class="stat-card">
                <div class="stat-label" data-i18n="speakerTimeDistribution">התפלגות זמן דיבור לפי דובר</div>
                <div class="chart-container">
                  <canvas id="speaker-time-chart"></canvas>
                </div>
              </div>
            </div>
          </div>
          
          <div id="viewer-transcription" contenteditable="false"></div>
        </div>
        
        <!-- Processing state overlay -->
        <div id="viewer-processing-state" style="display: none;">
          <div class="processing-state-content">
            <div class="processing-spinner"></div>
            <h3 id="viewer-processing-title" data-i18n="transcriptionInProgress">תמלול בתהליך</h3>
            <p id="viewer-processing-status" class="processing-status"></p>
            <p id="viewer-processing-eta" class="processing-eta"></p>
          </div>
        </div>
      </div>
      <!-- End Viewer Tab -->

      <!-- Statistics Tab Content -->
      <div id="tab-stats" class="tab-content">
        <div style="text-align: center; padding: 2rem;">
          <h2 style="color: var(--text-color); margin-bottom: 2rem;">System Statistics</h2>

          <div id="stats-loading" class="stats-loading" style="display: block;">
            <p>Loading statistics...</p>
          </div>

          <div id="stats-content" class="stats-content" style="display: none;">
            <div class="stats-section" style="margin-bottom: 2rem;">
              <h3 style="color: var(--text-color); margin-bottom: 1rem;">System Uptime</h3>
              <div class="stats-value" id="stats-uptime" style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">-</div>
            </div>

            <div class="stats-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem; margin-bottom: 2rem;">
              <div class="stats-card" style="background: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem;">
                <h3 style="color: var(--text-color); margin-bottom: 1rem;">Queued Jobs</h3>
                <div class="stats-job-type" style="display: flex; flex-direction: column; gap: 0.5rem;">
                  <div class="stats-row">
                    <span class="stats-row-label">Short:</span>
                    <span class="stats-row-value" id="queued-short-count">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Long:</span>
                    <span class="stats-row-value" id="queued-long-count">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Private:</span>
                    <span class="stats-row-value" id="queued-private-count">-</span>
                  </div>
                </div>
              </div>

              <div class="stats-card" style="background: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem;">
                <h3 style="color: var(--text-color); margin-bottom: 1rem;">Running Jobs</h3>
                <div class="stats-job-type" style="display: flex; flex-direction: column; gap: 0.5rem;">
                  <div class="stats-row">
                    <span class="stats-row-label">Short:</span>
                    <span class="stats-row-value" id="running-short-count">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Long:</span>
                    <span class="stats-row-value" id="running-long-count">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Private:</span>
                    <span class="stats-row-value" id="running-private-count">-</span>
                  </div>
                </div>
              </div>
            </div>

            <div class="stats-section" style="margin-bottom: 2rem;">
              <h3 style="color: var(--text-color); margin-bottom: 1rem;">Transcoding</h3>
              <div class="stats-system-info" style="background: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem;">
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                  <div class="stats-row">
                    <span class="stats-row-label">Jobs:</span>
                    <span class="stats-row-value" id="transcoding-total-jobs">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Total GB:</span>
                    <span class="stats-row-value" id="transcoding-total-gb">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Total Duration:</span>
                    <span class="stats-row-value" id="transcoding-total-duration">-</span>
                  </div>
                </div>
              </div>
            </div>

            <div class="stats-section" style="margin-bottom: 2rem;">
              <h3 style="color: var(--text-color); margin-bottom: 1rem;">Transcribed Since Launch</h3>
              <div class="stats-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                <div class="stats-card" style="background: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem; text-align: center;">
                  <h4 style="color: var(--text-color); margin-bottom: 0.5rem;">Short</h4>
                  <div class="stats-value" id="transcribed-short-jobs" style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">-</div>
                  <div id="transcribed-short-minutes" style="font-size: 1rem; color: var(--text-color); opacity: 0.8;">-</div>
                </div>
                <div class="stats-card" style="background: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem; text-align: center;">
                  <h4 style="color: var(--text-color); margin-bottom: 0.5rem;">Long</h4>
                  <div class="stats-value" id="transcribed-long-jobs" style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">-</div>
                  <div id="transcribed-long-minutes" style="font-size: 1rem; color: var(--text-color); opacity: 0.8;">-</div>
                </div>
                <div class="stats-card" style="background: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem; text-align: center;">
                  <h4 style="color: var(--text-color); margin-bottom: 0.5rem;">Private</h4>
                  <div class="stats-value" id="transcribed-private-jobs" style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">-</div>
                  <div id="transcribed-private-minutes" style="font-size: 1rem; color: var(--text-color); opacity: 0.8;">-</div>
                </div>
                <div class="stats-card" style="background: var(--primary-color); border: 1px solid var(--primary-color); border-radius: 12px; padding: 1.5rem; text-align: center;">
                  <h4 style="color: white; margin-bottom: 0.5rem;">Total</h4>
                  <div class="stats-value" id="transcribed-total-jobs" style="font-size: 1.5rem; font-weight: bold; color: white;">-</div>
                  <div id="transcribed-total-minutes" style="font-size: 1rem; color: white; opacity: 0.9;">-</div>
                </div>
              </div>
            </div>

            <div class="stats-section" style="margin-bottom: 2rem;">
              <h3 style="color: var(--text-color); margin-bottom: 1rem;">System Info</h3>
              <div class="stats-system-info" style="background: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem;">
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                  <div class="stats-row">
                    <span class="stats-row-label">Max Parallel Short Jobs:</span>
                    <span class="stats-row-value" id="max-parallel-short">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Max Parallel Long Jobs:</span>
                    <span class="stats-row-value" id="max-parallel-long">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Max Parallel Private Jobs:</span>
                    <span class="stats-row-value" id="max-parallel-private">-</span>
                  </div>
                </div>
              </div>
            </div>

            <div class="stats-section">
              <h3 style="color: var(--text-color); margin-bottom: 1rem;">Errors</h3>
              <div class="stats-system-info" style="background: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem;">
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                  <h4 style="margin: 0; color: var(--text-color); font-size: 0.95rem; text-align: left;">Google Drive</h4>
                  <div class="stats-row">
                    <span class="stats-row-label">TOC Upload Errors:</span>
                    <span class="stats-row-value" id="gdrive-toc-upload-errors">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">TOC Download Errors:</span>
                    <span class="stats-row-value" id="gdrive-toc-download-errors">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Audio Upload Errors:</span>
                    <span class="stats-row-value" id="gdrive-audio-upload-errors">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">Audio Download Errors:</span>
                    <span class="stats-row-value" id="gdrive-audio-download-errors">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">File Rename Errors:</span>
                    <span class="stats-row-value" id="gdrive-rename-errors">-</span>
                  </div>
                  <div class="stats-row">
                    <span class="stats-row-label">File Delete Errors:</span>
                    <span class="stats-row-value" id="gdrive-delete-errors">-</span>
                  </div>
                  <h4 style="margin: 0; color: var(--text-color); font-size: 0.95rem; text-align: left; margin-top: 1rem;">Quota</h4>
                  <div class="stats-row">
                    <span class="stats-row-label">Transcription Quota Exceeded:</span>
                    <span class="stats-row-value" id="quota-denied-errors">-</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div id="stats-error" class="stats-error" style="display: none; color: #f44336; margin-top: 2rem;">
            <p>Error loading statistics</p>
          </div>
        </div>
      </div>
      <!-- End Statistics Tab -->

      <div class="links-container">
        <a href="mailto:info@ivrit.ai" class="contact-link">
          <i data-lucide="mail"></i>
          <span data-i18n="contactUs">רוצים ליצור קשר? אנחנו כאן</span>
        </a>
        <a
          href="https://www.patreon.com/ivrit_ai/membership"
          target="_blank"
          class="support-link"
        >
          <img
            src="{{ url_for('static', path='patreon.png') }}"
            alt="Patreon"
          />
          <span data-i18n="donateAsk">רוצים לתרום לנו?</span>
        </a>
      </div>
      <div class="site-footer">
        <button type="button" class="stats-footer-link" id="stats-link-btn" onclick="openStatsTab()">
          Stats for Nerds
        </button>
        <a
          href="https://www.ivrit.ai/en/privacy/"
          target="_blank"
          rel="noopener"
          ><span data-i18n="privacyTos">מדיניות פרטיות ותנאי שימוש</span></a
        >
      </div>
    </div>

    <div id="settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 data-i18n="settingsHeader">הגדרות</h2>
          <button class="close" id="close-settings">&times;</button>
        </div>
        <form id="settings-form">
          {% if not in_local_mode %}
          <div class="settings-section">
            <h3 data-i18n="settingsRunpod">הגדרות RunPod</h3>
            <div class="form-group">
              <label for="runpod-token" dir="ltr" data-i18n="runpodKeyLabel">RunPod API Key:</label>
              <input
                type="password"
                id="runpod-token"
                name="runpod-token"
                data-i18n="runpodKeyPlaceholder"
                placeholder="הכנס את ה-API Key שלך"
              />
              <small class="form-help"
                ><span data-i18n="runpodHelpText">הזנת מפתח פרטי מאפשרת שימוש במשאבים פרטיים לעיבוד מהיר יותר.</span><br />
                <a
                  href="{{ quota_increase_url }}"
                  target="_blank"
                  rel="noopener"
                  data-i18n="runpodHelpWatch">לצפייה בסרטון הסבר</a
                ></small
              >
            </div>
          </div>
          {% endif %}

          

          <div class="modal-buttons">
            <button type="submit" class="btn btn-primary" data-i18n="save">שמור</button>
            <button
              type="button"
              class="btn btn-secondary"
              id="cancel-settings"
            >
              <span data-i18n="cancel">ביטול</span>
            </button>
            <button type="button" class="btn btn-secondary" id="clear-settings">
              <span data-i18n="clear">נקה הגדרות</span>
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Speaker Context Menu -->
    <div id="speaker-context-menu" class="context-menu">
      <div class="context-menu-item" id="speaker-rename-option">שנה שם</div>
      <div class="context-menu-item has-submenu" id="speaker-swap-option">
        החלף דובר
        <div class="context-submenu" id="speaker-swap-submenu">
          <!-- Populated dynamically -->
        </div>
      </div>
    </div>

    <!-- Segment Context Menu -->
    <div id="segment-context-menu" class="context-menu">
      <div class="context-menu-item has-submenu" id="segment-speaker-option">
        החלף דובר
        <div class="context-submenu" id="segment-speaker-submenu">
          <!-- Populated dynamically -->
        </div>
      </div>
    </div>

    <!-- Speaker Rename Modal -->
    <div id="speaker-rename-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>שנה שם דובר</h2>
          <button class="close" id="close-speaker-rename">&times;</button>
        </div>
        <div class="form-group">
          <label for="speaker-new-name">שם חדש:</label>
          <input
            type="text"
            id="speaker-new-name"
            placeholder="הזן שם לדובר"
            style="text-align: right; direction: rtl;"
          />
        </div>
        <div class="modal-buttons">
          <button type="button" class="btn btn-primary" id="save-speaker-name">שמור</button>
          <button type="button" class="btn btn-secondary" id="cancel-speaker-rename">ביטול</button>
        </div>
      </div>
    </div>

    <script src="{{ url_for('static', path='i18n.js') }}"></script>
    
    <!-- TipTap Editor Module -->
    <script type="module">
      import { Editor, Node, mergeAttributes } from 'https://esm.sh/@tiptap/core@2.11.5'
      import Document from 'https://esm.sh/@tiptap/extension-document@2.11.5'
      import Paragraph from 'https://esm.sh/@tiptap/extension-paragraph@2.11.5'
      import Text from 'https://esm.sh/@tiptap/extension-text@2.11.5'
      import History from 'https://esm.sh/@tiptap/extension-history@2.11.5'
      import { Plugin, PluginKey } from 'https://esm.sh/@tiptap/pm@2.11.5/state'
      
      // Export to window for use in non-module scripts
      window.TipTap = {
        Editor,
        Node,
        mergeAttributes,
        Document,
        Paragraph,
        Text,
        History,
        Plugin,
        PluginKey
      }
      
      // Signal that TipTap is loaded
      window.dispatchEvent(new Event('tiptap-loaded'))
    </script>
    
    <script>
      // Heartbeat interval for local mode auto-shutdown
      const HEARTBEAT_INTERVAL_MS = 60 * 1000  // 60 seconds
      let heartbeatInterval = null

      function startHeartbeat() {
        if (!IN_LOCAL_MODE) return
        
        // Send initial heartbeat
        sendHeartbeat()
        
        // Set up periodic heartbeat
        heartbeatInterval = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL_MS)
      }

      async function sendHeartbeat() {
        try {
          await fetch('/client_heartbeat', { method: 'POST' })
        } catch (e) {
          // Server might be shutting down, ignore errors
          console.log('Heartbeat failed:', e.message)
        }
      }

      // Initialize Lucide icons after DOM is parsed
      document.addEventListener("DOMContentLoaded", () => {
        if (window.lucide && typeof window.lucide.createIcons === "function") {
          window.lucide.createIcons()
        }
        if (window.I18N) {
          window.I18N.apply()
          const langBtn = document.getElementById('lang-btn')
          if (langBtn) {
            langBtn.title = window.I18N.t('language')
            langBtn.setAttribute('aria-label', window.I18N.t('language'))
          }
        }
        initTranscriptionLanguages()
        // Toggle UI initialization removed - toggles only in Viewer tab
        // Initialize default diarization setting
        if (!displaySettings.diarizationDisplay) {
          displaySettings.diarizationDisplay = 'enabled'
          localStorage.setItem('displaySettings', JSON.stringify(displaySettings))
        }
        updateTranscriptionDirectionUI()
        // Initialize tab switching
        initTabs()
        // Initialize save audio info tooltip
        initSaveAudioTooltip()
        // Start heartbeat for local mode auto-shutdown
        startHeartbeat()
      })

      // Initialize save audio tooltip
      function initSaveAudioTooltip() {
        const saveAudioInfoBtn = document.getElementById('save-audio-info-btn')
        const tooltip = document.getElementById('save-audio-tooltip')
        const tooltipClose = tooltip?.querySelector('.tooltip-close')
        
        if (!saveAudioInfoBtn || !tooltip) return
        
        // Show tooltip when clicking the button
        saveAudioInfoBtn.addEventListener('click', (e) => {
          e.stopPropagation()
          const isVisible = tooltip.style.display !== 'none'
          
          if (isVisible) {
            hideTooltip()
          } else {
            showTooltip(saveAudioInfoBtn, tooltip)
          }
        })
        
        // Close tooltip when clicking close button
        if (tooltipClose) {
          tooltipClose.addEventListener('click', () => {
            hideTooltip()
          })
        }
        
        // Close tooltip when clicking outside
        document.addEventListener('click', (e) => {
          if (tooltip.style.display !== 'none' && 
              !tooltip.contains(e.target) && 
              !saveAudioInfoBtn.contains(e.target)) {
            hideTooltip()
          }
        })
      }
      
      // Show tooltip positioned near the button
      function showTooltip(button, tooltip) {
        // First make it visible (but off-screen) to measure it
        tooltip.style.display = 'block'
        tooltip.style.visibility = 'hidden'
        tooltip.style.top = '0'
        tooltip.style.left = '0'
        
        const rect = button.getBoundingClientRect()
        const tooltipRect = tooltip.getBoundingClientRect()
        const viewportWidth = window.innerWidth
        const viewportHeight = window.innerHeight
        
        // Position tooltip below the button, centered horizontally
        let top = rect.bottom + 10
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2)
        
        // Adjust if tooltip goes off screen
        if (left < 10) {
          left = 10
        } else if (left + tooltipRect.width > viewportWidth - 10) {
          left = viewportWidth - tooltipRect.width - 10
        }
        
        // If tooltip would go below viewport, show it above instead
        if (top + tooltipRect.height > viewportHeight - 10) {
          top = rect.top - tooltipRect.height - 10
        }
        
        // Now position it correctly and make it visible
        tooltip.style.top = `${top}px`
        tooltip.style.left = `${left}px`
        tooltip.style.visibility = 'visible'
      }
      
      // Hide tooltip
      function hideTooltip() {
        const tooltip = document.getElementById('save-audio-tooltip')
        if (tooltip) {
          tooltip.style.display = 'none'
          tooltip.style.visibility = ''
        }
      }
      const dropArea = document.getElementById("drop-area")
      const fileInput = document.getElementById("file-input")
      const fileName = document.getElementById("file-name")
      const transcribeBtn = document.getElementById("transcribe-btn")
      const progressContainer = document.getElementById("progress-container")
      const progressBar = document.getElementById("progress-bar")
      const progressStatus = document.getElementById("progress-status")
      const transcriptionArea = document.getElementById("transcription")
      const languageSelect = document.getElementById("language-select")
      const copyBtn = document.getElementById("copy-btn")
      const downloadBtn = document.getElementById("download-btn")
      const downloadDocxBtn = document.getElementById("download-docx-btn")
      const exportWordsBtn = document.getElementById("export-words-btn")
      const textFormatToggleBtn = document.getElementById("text-format-toggle")
      const timestampsToggleBtn = document.getElementById("timestamps-toggle")
      const diarizationToggleBtn = document.getElementById("diarization-toggle")
      // New unified download menu elements
      const downloadMenuBtn = document.getElementById("download-menu-btn")
      const menuVttBtn = document.getElementById("menu-vtt")
      const menuSrtBtn = document.getElementById("menu-srt")
      const menuDocxBtn = document.getElementById("menu-docx")
      const menuJsonBtn = document.getElementById("menu-json")
      const settingsBtn = document.getElementById("settings-btn")
      const langMenu = document.getElementById("lang-menu")
      const statsTabBtn = document.getElementById("stats-tab-btn")
      // Language selection handlers
      if (langMenu && window.I18N) {
        langMenu.addEventListener('click', (e) => {
          const btn = e.target.closest('button[data-lang]')
          if (!btn) return
          const lang = btn.getAttribute('data-lang')
          window.I18N.setLanguage(lang)
          window.I18N.apply()
          if (window.lucide && typeof window.lucide.createIcons === 'function') {
            window.lucide.createIcons()
          }
          // Keep transcription language default aligned with UI language when user changes UI language
          if (languageSelect) {
            if ([...languageSelect.options].some(o => o.value === lang)) {
              languageSelect.value = lang
            }
          }
          updateTranscriptionDirectionUI()
        })
      }
      const settingsModal = document.getElementById("settings-modal")
      const closeSettings = document.getElementById("close-settings")
      const cancelSettings = document.getElementById("cancel-settings")
      const clearSettings = document.getElementById("clear-settings")
      const settingsForm = document.getElementById("settings-form")
      const runpodTokenInput = document.getElementById("runpod-token")
      let savedRunpodToken = ""
      let runpodTokenDirty = false

      if (runpodTokenInput) {
        savedRunpodToken = (getCookie("runpod_token") || "").trim()
        runpodTokenInput.addEventListener("input", () => {
          const currentValue = runpodTokenInput.value.trim()
          runpodTokenDirty = currentValue !== savedRunpodToken
        })
      }

      async function initTranscriptionLanguages() {
        try {
          const resp = await fetch('/languages')
          const data = await resp.json()
          const langs = (data && data.languages) ? data.languages : {}
          if (!languageSelect) return
          languageSelect.innerHTML = ''
          const KNOWN = [
            { key: 'he', label: 'עברית' },
            { key: 'en', label: 'English' },
            { key: 'fr', label: 'Français' },
            { key: 'es', label: 'Español' },
            { key: 'de', label: 'Deutsch' },
            { key: 'zh', label: '中文' },
          ]
          const addIfEnabled = ({ key, label }) => {
            const cfg = langs[key]
            if (cfg && cfg.enabled) {
              const opt = document.createElement('option')
              opt.value = key
              opt.textContent = label
              languageSelect.appendChild(opt)
            }
          }
          KNOWN.forEach(addIfEnabled)
          const uiLang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
          if ([...languageSelect.options].some(o => o.value === uiLang)) {
            languageSelect.value = uiLang
          } else if (languageSelect.options.length > 0) {
            languageSelect.selectedIndex = 0
          }
          updateTranscriptionDirectionUI()
        } catch (e) {
          if (!languageSelect) return
          if (languageSelect.options.length === 0) {
            ;[
              { key: 'he', label: 'עברית' },
              { key: 'en', label: 'English' },
              { key: 'fr', label: 'Français' },
              { key: 'es', label: 'Español' },
              { key: 'de', label: 'Deutsch' },
              { key: 'zh', label: '中文' },
            ].forEach(({ key, label }) => {
              const opt = document.createElement('option')
              opt.value = key
              opt.textContent = label
              languageSelect.appendChild(opt)
            })
            const uiLang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
            if ([...languageSelect.options].some(o => o.value === uiLang)) {
              languageSelect.value = uiLang
            }
            updateTranscriptionDirectionUI()
          }
        }
      }

      let selectedFile = null
      let selectedFiles = []
      let batchMode = false
      const MAX_FILE_SIZE_REGULAR = 300 * 1024 * 1024 // 300MB in bytes
      const MAX_FILE_SIZE_PRIVATE = 3 * 1024 * 1024 * 1024 // 3GB in bytes
      const IN_LOCAL_MODE = {{ 'true' if in_local_mode else 'false' }}
      let transcriptionSegments = []
      let activeTranscription = false
      let currentJobId = null
      let uploadPhase = "idle"
      let streamingUploadActive = false

      // Function to get current max file size based on private key usage
      function getMaxFileSize() {
        // In local mode, no file size limit
        if (IN_LOCAL_MODE) return Infinity
        const runpodToken = (runpodTokenInput && runpodTokenInput.value.trim()) || getCookie("runpod_token")
        return runpodToken ? MAX_FILE_SIZE_PRIVATE : MAX_FILE_SIZE_REGULAR
      }

      // Function to get max file size text for display
      function getMaxFileSizeText() {
        // In local mode, no file size limit
        if (IN_LOCAL_MODE) return "unlimited"
        const runpodToken = (runpodTokenInput && runpodTokenInput.value.trim()) || getCookie("runpod_token")
        return runpodToken ? "3GB" : "300MB"
      }

      let displaySettings = {
        textFormat: "continuous",
        timestampFormat: "none",
        diarizationDisplay: "enabled",
      }

      function showToast(message, type = "success") {
        const toastContainer = document.getElementById("toast-container")
        const toast = document.createElement("div")
        toast.className = `toast ${type}`

        // Support multi-line messages using \n
        const formatted = (message || "").toString().replace(/\n/g, "<br />")
        
        // Add close button for errors, optional for success
        const closeBtn = type === "error" 
          ? '<button type="button" class="toast-close" aria-label="Close" style="background:none;border:none;color:inherit;font-size:1.2rem;cursor:pointer;padding:0 0 0 0.5rem;opacity:0.7;line-height:1;">&times;</button>'
          : ''
        
        toast.innerHTML = `
          <span class="toast-message">${formatted}</span>
          ${closeBtn}
        `

        toastContainer.appendChild(toast)

        setTimeout(() => toast.classList.add("show"), 10)

        // Add click handler for close button
        const closeBtnEl = toast.querySelector('.toast-close')
        if (closeBtnEl) {
          closeBtnEl.addEventListener('click', () => {
            toast.classList.remove("show")
            setTimeout(() => toast.remove(), 300)
          })
        }

        // Duration: errors require manual dismiss, success messages auto-dismiss
        if (type !== "error") {
          const duration = 3000
          setTimeout(() => {
            toast.classList.remove("show")
            setTimeout(() => toast.remove(), 300)
          }, duration)
        }
      }

      function showFilePreview(file) {
        const preview = document.getElementById("file-preview")
        const fileName = document.getElementById("preview-file-name")
        const fileSize = document.getElementById("preview-file-size")

        fileName.textContent = file.name
        fileSize.textContent = formatFileSize(file.size)

        preview.classList.add("show")
        document.getElementById("file-name").style.display = "none"
      }

      function removeFile() {
        selectedFile = null
        transcribeBtn.disabled = true
        document.getElementById("file-preview").classList.remove("show")
        document.getElementById("file-name").style.display = "block"
        document.getElementById("file-name").textContent = ""
        fileInput.value = ""
        
        // Hide recorded audio preview if it's showing
        const recordedAudioPreview = document.getElementById('recorded-audio-preview')
        const recordedAudioPlayer = document.getElementById('recorded-audio-player')
        if (recordedAudioPreview && recordedAudioPreview.style.display !== 'none') {
          recordedAudioPreview.style.display = 'none'
          if (recordedAudioPlayer && recordedAudioPlayer.src) {
            URL.revokeObjectURL(recordedAudioPlayer.src)
            recordedAudioPlayer.src = ''
          }
          // Clear recording data
          if (typeof recordedBlob !== 'undefined') {
            recordedBlob = null
          }
          if (typeof audioChunks !== 'undefined') {
            audioChunks = []
          }
          const recordingTimer = document.getElementById('recording-timer')
          if (recordingTimer) {
            recordingTimer.textContent = '00:00'
          }
        }
        
        showToast(window.I18N.t('fileRemovedSuccess'), "success")
      }

      function formatFileSize(bytes) {
        if (bytes === 0) return "0 Bytes"
        const k = 1024
        const sizes = [
          window.I18N.t('unitBytes'),
          window.I18N.t('unitKB'),
          window.I18N.t('unitMB'),
          window.I18N.t('unitGB')
        ]
        const i = Math.floor(Math.log(bytes) / Math.log(k))
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
      }

      function toggleTheme() {
        const currentTheme = document.documentElement.getAttribute("data-theme")
        const newTheme = currentTheme === "dark" ? "light" : "dark"
        document.documentElement.setAttribute("data-theme", newTheme)
        localStorage.setItem("theme", newTheme)
        updateThemeIcon(newTheme)
      }

      function updateThemeIcon(theme) {
        const sunIcon = document.getElementById("sun-icon")
        const moonIcon = document.getElementById("moon-icon")
        const isDark = theme === "dark"
        sunIcon.style.display = isDark ? "none" : "inline-block"
        moonIcon.style.display = isDark ? "inline-block" : "none"
      }

      // Load saved theme
      const savedTheme = localStorage.getItem("theme") || "light"
      document.documentElement.setAttribute("data-theme", savedTheme)
      updateThemeIcon(savedTheme)

      // Load saved display settings
      const savedDisplaySettings = localStorage.getItem("displaySettings")
      if (savedDisplaySettings) {
        displaySettings = {
          ...displaySettings,
          ...JSON.parse(savedDisplaySettings),
        }
        // Ensure diarization is enabled by default when not present
        if (!displaySettings.diarizationDisplay) {
          displaySettings.diarizationDisplay = "enabled"
        }
      }

      // Load settings from cookies and localStorage
      function loadSettings() {
        // Load RunPod token
        const token = getCookie("runpod_token") || ""
        if (runpodTokenInput) {
          runpodTokenInput.value = token
        }
        savedRunpodToken = token.trim()
        runpodTokenDirty = false

        // Load display settings from localStorage
        const savedSettings = localStorage.getItem("displaySettings")
        if (savedSettings) {
          displaySettings = { ...displaySettings, ...JSON.parse(savedSettings) }
          // Ensure diarizationDisplay has a default value if not present in saved settings
          if (!displaySettings.diarizationDisplay) {
            displaySettings.diarizationDisplay = "enabled"
          }
        }

        // Toggle UI update removed - toggles only in Viewer tab

        // Update settings button appearance if credentials are saved
        updateSettingsButtonIndicator()
      }

      // Update settings button to show if credentials are saved
      function updateSettingsButtonIndicator() {
        const token = getCookie("runpod_token")
        const hasCredentials = token

        if (hasCredentials) {
          settingsBtn.style.color = "#4CAF50"
          settingsBtn.title = window.I18N.t('settingsWithRunpodSaved')
        } else {
          settingsBtn.style.color = "#666"
          settingsBtn.title = window.I18N.t('settings')
        }
      }

      // Save settings to cookies and localStorage
      async function saveSettings() {
        // Save display settings
        const textFormat = displaySettings.textFormat || "continuous"
        const timestampFormat = displaySettings.timestampFormat || "none"
        const diarizationDisplay = displaySettings.diarizationDisplay || "enabled"

        displaySettings.textFormat = textFormat
        displaySettings.timestampFormat = timestampFormat
        displaySettings.diarizationDisplay = diarizationDisplay
        localStorage.setItem("displaySettings", JSON.stringify(displaySettings))

        // Update transcription display if there are results
        if (transcriptionSegments.length > 0) {
          updateTranscriptionDisplay()
        }

        // Block RunPod settings in local mode
        if (IN_LOCAL_MODE) {
          dismissSettingsModal(false)
          showToast(window.I18N.t('settingsSaved'), "success")
          return
        }
        
        // If RunPod token input doesn't exist, just save display settings and return
        if (!runpodTokenInput) {
          dismissSettingsModal(false)
          showToast(window.I18N.t('settingsSaved'), "success")
          return
        }

        const token = runpodTokenInput.value.trim()

        // If token is empty, just clear the RunPod credentials but keep display settings
        if (!token) {
          deleteCookie("runpod_token")
          savedRunpodToken = ""
          runpodTokenDirty = false
          if (runpodTokenInput) {
            runpodTokenInput.value = ""
          }
          dismissSettingsModal(false)
          updateSettingsButtonIndicator()
          showToast(window.I18N.t('settingsSaved'), "success")
          return
        }

        // Show loading state
        const saveBtn = document.querySelector(
          '#settings-form button[type="submit"]'
        )
        const originalText = saveBtn.textContent
        saveBtn.textContent = window.I18N.t('verifyChecking')
        saveBtn.disabled = true

        try {
          // Verify credentials by checking balance
          const response = await fetch(
            `/balance?runpod_token=${encodeURIComponent(token)}`
          )
          const data = await response.json()

          if (!response.ok) {
            showToast(
              `שגיאה בבדיקת הגדרות RunPod:\n${response.status}: ${translateServerError(data)}`,
              "error"
            )
          } else {
            // Credentials are valid, check endpoint
            const endpointResult = await checkAndCreateEndpoint(token)

            if (endpointResult.success) {
              // Save credentials
              setCookie("runpod_token", token, 365 * 24 * 60 * 60) // 1 year

              let successMessage = window.I18N.t('runpodSettingsSaved')
              if (endpointResult.needsWait) {
                successMessage += ' ' + window.I18N.t('runpodEndpointWait')
              }
              savedRunpodToken = token
              runpodTokenDirty = false
              if (runpodTokenInput) {
                runpodTokenInput.value = token
              }
              showToast(successMessage, "success")
              dismissSettingsModal(false)
              updateSettingsButtonIndicator()
              checkBalance() // Update balance display
            } else {
              showToast(`${window.I18N.t('endpointCheckError')}\n${translateServerError(endpointResult) || ''}`.trim(), "error")
            }
          }
        } catch (error) {
          console.error("Error verifying credentials:", error)
          if (
            error.name === "TypeError" &&
            error.message.includes("Failed to fetch")
          ) {
            showToast(
              "שגיאה: לא ניתן להתחבר לשרת RunPod.\nאנא בדוק את החיבור לאינטרנט ונסה שוב.",
              "error"
            )
          } else {
            showToast(`שגיאה בבדיקת הגדרות RunPod.\n ${error.message}`, "error")
          }
        } finally {
          // Restore button state
          saveBtn.textContent = originalText
          saveBtn.disabled = false
        }
      }

      // Clear all settings
      function clearAllSettings() {
        // Clear RunPod settings (only if not in local mode)
        if (!IN_LOCAL_MODE) {
          deleteCookie("runpod_token")
          if (runpodTokenInput) {
            runpodTokenInput.value = ""
          }
          savedRunpodToken = ""
          runpodTokenDirty = false
        }

        // Clear display settings
        displaySettings = {
          textFormat: "continuous",
          timestampFormat: "none",
        }
        localStorage.removeItem("displaySettings")

        // Reset form controls to defaults
        displaySettings.textFormat = "continuous"
        displaySettings.timestampFormat = "none"
        displaySettings.diarizationDisplay = "enabled"

        // Toggle UI and display updates removed - only in Viewer tab

        showToast("כל ההגדרות נמחקו בהצלחה", "success")
        dismissSettingsModal(false)
        updateSettingsButtonIndicator()

        // Refresh balance/quota display after clearing credentials
        checkBalance()
      }

      // Cookie utility functions
      function setCookie(name, value, days) {
        const expires = new Date()
        expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000)
        document.cookie =
          name + "=" + value + ";expires=" + expires.toUTCString() + ";path=/"
      }

      function getCookie(name) {
        const nameEQ = name + "="
        const ca = document.cookie.split(";")
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i]
          while (c.charAt(0) === " ") c = c.substring(1, c.length)
          if (c.indexOf(nameEQ) === 0)
            return c.substring(nameEQ.length, c.length)
        }
        return null
      }

      function deleteCookie(name) {
        document.cookie =
          name + "=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/;"
      }

      // Check for RunPod credentials or fetch user quota
      async function checkBalance() {
        // Block in local mode
        if (IN_LOCAL_MODE) {
          console.log("checkBalance blocked: not available in local mode")
          return
        }
        
        const balanceContainer = document.getElementById("main-balance-container")
        // Return early if balance container doesn't exist
        if (!balanceContainer) {
          return
        }
        
        const token = getCookie("runpod_token")
        const balanceLabel = document.getElementById("main-balance-label")
        const balanceAmount = document.getElementById("main-balance-amount")
        const quotaInfoLink = document.getElementById("quota-info-link")

        if (token) {
          // User has private key - show RunPod balance
          balanceContainer.classList.add("visible")
          balanceLabel.textContent = window.I18N.t('balanceLabel') || 'יתרה'
          balanceAmount.textContent = window.I18N.t('loading') || 'טוען...'
          balanceAmount.className = "balance-amount balance-loading"
          quotaInfoLink.style.display = "none"

          try {
            const response = await fetch(
              `/balance?runpod_token=${encodeURIComponent(token)}`
            )
            const data = await response.json()

            if (response.ok && data.clientBalance !== "N/A") {
              const formattedBalance = parseFloat(data.clientBalance).toFixed(2)
              balanceAmount.textContent = `$${formattedBalance}`
              balanceAmount.className = "balance-amount"
            } else {
              balanceAmount.textContent = window.I18N.t('balanceLoadingError') || 'שגיאה'
              balanceAmount.className = "balance-amount"
            }
          } catch (error) {
            console.error("Balance fetch error:", error)
            balanceAmount.textContent = window.I18N.t('balanceLoadingError') || 'שגיאה'
            balanceAmount.className = "balance-amount"
          }
        } else {
          // No private key - show user quota
          balanceContainer.classList.add("visible")
          balanceLabel.textContent = window.I18N.t('remainingQuotaLabel') || 'מכסה נותרת'
          balanceAmount.textContent = window.I18N.t('loading') || 'טוען...'
          balanceAmount.className = "balance-amount balance-loading"
          quotaInfoLink.style.display = "inline"

          try {
            const response = await fetch('/quota')
            const data = await response.json()

            if (response.ok) {
              const remainingMinutes = Math.floor(data.remainingMinutes)
              const hours = Math.floor(remainingMinutes / 60)
              const minutes = remainingMinutes % 60
              
              let quotaText = ''
              if (hours > 0) {
                quotaText = `${hours}:${minutes.toString().padStart(2, '0')} ${window.I18N.t('hours') || 'שעות'}`
              } else {
                quotaText = `${minutes} ${window.I18N.t('minutes') || 'דקות'}`
              }
              
              balanceAmount.textContent = quotaText
              balanceAmount.className = "balance-amount"
            } else {
              balanceAmount.textContent = window.I18N.t('quotaLoadingError') || 'שגיאה'
              balanceAmount.className = "balance-amount"
            }
          } catch (error) {
            console.error("Quota fetch error:", error)
            balanceAmount.textContent = window.I18N.t('quotaLoadingError') || 'שגיאה'
            balanceAmount.className = "balance-amount"
          }
        }
      }

      // Check and create endpoint if needed (called automatically when saving settings)
      async function checkAndCreateEndpoint(token) {
        // Block endpoint checks in local mode
        if (IN_LOCAL_MODE) {
          console.error("checkAndCreateEndpoint called in local mode - this should not happen")
          throw new Error("Endpoint checks are not available in local mode")
        }
        
        try {
          const response = await fetch("/check_endpoint", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              runpod_token: token,
            }),
          })

          const data = await response.json()

          if (response.ok) {
            if (data.action === "up_to_date") {
              console.log("Endpoint is up to date")
              return { success: true, needsWait: false }
            } else if (data.action === "updated") {
              console.log("Endpoint was updated")
              return { success: true, needsWait: true }
            } else if (data.action === "created") {
              console.log("New endpoint was created")
              return { success: true, needsWait: true }
            }
          } else {
            console.error("Endpoint check failed:", data.error)
            return { success: false, error: translateServerError(data) }
          }
        } catch (error) {
          console.error("Error checking endpoint:", error)
          return { success: false, error: "שגיאה בבדיקת ה-endpoint" }
        }
      }

      function dismissSettingsModal(checkUnsaved = true) {
        if (!settingsModal) return

        if (checkUnsaved && runpodTokenDirty) {
          showToast(
            window.I18N
              ? window.I18N.t('runpodTokenUnsavedWarning')
              : 'RunPod token not saved. Click "Save" to apply.',
            "error"
          )
          if (runpodTokenInput) {
            runpodTokenInput.value = savedRunpodToken
          }
        }

        runpodTokenDirty = false
        settingsModal.style.display = "none"
        settingsModal.classList.remove("show")
      }

      async function runUploadPrecheck({ fileSize, language, runpodToken, saveAudio }) {
        try {
          const response = await fetch("/upload/precheck", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              file_size: fileSize,
              language,
              runpod_token: runpodToken || "",
              save_audio: saveAudio,
            }),
          })

          const data = await response.json()
          if (!response.ok || data.error) {
            showError(data || (window.I18N ? window.I18N.t("uploadError") : "שגיאת העלאה"))
            return { ok: false }
          }

          return { ok: true, data }
        } catch (error) {
          console.error("Precheck error:", error)
          showError(window.I18N ? window.I18N.t("uploadError") : "שגיאת העלאה")
          return { ok: false }
        }
      }

      function setProgressStatusText(key, vars) {
        if (!progressStatus) return
        if (!key) {
          progressStatus.textContent = ""
          progressStatus.style.display = "none"
          return
        }
        const text = window.I18N ? window.I18N.t(key, vars) : key
        progressStatus.textContent = text
        progressStatus.style.display = "block"
      }

      function showProgressUI() {
        if (progressContainer) {
          progressContainer.style.display = "block"
        }
        if (progressStatus) {
          progressStatus.style.display = "none"
          progressStatus.textContent = ""
        }
      }

      function hideProgressUI() {
        if (progressContainer) {
          progressContainer.style.display = "none"
        }
        if (progressBar) {
          progressBar.style.width = "0%"
        }
        if (progressStatus) {
          progressStatus.style.display = "none"
          progressStatus.textContent = ""
        }
        uploadPhase = "idle"
      }

      function startUploadPhaseUI() {
        uploadPhase = "upload"
        showProgressUI()
        if (progressBar) {
          progressBar.style.width = "0%"
        }
        setProgressStatusText("uploading")
      }

      function startTranscodingPhaseUI(statusKey = "uploadTranscodingPending", options = {}) {
        const { resetBar = false } = options
        const shouldReset = resetBar || uploadPhase !== "transcoding"
        uploadPhase = "transcoding"
        showProgressUI()
        if (progressBar && shouldReset) {
          progressBar.style.width = "0%"
        }
        setProgressStatusText(statusKey)
      }

      function getJobTypeLabel(jobType) {
        if (!window.I18N) return jobType || ""
        if (jobType === "short") return window.I18N.t('jobTypeShort')
        if (jobType === "long") return window.I18N.t('jobTypeLong')
        if (jobType === "private") return window.I18N.t('jobTypePrivate')
        return jobType || ""
      }

      function formatEtaDisplay(event) {
        if (!event) return "-"
        if (event.eta_display) return event.eta_display
        const seconds = typeof event.eta_seconds === "number" ? event.eta_seconds : null
        if (seconds === null) return "-"
        const mins = Math.floor(seconds / 60)
        const secs = Math.max(0, Math.round(seconds % 60))
        return `${mins}:${String(secs).padStart(2, "0")}`
      }

      function extractProgressPercent(event) {
        if (!event) return null
        if (typeof event.progress_percent === "number" && Number.isFinite(event.progress_percent)) {
          return Math.max(0, Math.min(100, event.progress_percent))
        }
        if (
          typeof event.progress_seconds === "number" &&
          typeof event.duration_seconds === "number" &&
          event.duration_seconds > 0
        ) {
          const ratio = (event.progress_seconds / event.duration_seconds) * 100
          return Math.max(0, Math.min(100, ratio))
        }
        return null
      }

      function updateTranscodingProgress(event) {
        startTranscodingPhaseUI("uploadTranscodingStarted")
        const percent = extractProgressPercent(event)
        if (percent !== null && progressBar) {
          progressBar.style.width = `${percent}%`
        }
        if (percent !== null) {
          setProgressStatusText("uploadTranscodingProgress", { progress: Math.round(percent) })
        }
      }

      function handleUploadStreamEvent(event) {
        if (!event || !event.type) return
        switch (event.type) {
          case "transcoding_waiting":
            startTranscodingPhaseUI("uploadTranscodingPending", { resetBar: true })
            break
          case "transcoding_started":
            startTranscodingPhaseUI("uploadTranscodingStarted")
            break
          case "transcoding_progress":
            updateTranscodingProgress(event)
            break
          case "queue_position": {
            const position = ((event.queue_depth ?? 0) + 1)
            const jobTypeLabel = getJobTypeLabel(event.job_type)
            setProgressStatusText("uploadQueuePositionDetail", { position, jobType: jobTypeLabel })
            break
          }
          case "eta":
            setProgressStatusText("uploadQueueEtaDetail", { eta: formatEtaDisplay(event) })
            break
          case "transcoding_complete":
            if (progressBar) progressBar.style.width = "100%"
            setProgressStatusText("uploadTranscodingComplete")
            uploadPhase = "done"
            streamingUploadActive = false
            break
        }
      }

      function sendStreamingUpload({ formData, onUploadProgress, onUploadComplete, onStreamEvent }) {
        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest()
          let buffer = ""
          let lastIndex = 0
          let settled = false

          xhr.open("POST", "/upload", true)
          xhr.responseType = "text"
          xhr.setRequestHeader("Accept", "application/x-ndjson, application/json")

          if (typeof onUploadProgress === "function") {
            xhr.upload.onprogress = (event) => {
              try {
                onUploadProgress(event)
              } catch {}
            }
          }
          if (typeof onUploadComplete === "function") {
            xhr.upload.onload = () => {
              try {
                onUploadComplete()
              } catch {}
            }
          }

          xhr.onreadystatechange = function () {
            if (xhr.readyState === XMLHttpRequest.LOADING || xhr.readyState === XMLHttpRequest.DONE) {
              processChunks()
            }
            if (xhr.readyState === XMLHttpRequest.DONE && !settled) {
              if (xhr.status >= 200 && xhr.status < 300) {
                if (!buffer.trim()) {
                  try {
                    const parsed = JSON.parse(xhr.responseText || "{}")
                    if (parsed.error) {
                      settled = true
                      reject(parsed)
                      return
                    }
                  } catch {}
                }
                settled = true
                resolve({})
              } else {
                settled = true
                let payload = { error: "errorUploadFailed", details: xhr.statusText || "http_error" }
                try {
                  const parsed = JSON.parse(xhr.responseText || "{}")
                  if (parsed && parsed.error) {
                    payload = parsed
                  }
                } catch {}
                reject(payload)
              }
            }
          }

          xhr.onerror = function () {
            if (settled) return
            settled = true
            reject({ error: "errorUploadFailed", details: xhr.statusText || "network_error" })
          }

          function processChunks() {
            const text = xhr.responseText || ""
            if (text.length <= lastIndex) return
            buffer += text.slice(lastIndex)
            lastIndex = text.length

            let newlineIndex = buffer.indexOf("\n")
            while (newlineIndex !== -1) {
              const rawLine = buffer.slice(0, newlineIndex).trim()
              buffer = buffer.slice(newlineIndex + 1)
              if (rawLine) {
                try {
                  const event = JSON.parse(rawLine)
                  if (typeof onStreamEvent === "function") {
                    try {
                      onStreamEvent(event)
                    } catch {}
                  }
                  if (event.type === "error" && !settled) {
                    settled = true
                    xhr.abort()
                    reject(event)
                    return
                  }
                  if (event.type === "transcoding_complete" && !settled) {
                    settled = true
                    resolve(event)
                    return
                  }
                } catch (err) {
                  console.warn("Failed to parse upload stream chunk", err)
                }
              }
              newlineIndex = buffer.indexOf("\n")
            }
          }

          xhr.send(formData)
        })
      }

      // Initialize settings button indicator on page load
      updateSettingsButtonIndicator()

      // Check balance on page load
      checkBalance()

      // Settings modal handlers
      settingsBtn.addEventListener("click", () => {
        settingsModal.style.display = "block"
        settingsModal.classList.add("show")
        loadSettings()
      })

      closeSettings.addEventListener("click", () => {
        dismissSettingsModal(true)
      })

      cancelSettings.addEventListener("click", () => {
        dismissSettingsModal(true)
      })

      clearSettings.addEventListener("click", clearAllSettings)

      settingsForm.addEventListener("submit", async (e) => {
        e.preventDefault()
        await saveSettings()
      })

      // Speaker rename modal handlers
      document.getElementById('speaker-rename-option').addEventListener('click', () => {
        document.getElementById('speaker-context-menu').classList.remove('show')
        showSpeakerRenameDialog()
      })

      document.getElementById('close-speaker-rename').addEventListener('click', () => {
        document.getElementById('speaker-rename-modal').classList.remove('show')
      })

      document.getElementById('cancel-speaker-rename').addEventListener('click', () => {
        document.getElementById('speaker-rename-modal').classList.remove('show')
      })

      document.getElementById('save-speaker-name').addEventListener('click', () => {
        saveSpeakerName()
      })

      document.getElementById('speaker-new-name').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault()
          saveSpeakerName()
        } else if (e.key === 'Escape') {
          document.getElementById('speaker-rename-modal').classList.remove('show')
        }
      })

      // Close modal when clicking on backdrop
      document.getElementById('speaker-rename-modal').addEventListener('click', (e) => {
        if (e.target.id === 'speaker-rename-modal') {
          e.target.classList.remove('show')
        }
      })

      // Close modal when clicking outside
      window.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
          dismissSettingsModal(true)
        }
      })
      
      ;["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        dropArea.addEventListener(eventName, preventDefaults, false)
      })

      function preventDefaults(e) {
        e.preventDefault()
        e.stopPropagation()
      }

      ;["dragenter", "dragover"].forEach((eventName) => {
        dropArea.addEventListener(eventName, highlight, false)
      })
      ;["dragleave", "drop"].forEach((eventName) => {
        dropArea.addEventListener(eventName, unhighlight, false)
      })

      function highlight() {
        dropArea.classList.add("highlight")
      }

      function unhighlight() {
        dropArea.classList.remove("highlight")
      }

      dropArea.addEventListener("drop", handleDrop, false)

      async function handleDrop(e) {
        const dt = e.dataTransfer
        // Allow dropping multiple files/folders only with private key (not available in local mode)
        const isPrivate = IN_LOCAL_MODE ? false : ((runpodTokenInput && runpodTokenInput.value.trim()) || getCookie("runpod_token"))
        if (isPrivate && dt.items && dt.items.length) {
          const files = await extractFilesFromDataTransfer(dt)
          handleFiles(files)
        } else {
          handleFiles(dt.files)
        }
      }

      async function extractFilesFromDataTransfer(dt) {
        const out = []
        const items = dt.items
        if (!items || !items.length) return Array.from(dt.files || [])

        const traverseEntry = async (entry) => {
          return new Promise((resolve) => {
            try {
              if (entry.isFile) {
                entry.file((file) => resolve([file]))
              } else if (entry.isDirectory) {
                const dirReader = entry.createReader()
                const all = []
                const readAll = () => {
                  dirReader.readEntries(async (entries) => {
                    if (!entries.length) {
                      resolve(all)
                      return
                    }
                    const promises = entries.map((ent) => traverseEntry(ent))
                    Promise.all(promises).then((nested) => {
                      nested.forEach((arr) => all.push(...arr))
                      readAll()
                    })
                  })
                }
                readAll()
              } else {
                resolve([])
              }
            } catch (err) {
              resolve([])
            }
          })
        }

        const entryPromises = []
        for (let i = 0; i < items.length; i++) {
          const item = items[i]
          if (item.webkitGetAsEntry) {
            const entry = item.webkitGetAsEntry()
            if (entry) entryPromises.push(traverseEntry(entry))
          } else if (item.kind === "file") {
            const f = item.getAsFile()
            if (f) out.push(f)
          }
        }

        const nested = await Promise.all(entryPromises)
        nested.forEach((arr) => out.push(...arr))
        return out
      }

      fileInput.addEventListener("change", function () {
        handleFiles(this.files)
      })

      function handleFiles(files) {
        // Batch mode only available with private key (not available in local mode)
        const isPrivate = IN_LOCAL_MODE ? false : ((runpodTokenInput && runpodTokenInput.value.trim()) || getCookie("runpod_token"))
        const list = Array.from(files || [])
        if (!list.length) return

        if (isPrivate && list.length > 1) {
          // Multi-file mode (private key only)
          const maxSize = getMaxFileSize()
          const maxText = getMaxFileSizeText()
          const valid = []
          for (const f of list) {
            if (f.size > maxSize) {
              showToast((window.I18N ? window.I18N.t('fileTooLarge', { size: maxText }) : `הקובץ גדול מדי. הגודל המקסימלי המותר הוא ${maxText}`) + `: ${f.name}`, "error")
              continue
            }
            valid.push(f)
          }
          if (!valid.length) {
            selectedFiles = []
            batchMode = false
            transcribeBtn.disabled = true
            return
          }
          selectedFiles = valid
          selectedFile = null
          batchMode = true
          transcribeBtn.disabled = false
          document.getElementById("file-preview").classList.remove("show")
          document.getElementById("file-name").style.display = "block"
          document.getElementById("file-name").textContent = (window.I18N ? window.I18N.t('filesSelectedCount', { count: valid.length }) : `${valid.length} קבצים נבחרו`)
          showToast((window.I18N ? window.I18N.t('filesSelectedSuccess', { count: valid.length }) : `${valid.length} קבצים נבחרו בהצלחה`), "success")
        } else {
          // Single-file mode
          selectedFile = list[0]
          const maxFileSize = getMaxFileSize()
          const maxFileSizeText = getMaxFileSizeText()
          if (selectedFile.size > maxFileSize) {
            showToast((window.I18N ? window.I18N.t('fileTooLarge', { size: maxFileSizeText }) : `הקובץ גדול מדי. הגודל המקסימלי המותר הוא ${maxFileSizeText}`), "error")
            selectedFile = null
            transcribeBtn.disabled = true
            fileName.textContent = ""
          } else {
            selectedFiles = []
            batchMode = false
            transcribeBtn.disabled = false
            showFilePreview(selectedFile)
            showToast((window.I18N ? window.I18N.t('fileSelectedSuccess') : "קובץ נבחר בהצלחה"), "success")
          }
        }
      }

      dropArea.addEventListener("click", () => {
        // Multiple file selection only available with private key (not available in local mode)
        const isPrivate = IN_LOCAL_MODE ? false : ((runpodTokenInput && runpodTokenInput.value.trim()) || getCookie("runpod_token"))
        if (isPrivate) {
          fileInput.setAttribute("multiple", "multiple")
        } else {
          fileInput.removeAttribute("multiple")
        }
        // Keep chooser as files-only; folders are supported via drag & drop
        fileInput.click()
      })

      transcribeBtn.addEventListener("click", function () {
        if (batchMode && selectedFiles.length > 0) {
          uploadBatch()
        } else {
          uploadFile()
        }
      })

      async function uploadFile() {
        if (!selectedFile) return

        // In local mode, ensure no RunPod token is used
        const token = IN_LOCAL_MODE ? "" : getCookie("runpod_token")
        let selectedLang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
        try {
          if (languageSelect && languageSelect.value) {
            selectedLang = languageSelect.value
          }
        } catch {}

        const saveAudioCheckbox = document.getElementById('save-audio-checkbox')
        const saveAudioValue = saveAudioCheckbox ? (saveAudioCheckbox.checked ? 'true' : 'false') : 'false'

        const precheckResult = await runUploadPrecheck({
          fileSize: selectedFile.size,
          language: selectedLang,
          runpodToken: token,
          saveAudio: saveAudioValue,
        })

        if (!precheckResult.ok) {
          return
        }

        const formData = new FormData()
        formData.append("file", selectedFile)

        if (token) {
          formData.append("runpod_token", token)
        }
        formData.append("language", selectedLang)
        formData.append("save_audio", saveAudioValue)

        transcribeBtn.disabled = true
        transcriptionSegments = []
        currentJobId = null
        streamingUploadActive = true
        startUploadPhaseUI()

        const handleUploadProgress = (event) => {
          if (!progressBar || !event.lengthComputable) return
          const percentComplete = Math.round((event.loaded / event.total) * 100)
          progressBar.style.width = percentComplete + "%"
          setProgressStatusText("uploadingProgress", { progress: percentComplete })
        }

        let uploadSucceeded = false
        const uploadedFilename = selectedFile.name
        try {
          await sendStreamingUpload({
            formData,
            onUploadProgress: handleUploadProgress,
            onUploadComplete: () => startTranscodingPhaseUI("uploadTranscodingPending", { resetBar: true }),
            onStreamEvent: handleUploadStreamEvent,
          })
          uploadSucceeded = true
          resetUploadState()
          activeTranscription = false
          showToast((window.I18N ? window.I18N.t('transcriptionQueued') : 'הקובץ נשלח לתמלול בהצלחה.'), 'success')
          // Switch to viewer tab with processing state
          showViewerProcessingState(uploadedFilename, selectedLang)
        } catch (error) {
          showError(error)
        } finally {
          streamingUploadActive = false
          if (!uploadSucceeded) {
            transcribeBtn.disabled = false
          } else {
            transcribeBtn.disabled = !(selectedFile || (batchMode && selectedFiles.length > 0))
          }
        }
      }

      async function uploadBatch() {
        if (!selectedFiles || selectedFiles.length === 0) return

        transcribeBtn.disabled = true
        showProgressUI()
        setProgressStatusText("batchStarting", { count: selectedFiles.length })

        // In local mode, ensure no RunPod token is used
        const token = IN_LOCAL_MODE ? "" : getCookie("runpod_token")
        const selectedLang = (languageSelect && languageSelect.value) ? languageSelect.value : ((window.I18N && window.I18N.current) ? window.I18N.current : 'he')
        const saveAudioCheckbox = document.getElementById('save-audio-checkbox')
        const saveAudioValue = saveAudioCheckbox ? (saveAudioCheckbox.checked ? 'true' : 'false') : 'false'

        let successCount = 0
        for (let i = 0; i < selectedFiles.length; i++) {
          const file = selectedFiles[i]

          const precheckResult = await runUploadPrecheck({
            fileSize: file.size,
            language: selectedLang,
            runpodToken: token,
            saveAudio: saveAudioValue,
          })

          if (!precheckResult.ok) {
            transcribeBtn.disabled = false
            hideProgressUI()
            return
          }

          const formData = new FormData()
          formData.append("file", file)
          formData.append('language', selectedLang)
          if (token) formData.append("runpod_token", token)
          
          // Include save_audio checkbox value
          formData.append('save_audio', saveAudioValue)

          setProgressStatusText("batchUploading", {
            index: i + 1,
            total: selectedFiles.length,
            filename: file.name,
          })

          try {
            await sendStreamingUpload({
              formData,
              onStreamEvent: () => {},
            })
            successCount++
          } catch (err) {
            const translated = translateServerError(err) || (window.I18N ? window.I18N.t('uploadError') : 'שגיאת העלאה')
            showToast(`${file.name}: ${translated}`, "error")
            continue
          } finally {
            if (progressBar) {
              progressBar.style.width = `${Math.min(100, ((i + 1) / selectedFiles.length) * 100)}%`
            }
          }
        }

        resetUploadState()
        activeTranscription = false
        if (successCount > 0) {
          showToast((window.I18N ? window.I18N.t('batchQueued', { count: successCount }) : `${successCount} קבצים נשלחו לתמלול בהצלחה. התוצאות יופיעו ב"הקבצים שלי" כשיסתיימו.`), 'success')
          // Switch to My Files tab
          switchTab('files')
        } else {
          showToast((window.I18N ? window.I18N.t('batchFailed') : 'כל הקבצים נכשלו'), 'error')
        }
      }

      function buildDocxHTMLFromSegmentsParam(segments, language) {
        const docLang = language || getTranscriptionLanguage()
        const diarizationEnabled = displaySettings.diarizationDisplay !== "disabled"
        const speakerColors = {
          1: "#2196F3",
          2: "#4CAF50",
          3: "#FF9800",
          4: "#9C27B0",
          5: "#009688",
          6: "#E91E63",
          7: "#3F51B5",
          8: "#795548",
          9: "#607D8B",
          10: "#8BC34A"
        }
        const esc = (text) => String(text || '').replace(/[&<>]/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]))

        const lines = []
        const isRTL = ['he', 'yi'].includes(docLang)
        lines.push('<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40">')
        lines.push('<head><meta charset="utf-8"><title>Transcript</title></head>')
        lines.push('<body style="font-family:\'Arial\', \'Helvetica\', sans-serif; font-size:12pt; direction:' + (isRTL ? 'rtl' : 'ltr') + '; text-align:' + (isRTL ? 'right' : 'left') + '">')

        if (displaySettings.timestampFormat === "segments") {
          for (let i = 0; i < segments.length; i++) {
            const seg = segments[i]
            const text = esc(seg.text.trim())
            const start = formatTimeForDisplay(seg.start || 0)
            const end = formatTimeForDisplay(seg.end || 0)
            if (diarizationEnabled) {
              if (seg.speakers && seg.speakers.length > 0) {
                const speakerNumber = parseInt(seg.speakers[0].replace('SPEAKER_', '')) || 0
                const colorIndex = ((speakerNumber - 1) % 10) + 1
                const color = speakerColors[colorIndex] || '#000000'
                const label = (typeof translateSpeakerLabelText === 'function' ? translateSpeakerLabelText(docLang, speakerNumber) : ('Speaker ' + speakerNumber)) + ': '
                lines.push('<p>[' + start + '-' + end + '] ' + '<span style="color:' + color + '; font-weight:700">' + label + '</span>' + text + '</p>')
              } else {
                const unknownText = (typeof translateSpeakerUnknownText === 'function' ? translateSpeakerUnknownText(docLang) : 'Unknown speaker')
                lines.push('<p>[' + start + '-' + end + '] ' + '<span style="font-weight:700">' + unknownText + ': </span>' + text + '</p>')
              }
            } else {
              lines.push('<p>[' + start + '-' + end + '] ' + text + '</p>')
            }
          }
        } else {
          let currentSpeaker = undefined
          let bufferParts = []
          let currentLabelHTML = ''

          const flushParagraph = () => {
            if (bufferParts.length === 0) return
            const content = bufferParts.join(' ').trim()
            if (currentLabelHTML) {
              lines.push('<p>' + currentLabelHTML + content + '</p>')
            } else {
              lines.push('<p>' + content + '</p>')
            }
            bufferParts = []
            currentLabelHTML = ''
          }

          for (let i = 0; i < segments.length; i++) {
            const seg = segments[i]
            const rawSpeaker = seg.speakers && seg.speakers.length > 0 ? seg.speakers[0] : null
            const segText = esc(seg.text.trim())
            const speakerChanged = i === 0 ? true : rawSpeaker !== currentSpeaker
            if (speakerChanged) {
              flushParagraph()
              if (diarizationEnabled) {
                if (rawSpeaker) {
                  const speakerNumber = parseInt(rawSpeaker.replace('SPEAKER_', '')) || 0
                  const colorIndex = ((speakerNumber - 1) % 10) + 1
                  const color = speakerColors[colorIndex] || '#000000'
                  const label = (typeof translateSpeakerLabelText === 'function' ? translateSpeakerLabelText(docLang, speakerNumber) : ('Speaker ' + speakerNumber)) + ': '
                  currentLabelHTML = '<span style="color:' + color + '; font-weight:700">' + label + '</span>'
                } else {
                  const unknownText = (typeof translateSpeakerUnknownText === 'function' ? translateSpeakerUnknownText(docLang) : 'Unknown speaker')
                  currentLabelHTML = '<span style="font-weight:700">' + unknownText + ': </span>'
                }
              } else {
                currentLabelHTML = ''
              }
              currentSpeaker = rawSpeaker
            }
            if (segText) bufferParts.push(segText)
          }
          flushParagraph()
        }

        lines.push('<p style="color:#666; font-size:10pt; margin-top:16pt">' + (window.I18N ? window.I18N.t('transcriptFooter') : 'תומלל באמצעות שירות התמלול של ivrit.ai') + '</p>')
        lines.push('</body>')
        lines.push('</html>')
        return lines.join('\n')
      }


      function formatWithTimecodes(segments) {
        if (!segments || segments.length === 0) return ""

        const separator =
          displaySettings.textFormat === "continuous" ? " " : "<br>"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30 // Start with 30 seconds

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          // Check if this segment should end the current group
          const shouldEndGroup =
            (segment.start <= currentTimeMarker &&
              segment.end >= currentTimeMarker) ||
            i === segments.length - 1 || // Last segment
            (i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            // Get start time of first segment and end time of last segment in group
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            const groupText = displaySettings.diarizationDisplay !== "disabled"
              ? joinSegmentsWithSpeakerChanges(currentGroup, separator, "<br>", true)
              : currentGroup.map((seg) => seg.text.trim()).join(separator)

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push(
              "[" +
                formattedStartTime +
                "-" +
                formattedEndTime +
                "]<br>" +
                groupText
            )

            // Reset for next group
            currentGroup = []
            currentTimeMarker += 30

            // Handle case where we need to advance time marker further
            while (
              i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker
            ) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("<br><br>")
      }

      function formatTimeForDisplay(seconds) {
        const hours = Math.floor(seconds / 3600)
        const minutes = Math.floor((seconds % 3600) / 60)
        const secs = Math.floor(seconds % 60)

        if (hours > 0) {
          return `${hours}:${String(minutes).padStart(2, "0")}:${String(
            secs
          ).padStart(2, "0")}`
        } else {
          return `${minutes}:${String(secs).padStart(2, "0")}`
        }
      }

      // Update transcription area direction and alignment based on selected language
      function updateTranscriptionDirectionUI() {
        // No-op: transcription display removed from new transcript tab
        // Viewer tab handles its own direction
      }

      // Speaker label localization should follow the transcription target language, not UI language
      function getTranscriptionLanguage() {
        try {
          if (languageSelect && languageSelect.value) return languageSelect.value
        } catch {}
        return (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
      }

      const SPEAKER_I18N = {
        he: { speaker: 'דובר {num}', unknown: 'דובר לא מזוהה' },
        yi: { speaker: 'רעדנדיקער {num}', unknown: 'ניט־ידענטיפֿיצירטער רעדנדיקער' },
        en: { speaker: 'Speaker {num}', unknown: 'Unknown speaker' },
        fr: { speaker: 'Locuteur {num}', unknown: 'Locuteur inconnu' },
        es: { speaker: 'Hablante {num}', unknown: 'Hablante desconocido' },
        de: { speaker: 'Sprecher {num}', unknown: 'Unbekannter Sprecher' },
        zh: { speaker: '说话者 {num}', unknown: '未知说话者' }
      }

      function translateSpeakerLabelText(lang, num) {
        const speakerId = `SPEAKER_${String(num).padStart(2, '0')}`
        
        // Check if there's a custom name mapping
        if (speakerNameMappings[speakerId]) {
          return speakerNameMappings[speakerId]
        }
        
        // Otherwise use the default translation
        const entry = SPEAKER_I18N[lang] || SPEAKER_I18N['en']
        const template = entry.speaker || 'Speaker {num}'
        return String(template).replace('{num}', String(num))
      }

      function translateSpeakerUnknownText(lang) {
        const entry = SPEAKER_I18N[lang] || SPEAKER_I18N['en']
        return entry.unknown || 'Unknown speaker'
      }

      function getSpeakerLabel(segment) {
        const lang = getTranscriptionLanguage()
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(segment.speakers[0].replace("SPEAKER_", ""))
          const speakerLabelText = translateSpeakerLabelText(lang, speakerNumber)
          return `<span class="speaker speaker-${speakerNumber}">${speakerLabelText}: </span>`
        }
        return `<span class="speaker">${translateSpeakerUnknownText(lang)}: </span>`
      }
      
      function getSpeakerLabelPlain(segment) {
        const lang = getTranscriptionLanguage()
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(segment.speakers[0].replace("SPEAKER_", ""))
          return `${translateSpeakerLabelText(lang, speakerNumber)}: `
        }
        return `${translateSpeakerUnknownText(lang)}: `
      }
      
      function getPlainTextFromSegments() {
        if (!transcriptionSegments || transcriptionSegments.length === 0) {
          return ""
        }
        
        let result
        if (displaySettings.timestampFormat === "segments") {
          result = formatWithTimecodesPlain(transcriptionSegments)
        } else {
          const continuousSeparator = displaySettings.textFormat === "continuous" ? " " : "\n"
          const segmentSeparator = "\n"
          result = joinSegmentsWithSpeakerChanges(transcriptionSegments, continuousSeparator, segmentSeparator, false)
        }
        
        return result + "\n\n" + (window.I18N ? window.I18N.t('transcriptFooter') : "תומלל באמצעות שירות התמלול של ivrit.ai")
      }
      
      function formatWithTimecodesPlain(segments) {
        if (!segments || segments.length === 0) return ""

        const separator =
          displaySettings.textFormat === "continuous" ? " " : "\n"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30 // Start with 30 seconds

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          // Check if this segment should end the current group
          const shouldEndGroup =
            (segment.start <= currentTimeMarker &&
              segment.end >= currentTimeMarker) ||
            i === segments.length - 1 || // Last segment
            (i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            // Get start time of first segment and end time of last segment in group
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            const groupText = displaySettings.diarizationDisplay !== "disabled"
              ? joinSegmentsWithSpeakerChanges(currentGroup, separator, "\n", false)
              : currentGroup.map((seg) => seg.text.trim()).join(separator)

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push(
              "[" +
                formattedStartTime +
                "-" +
                formattedEndTime +
                "]\n" +
                groupText
            )

            // Reset for next group
            currentGroup = []
            currentTimeMarker += 30

            // Handle case where we need to advance time marker further
            while (
              i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker
            ) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("\n\n")
      }

      /**
       * Translate server error response if it contains an i18n key
       * @param {string|object} errorData - Error string or response object with error field
       * @returns {string} - Translated error message
       */
      function translateServerError(errorData) {
        // If errorData is a string, it might be an i18n key
        if (typeof errorData === 'string') {
          // Check if it looks like an i18n key (starts with 'error')
          if (errorData.startsWith('error') && window.I18N) {
            return window.I18N.t(errorData)
          }
          return errorData
        }
        
        // If errorData is an object with error field
        if (errorData && typeof errorData === 'object') {
          const error = errorData.error
          const i18nKey = errorData.i18n_key
          const i18nVars = errorData.i18n_vars || {}
          
          // Include details field in translation variables if present
          if (errorData.details) {
            i18nVars.details = errorData.details
          }
          
          // If we have an i18n_key field, use it for translation
          if (i18nKey && window.I18N) {
            return window.I18N.t(i18nKey, i18nVars)
          }
          
          // Otherwise, check if error field looks like an i18n key
          if (error && typeof error === 'string') {
            if (error.startsWith('error') && window.I18N) {
              return window.I18N.t(error, i18nVars)
            }
            return error
          }
        }
        
        // Fallback
        return window.I18N ? window.I18N.t('errorInternalServer') : 'Internal server error'
      }

      function showError(message) {
        const translatedMessage = translateServerError(message)
        showToast(`${window.I18N.t('errorPrefix')}: ${translatedMessage}`, 'error')
        resetAllState()
      }

      function joinSegmentsWithSpeakerChanges(segments, continuousSeparator, segmentSeparator, isHTML = true) {
        if (!segments || segments.length === 0) return ""
        
        const result = []
        let currentSpeaker = null
        const diarizationEnabled = displaySettings.diarizationDisplay !== "disabled"
        
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          const segmentSpeaker = segment.speakers && segment.speakers.length > 0 ? segment.speakers[0] : null
          
          // Determine if we should show the speaker label (only if diarization is enabled)
          const showSpeakerLabel = diarizationEnabled && segmentSpeaker !== currentSpeaker
          
          // Get segment text with or without speaker label
          const segmentText = showSpeakerLabel 
            ? (isHTML ? getSpeakerLabel(segment) + segment.text.trim() : getSpeakerLabelPlain(segment) + segment.text.trim())
            : segment.text.trim()
          
          if (i === 0) {
            // First segment
            result.push(segmentText)
            currentSpeaker = segmentSpeaker
          } else if (diarizationEnabled && segmentSpeaker !== currentSpeaker) {
            // Speaker changed and diarization enabled - use double line break
            result.push('<br><br>' + segmentText)
            currentSpeaker = segmentSpeaker
          } else {
            // Same speaker OR diarization disabled - use the appropriate separator based on format
            result.push(continuousSeparator + segmentText)
            if (diarizationEnabled) {
              currentSpeaker = segmentSpeaker
            }
          }
        }
        
        return result.join("")
      }

      // updateTranscriptionDisplay and toggle UI functions removed
      // Display and controls only exist in Viewer tab

      function resetUploadState() {
        transcribeBtn.disabled = true
        selectedFile = null
        selectedFiles = []
        batchMode = false
        fileName.textContent = ""
        const filePreview = document.getElementById("file-preview")
        if (filePreview) {
          filePreview.classList.remove("show")
        }
        const fileInput = document.getElementById("file-input")
        if (fileInput) {
          fileInput.value = ""
        }
        const fileNameElement = document.getElementById("file-name")
        if (fileNameElement) {
          fileNameElement.style.display = "block"
        }
        hideProgressUI()
      }

      function resetAllState() {
        transcribeBtn.disabled = false
        selectedFile = null
        fileName.textContent = ""
        hideProgressUI()
        currentJobId = null
        transcriptionSegments = []
      }

      // Event listeners for new transcript tab buttons removed
      // All viewing and download functionality is now in the Viewer tab

      function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600)
        const minutes = Math.floor((seconds % 3600) / 60)
        const secs = Math.floor(seconds % 60)
        const ms = Math.floor((seconds % 1) * 1000)
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
          2,
          "0"
        )}:${String(secs).padStart(2, "0")}.${String(ms).padStart(3, "0")}`
      }

      // Custom confirmation dialog
      function showExitWarning() {
        return confirm(
          window.I18N.t('exitWarning')
        )
      }

      window.addEventListener("beforeunload", function (e) {
        if (activeTranscription) {
          // Show confirmation dialog
          e.preventDefault()
          e.returnValue = window.I18N.t('exitWarning')
          return e.returnValue
        }
      })

      // Handle refresh key combinations
      window.addEventListener("keydown", function (e) {
        if (
          activeTranscription &&
          (e.key === "F5" || (e.key === "r" && (e.ctrlKey || e.metaKey)))
        ) {
          if (!showExitWarning()) {
            e.preventDefault()
            return false
          }
        }
      })

      // Handle clicks on links
      document.addEventListener("click", function (e) {
        if (!activeTranscription) return

        const link = e.target.closest("a")
        if (link && !link.hasAttribute("download")) {
          if (!showExitWarning()) {
            e.preventDefault()
            return false
          }
        }
      })

      // Tab switching functionality
      function initTabs() {
        const tabButtons = document.querySelectorAll('.tab-button')
        
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const tabName = button.getAttribute('data-tab')
            switchTab(tabName)
          })
        })
      }

      function switchTab(tabName) {
        // Update button states
        document.querySelectorAll('.tab-button').forEach(btn => {
          if (btn.getAttribute('data-tab') === tabName) {
            btn.classList.add('active')
          } else {
            btn.classList.remove('active')
          }
        })

        // Update content visibility
        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active')
        })
        document.getElementById(`tab-${tabName}`).classList.add('active')

        // Load files when switching to files tab
        if (tabName === 'files') {
          lastKnownEntries = null  // Reset cache for fresh load
          loadSavedFiles(true)  // Show loading on tab switch
        } else {
          // Cancel auto-refresh when leaving files tab
          if (filesRefreshTimeout) {
            clearTimeout(filesRefreshTimeout)
            filesRefreshTimeout = null
          }
        }
        
        // Stop viewer processing poll when leaving viewer tab
        if (tabName !== 'viewer' && viewerProcessingPollTimeout) {
          stopViewerProcessingPoll()
        }
        
        // Restart viewer processing poll when returning to viewer tab with pending file
        if (tabName === 'viewer' && pendingViewerFilename && !viewerProcessingPollTimeout) {
          startViewerProcessingPoll()
        }

        // Refresh Lucide icons after tab switch
        if (window.lucide && typeof window.lucide.createIcons === 'function') {
          window.lucide.createIcons()
        }
      }

      // Store last known entries for comparison
      let lastKnownEntries = null

      // Load saved files from Google Drive TOC
      async function loadSavedFiles(showLoading = true) {
        const filesLoading = document.getElementById('files-loading')
        const filesError = document.getElementById('files-error')
        const filesEmpty = document.getElementById('files-empty')
        const filesList = document.getElementById('files-list')
        const filesErrorMessage = document.getElementById('files-error-message')

        // Show loading state only on initial load
        if (showLoading) {
          filesLoading.style.display = 'block'
          filesError.style.display = 'none'
          filesEmpty.style.display = 'none'
          filesList.innerHTML = ''
        }

        try {
          const response = await fetch('/appdata/toc')
          const data = await response.json()

          if (showLoading) {
            filesLoading.style.display = 'none'
          }

          if (!response.ok) {
            if (showLoading) {
              filesError.style.display = 'block'
              filesErrorMessage.textContent = translateServerError(data) || (window.I18N ? window.I18N.t('filesLoadError') : 'שגיאה בטעינת הקבצים')
            }
            // Silent failure for background refresh
            return
          }

          const entries = data.entries || []

          // Check if data actually changed
          const entriesChanged = !lastKnownEntries || 
            JSON.stringify(entries) !== JSON.stringify(lastKnownEntries)
          
          if (!entriesChanged && !showLoading) {
            // No changes, just schedule next refresh
            scheduleFilesRefresh(entries)
            return
          }

          // Update last known entries
          lastKnownEntries = entries

          if (entries.length === 0) {
            if (showLoading) {
              filesEmpty.style.display = 'block'
            }
            scheduleFilesRefresh(entries)
            return
          }

          // Sort entries: active jobs first (Transcoding..., Queued, Being processed), then by time
          entries.sort((a, b) => {
            const statusOrder = { 'Transcoding...': 0, 'Queued': 1, 'Being processed': 2, 'Ready': 3 }
            const statusA = statusOrder[a.status] !== undefined ? statusOrder[a.status] : 3
            const statusB = statusOrder[b.status] !== undefined ? statusOrder[b.status] : 3
            
            if (statusA !== statusB) {
              return statusA - statusB
            }
            
            // Within same status, sort by time (newest first)
            const dateA = new Date(a.completed_at || a.submitted_at)
            const dateB = new Date(b.completed_at || b.submitted_at)
            return dateB - dateA
          })

          // Only re-render if data changed or it's initial load
          if (entriesChanged || showLoading) {
            filesList.innerHTML = ''
            entries.forEach(entry => {
              const fileItem = createFileItemFromTOC(entry)
              filesList.appendChild(fileItem)
            })

            // Refresh Lucide icons
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
              window.lucide.createIcons()
            }
          }

          // Schedule next refresh based on job status
          scheduleFilesRefresh(entries)

        } catch (error) {
          console.error('Error loading files:', error)
          if (showLoading) {
            filesLoading.style.display = 'none'
            filesError.style.display = 'block'
            filesErrorMessage.textContent = (window.I18N ? window.I18N.t('filesLoadError') : 'שגיאה בטעינת הקבצים')
          }
          // Silent failure for background refresh - still schedule next attempt
          scheduleFilesRefresh([])
        }
      }

      // Auto-refresh with adaptive polling frequency
      let filesRefreshTimeout = null
      function scheduleFilesRefresh(entries = []) {
        // Clear any existing timeout
        if (filesRefreshTimeout) {
          clearTimeout(filesRefreshTimeout)
          filesRefreshTimeout = null
        }
        
        // Check if there are active jobs
        const hasActiveJobs = entries.some(e => e.status === 'Queued' || e.status === 'Being processed' || e.status === 'Transcoding...')
        
        // Only poll if there are active jobs - stop polling when all done
        if (!hasActiveJobs) {
          return
        }
        
        // Poll every 5 seconds when jobs are in flight
        filesRefreshTimeout = setTimeout(() => {
          const filesTab = document.getElementById('tab-files')
          if (filesTab && filesTab.classList.contains('active')) {
            // Silent refresh (no loading indicator)
            loadSavedFiles(false)
          }
        }, 5000)
      }

      // Get localized status text
      function getStatusText(status) {
        const statusTexts = {
          'he': {
            'Queued': 'ממתין בתור',
            'Being processed': 'בתהליך תמלול',
            'Transcoding...': 'בתהליך המרה',
            'Ready': 'מוכן'
          },
          'en': {
            'Queued': 'Queued',
            'Being processed': 'Being processed',
            'Transcoding...': 'Transcoding...',
            'Ready': 'Ready'
          }
        }
        const lang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
        const langTexts = statusTexts[lang] || statusTexts['en']
        return langTexts[status] || status
      }

      // Format ETA seconds into human-readable string
      function formatETA(seconds) {
        if (seconds === null || seconds === undefined || seconds < 0) {
          return ''
        }
        
        const hours = Math.floor(seconds / 3600)
        const minutes = Math.floor((seconds % 3600) / 60)
        const secs = Math.floor(seconds % 60)
        
        const lang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
        
        if (hours > 0) {
          if (lang === 'he' || lang === 'yi') {
            return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`
          } else {
            return `${hours}h ${minutes}m`
          }
        } else if (minutes > 0) {
          if (lang === 'he' || lang === 'yi') {
            return `${minutes}:${String(secs).padStart(2, '0')}`
          } else {
            return `${minutes}m ${secs}s`
          }
        } else {
          if (lang === 'he' || lang === 'yi') {
            return `${secs} שניות`
          } else {
            return `${secs}s`
          }
        }
      }

      // Store current viewer data
      let currentViewerData = null
      let currentViewerLanguage = 'he'
      let currentViewerEntry = null
      
      // Edit mode state
      let isEditMode = false
      let editModeView = 'new' // 'original', 'compared', 'new'
      let currentEdits = {} // Map of segment index to edited text
      let currentEditingSegmentIndex = -1
      let speakerNameMappings = {} // Map of SPEAKER_XX to custom names
      let speakerSegmentSwaps = {} // Map of segment index to new SPEAKER_XX
      
      // TipTap editor instance
      let tiptapEditor = null
      let tiptapReady = false
      
      // TipTap extensions (initialized when TipTap loads)
      let SpeakerLabelExtension = null
      let SegmentExtension = null
      let SpeakerBlockExtension = null
      let ContextMenuPlugin = null
      
      // Initialize TipTap extensions when loaded
      function initTipTapExtensions() {
        if (!window.TipTap) return
        
        const { Node, mergeAttributes, Plugin, PluginKey } = window.TipTap
        
        // Custom Node: SpeakerLabel (non-editable, atomic)
        SpeakerLabelExtension = Node.create({
          name: 'speakerLabel',
          group: 'inline',
          inline: true,
          atom: true,
          selectable: false,
          draggable: false,
          
          addAttributes() {
            return {
              speakerId: { default: null },
              speakerNumber: { default: 0 },
              segmentIndices: { default: '' },
            }
          },
          
          parseHTML() {
            return [{
              tag: 'span[data-speaker-label]',
            }]
          },
          
          renderHTML({ node, HTMLAttributes }) {
            const speakerNumber = node.attrs.speakerNumber
            const label = translateSpeakerLabelText(currentViewerLanguage, speakerNumber)
            return ['span', mergeAttributes(HTMLAttributes, {
              'data-speaker-label': 'true',
              'data-speaker-id': node.attrs.speakerId,
              'data-speaker-number': speakerNumber,
              'data-segment-indices': node.attrs.segmentIndices,
              'class': `speaker speaker-${speakerNumber}`,
              'contenteditable': 'false',
            }), `${label}: `]
          },
        })
        
        // Custom Node: Segment (editable text wrapper)
        SegmentExtension = Node.create({
          name: 'segment',
          group: 'inline',
          inline: true,
          content: 'text*',
          
          addAttributes() {
            return {
              index: { default: -1 },
              start: { default: 0 },
              end: { default: 0 },
            }
          },
          
          parseHTML() {
            return [{
              tag: 'span[data-segment]',
            }]
          },
          
          renderHTML({ node, HTMLAttributes }) {
            return ['span', mergeAttributes(HTMLAttributes, {
              'data-segment': 'true',
              'data-segment-index': node.attrs.index,
              'data-start': node.attrs.start,
              'data-end': node.attrs.end,
              'class': 'tiptap-segment',
            }), 0]
          },
        })
        
        // Custom Node: SpeakerBlock (block container for speaker group)
        SpeakerBlockExtension = Node.create({
          name: 'speakerBlock',
          group: 'block',
          content: 'inline*',
          
          addAttributes() {
            return {
              speakerId: { default: null },
              segmentIndices: { default: '' },
            }
          },
          
          parseHTML() {
            return [{
              tag: 'div[data-speaker-block]',
            }]
          },
          
          renderHTML({ node, HTMLAttributes }) {
            return ['div', mergeAttributes(HTMLAttributes, {
              'data-speaker-block': 'true',
              'data-speaker-id': node.attrs.speakerId,
              'data-segment-indices': node.attrs.segmentIndices,
              'class': 'tiptap-speaker-block',
            }), 0]
          },
        })
        
        // Plugin for context menu and click handlers on speaker labels and segments
        ContextMenuPlugin = new Plugin({
          key: new PluginKey('contextMenu'),
          props: {
            handleDOMEvents: {
              contextmenu: (view, event) => {
                const target = event.target
                
                // Check if right-clicked on a speaker label
                if (target.closest('[data-speaker-label]')) {
                  event.preventDefault()
                  const labelEl = target.closest('[data-speaker-label]')
                  const speakerId = labelEl.dataset.speakerId
                  const segmentIndices = labelEl.dataset.segmentIndices.split(',').map(i => parseInt(i))
                  
                  currentRenamingSpeakerId = speakerId
                  currentContextSegmentIndices = segmentIndices
                  showSpeakerContextMenu(event.clientX, event.clientY, speakerId, segmentIndices)
                  return true
                }
                
                // Check if right-clicked on a segment
                if (target.closest('[data-segment]')) {
                  event.preventDefault()
                  const segmentEl = target.closest('[data-segment]')
                  const segmentIndex = parseInt(segmentEl.dataset.segmentIndex)
                  
                  // Underline the segment for visual feedback
                  segmentEl.classList.add('underlined')
                  currentTipTapHighlightedSegment = segmentEl
                  
                  // Show segment context menu
                  showTipTapSegmentContextMenu(event.clientX, event.clientY, segmentIndex)
                  return true
                }
                
                return false
              },
              click: (view, event) => {
                const target = event.target
                
                // Check if clicked on a segment (for audio playback)
                const segmentEl = target.closest('[data-segment]')
                if (segmentEl) {
                  const start = parseFloat(segmentEl.dataset.start)
                  const audioPlayer = document.getElementById('viewer-audio-player')
                  
                  // Only seek if audio is already playing
                  if (!isNaN(start) && audioPlayer && audioPlayer.currentSrc && !audioPlayer.paused) {
                    audioPlayer.currentTime = start
                    // Don't prevent default or stop propagation - let the editor handle cursor positioning
                  }
                }
                
                return false
              }
            }
          }
        })
        
        tiptapReady = true
        console.log('TipTap extensions initialized')
      }
      
      // Track highlighted segment for cleanup
      let currentTipTapHighlightedSegment = null
      
      // Show context menu for a segment in TipTap editor
      function showTipTapSegmentContextMenu(x, y, segmentIndex) {
        const contextMenu = document.getElementById('segment-context-menu')
        currentContextSegmentIndices = [segmentIndex]
        
        // Populate speaker submenu
        populateSegmentSpeakerSubmenu(segmentIndex)
        
        // Position the menu
        contextMenu.style.left = x + 'px'
        contextMenu.style.top = y + 'px'
        contextMenu.classList.add('show')
        
        // Hide menu when clicking outside
        const hideMenu = (e) => {
          if (!contextMenu.contains(e.target)) {
            contextMenu.classList.remove('show')
            document.removeEventListener('click', hideMenu)
            
            // Remove underline from segment
            if (currentTipTapHighlightedSegment) {
              currentTipTapHighlightedSegment.classList.remove('underlined')
              currentTipTapHighlightedSegment.classList.remove('highlighted')
              currentTipTapHighlightedSegment = null
            }
          }
        }
        setTimeout(() => {
          document.addEventListener('click', hideMenu)
        }, 0)
      }
      
      // Wait for TipTap to load, then initialize extensions
      if (window.TipTap) {
        initTipTapExtensions()
      } else {
        window.addEventListener('tiptap-loaded', initTipTapExtensions)
      }
      
      /**
       * Convert segments array to TipTap JSON document format
       * Groups consecutive segments by speaker and creates SpeakerBlock nodes
       */
      function buildTipTapContent(segments) {
        if (!segments || segments.length === 0) {
          return {
            type: 'doc',
            content: [{
              type: 'paragraph',
              content: [{ type: 'text', text: '' }]
            }]
          }
        }
        
        const groups = groupSegmentsBySpeaker(segments)
        const content = []
        
        for (const group of groups) {
          const blockContent = []
          
          // Add speaker label node
          const speakerNumber = parseInt((group.speaker || 'SPEAKER_00').replace('SPEAKER_', ''))
          blockContent.push({
            type: 'speakerLabel',
            attrs: {
              speakerId: group.speaker,
              speakerNumber: speakerNumber,
              segmentIndices: group.segments.join(','),
            }
          })
          
          // Add segment nodes with text
          group.segments.forEach((idx, i) => {
            const seg = segments[idx]
            const text = seg.text.trim()
            
            // Add space before segment (except first)
            if (i > 0) {
              blockContent.push({ type: 'text', text: ' ' })
            }
            
            blockContent.push({
              type: 'segment',
              attrs: {
                index: idx,
                start: seg.start,
                end: seg.end,
              },
              content: text ? [{ type: 'text', text: text }] : []
            })
          })
          
          content.push({
            type: 'speakerBlock',
            attrs: {
              speakerId: group.speaker,
              segmentIndices: group.segments.join(','),
            },
            content: blockContent
          })
        }
        
        return {
          type: 'doc',
          content: content
        }
      }
      
      /**
       * Create and initialize TipTap editor for edit mode
       */
      function createTipTapEditor(containerElement, segments) {
        if (!tiptapReady || !window.TipTap) {
          console.error('TipTap not ready')
          return null
        }
        
        const { Editor, Document, Paragraph, Text, History } = window.TipTap
        
        // Determine RTL/LTR based on language
        const lang = currentViewerLanguage
        const rtlLangs = ['he', 'yi']
        const isRTL = rtlLangs.includes(lang)
        const direction = isRTL ? 'rtl' : 'ltr'
        
        // Build content from segments
        const content = buildTipTapContent(segments)
        
        // Create editor
        const editor = new Editor({
          element: containerElement,
          extensions: [
            Document,
            Paragraph,
            Text,
            History,
            SpeakerLabelExtension,
            SegmentExtension,
            SpeakerBlockExtension,
          ],
          content: content,
          editorProps: {
            attributes: {
              class: 'tiptap-editor',
              dir: direction,
            },
          },
        })
        
        // Add the context menu plugin
        editor.registerPlugin(ContextMenuPlugin)
        
        return editor
      }
      
      /**
       * Extract edits from TipTap editor content
       */
      function extractEditsFromTipTap() {
        if (!tiptapEditor) return
        
        const json = tiptapEditor.getJSON()
        
        // Walk through speaker blocks and segments
        if (json.content) {
          json.content.forEach(block => {
            if (block.type === 'speakerBlock' && block.content) {
              block.content.forEach(node => {
                if (node.type === 'segment') {
                  const segmentIndex = node.attrs.index
                  const editedText = node.content && node.content.length > 0 
                    ? node.content.map(c => c.text || '').join('') 
                    : ''
                  
                  // Get original text
                  const originalText = currentViewerData.results[segmentIndex]?.text.trim() || ''
                  
                  // Store edit if changed
                  if (editedText !== originalText) {
                    currentEdits[segmentIndex] = editedText
                  } else {
                    delete currentEdits[segmentIndex]
                  }
                }
              })
            }
          })
        }
      }
      
      /**
       * Destroy TipTap editor instance
       */
      function destroyTipTapEditor() {
        if (tiptapEditor) {
          tiptapEditor.destroy()
          tiptapEditor = null
        }
      }
      
      // Pending file tracking for viewer processing state
      let pendingViewerFilename = null
      let pendingViewerLanguage = 'he'
      let viewerProcessingPollTimeout = null
      
      // Show viewer in processing state for a pending file
      function showViewerProcessingState(filename, language) {
        pendingViewerFilename = filename
        pendingViewerLanguage = language || 'he'
        currentViewerData = null
        currentViewerEntry = null
        
        // Set filename
        document.getElementById('viewer-file-name').textContent = filename
        
        // Hide regular viewer elements
        document.getElementById('viewer-sticky-header').style.display = 'none'
        document.getElementById('viewer-transcription-container').style.display = 'none'
        
        // Show processing state
        const processingState = document.getElementById('viewer-processing-state')
        processingState.style.display = 'flex'
        
        // Set initial text
        const title = document.getElementById('viewer-processing-title')
        const status = document.getElementById('viewer-processing-status')
        const eta = document.getElementById('viewer-processing-eta')
        
        title.textContent = window.I18N ? window.I18N.t('transcriptionInProgress') : 'תמלול בתהליך'
        status.textContent = ''
        eta.textContent = ''
        
        // Show viewer tab and switch to it
        document.getElementById('viewer-tab-btn').style.display = 'block'
        switchTab('viewer')
        
        // Start polling for completion
        startViewerProcessingPoll()
      }
      
      // Poll TOC for pending file status
      async function pollViewerProcessingStatus() {
        if (!pendingViewerFilename) return
        
        try {
          const response = await fetch('/appdata/toc')
          if (!response.ok) return
          
          const data = await response.json()
          const entries = data.entries || []
          
          // Find entry matching our pending file
          const entry = entries.find(e => e.source_filename === pendingViewerFilename)
          
          if (!entry) {
            // File not yet in TOC, continue polling
            scheduleViewerProcessingPoll()
            return
          }
          
          // Update status display
          const statusEl = document.getElementById('viewer-processing-status')
          const etaEl = document.getElementById('viewer-processing-eta')
          
          const statusText = getStatusText(entry.status)
          statusEl.textContent = statusText
          
          if (entry.eta_seconds !== undefined && entry.eta_seconds !== null) {
            const etaFormatted = formatETA(entry.eta_seconds)
            if (etaFormatted) {
              const lang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
              const etaLabel = lang === 'he' || lang === 'yi' ? 'ETA: ' : 'ETA: '
              etaEl.textContent = `${etaLabel}${etaFormatted}`
            } else {
              etaEl.textContent = ''
            }
          } else {
            etaEl.textContent = ''
          }
          
          // Check if ready
          if (entry.status === 'Ready' && entry.results_id) {
            // File is ready, load it
            stopViewerProcessingPoll()
            pendingViewerFilename = null
            await viewSavedFileFromTOC(entry)
          } else {
            // Continue polling
            scheduleViewerProcessingPoll()
          }
        } catch (error) {
          console.error('Error polling viewer status:', error)
          scheduleViewerProcessingPoll()
        }
      }
      
      function startViewerProcessingPoll() {
        stopViewerProcessingPoll()
        pollViewerProcessingStatus()
      }
      
      function scheduleViewerProcessingPoll() {
        stopViewerProcessingPoll()
        viewerProcessingPollTimeout = setTimeout(pollViewerProcessingStatus, 3000)
      }
      
      function stopViewerProcessingPoll() {
        if (viewerProcessingPollTimeout) {
          clearTimeout(viewerProcessingPollTimeout)
          viewerProcessingPollTimeout = null
        }
      }
      
      // Reset viewer processing state (called when loading completed file)
      function hideViewerProcessingState() {
        const processingState = document.getElementById('viewer-processing-state')
        processingState.style.display = 'none'
        document.getElementById('viewer-sticky-header').style.display = ''
        document.getElementById('viewer-transcription-container').style.display = ''
      }

      // Create file item element from TOC entry
      function createFileItemFromTOC(entry) {
        const div = document.createElement('div')
        div.className = 'file-item'

        // Status indicator
        const statusDot = document.createElement('div')
        statusDot.className = 'file-item-status'
        const status = entry.status || 'Ready'
        const statusClass = status.toLowerCase().replace(/\s+/g, '-').replace(/\./g, '-')
        statusDot.classList.add(`status-${statusClass}`)
        statusDot.title = status

        const info = document.createElement('div')
        info.className = 'file-item-info'
        
        // Only allow clicking for ready items
        const isReady = status === 'Ready' && entry.results_id
        if (isReady) {
          info.onclick = () => viewSavedFileFromTOC(entry)
        } else {
          info.style.cursor = 'default'
        }

        const name = document.createElement('div')
        name.className = 'file-item-name'
        name.textContent = entry.source_filename || 'Untitled'
        name.dataset.originalName = entry.source_filename || 'Untitled'

        const meta = document.createElement('div')
        meta.className = 'file-item-meta'
        
        // Show appropriate date and status text
        let dateStr = ''
        if (entry.completed_at) {
          const date = new Date(entry.completed_at)
          dateStr = date.toLocaleDateString('he-IL', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          })
        } else if (entry.submitted_at) {
          const date = new Date(entry.submitted_at)
          dateStr = date.toLocaleDateString('he-IL', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          })
        }
        
        // Add status text and ETA for non-ready items
        if (status !== 'Ready') {
          const statusText = getStatusText(status)
          let metaText = `${dateStr} (${statusText})`
          
          // Add ETA if available
          if (entry.eta_seconds !== undefined && entry.eta_seconds !== null) {
            const etaFormatted = formatETA(entry.eta_seconds)
            if (etaFormatted) {
              const lang = (window.I18N && window.I18N.current) ? window.I18N.current : 'he'
              const etaLabel = lang === 'he' || lang === 'yi' ? 'ETA: ' : 'ETA: '
              metaText += ` • ${etaLabel}${etaFormatted}`
            }
          }
          
          meta.textContent = metaText
        } else {
          meta.textContent = dateStr
        }

        info.appendChild(name)
        info.appendChild(meta)

        const actions = document.createElement('div')
        actions.className = 'file-item-actions'

        // Add edit and delete buttons for ready items
        if (isReady) {
          const editBtn = document.createElement('button')
          editBtn.className = 'file-item-edit-btn'
          editBtn.title = (window.I18N ? window.I18N.t('renameFile') : 'שנה שם')
          editBtn.innerHTML = '<i data-lucide="pencil"></i>'
          editBtn.onclick = (e) => {
            e.stopPropagation()
            enableRenameMode(name, entry.results_id)
          }
          actions.appendChild(editBtn)
          
          const deleteBtn = document.createElement('button')
          deleteBtn.className = 'file-item-delete-btn'
          deleteBtn.title = (window.I18N ? window.I18N.t('deleteFile') : 'מחק קובץ')
          deleteBtn.innerHTML = '<i data-lucide="trash-2"></i>'
          deleteBtn.onclick = (e) => {
            e.stopPropagation()
            confirmDeleteFile(entry.results_id, entry.source_filename)
          }
          actions.appendChild(deleteBtn)
        }

        div.appendChild(statusDot)
        div.appendChild(info)
        div.appendChild(actions)

        return div
      }

      // Enable rename mode for a file item
      function enableRenameMode(nameElement, resultsId) {
        const originalName = nameElement.textContent
        const input = document.createElement('input')
        input.type = 'text'
        input.value = originalName
        input.className = 'file-item-name-input'
        
        // Replace text with input
        nameElement.textContent = ''
        nameElement.appendChild(input)
        input.focus()
        input.select()
        
        const saveRename = async () => {
          const newName = input.value.trim()
          
          // If name unchanged or empty, cancel
          if (!newName || newName === originalName) {
            nameElement.textContent = originalName
            return
          }
          
          // Show loading state
          nameElement.textContent = (window.I18N ? window.I18N.t('saving') : 'שומר...')
          
          try {
            const response = await fetch('/appdata/rename', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                results_id: resultsId,
                new_filename: newName
              })
            })
            
            const data = await response.json()
            
            if (response.ok) {
              nameElement.textContent = newName
              nameElement.dataset.originalName = newName
              showToast((window.I18N ? window.I18N.t('fileRenamedSuccess') : 'השם שונה בהצלחה'), 'success')
              // Refresh the files list to show updated name
              loadSavedFiles(false)
            } else {
              nameElement.textContent = originalName
              showToast(translateServerError(data) || (window.I18N ? window.I18N.t('renameError') : 'שגיאה בשינוי השם'), 'error')
            }
          } catch (error) {
            console.error('Rename error:', error)
            nameElement.textContent = originalName
            showToast((window.I18N ? window.I18N.t('renameError') : 'שגיאה בשינוי השם'), 'error')
          }
        }
        
        const cancelRename = () => {
          nameElement.textContent = originalName
        }
        
        // Save on Enter
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault()
            saveRename()
          } else if (e.key === 'Escape') {
            e.preventDefault()
            cancelRename()
          }
        })
        
        // Save on blur
        input.addEventListener('blur', saveRename)
      }

      // Confirm and delete file
      function confirmDeleteFile(resultsId, filename) {
        const confirmMessage = window.I18N 
          ? window.I18N.t('deleteConfirm', { filename: filename })
          : `האם אתה בטוח שברצונך למחוק את "${filename}"?\n\nפעולה זו אינה הפיכה.`
        
        if (!confirm(confirmMessage)) {
          return
        }
        
        deleteFile(resultsId, filename)
      }

      // Show spinner overlay
      function showSpinner(message) {
        const overlay = document.getElementById('spinner-overlay')
        const messageEl = document.getElementById('spinner-message')
        if (overlay && messageEl) {
          messageEl.textContent = message || (window.I18N ? window.I18N.t('deleting') : 'מוחק...')
          overlay.style.display = 'flex'
          overlay.classList.add('show')
          // Force a reflow to ensure the spinner is visible
          void overlay.offsetHeight
        }
      }

      // Hide spinner overlay
      function hideSpinner() {
        const overlay = document.getElementById('spinner-overlay')
        if (overlay) {
          overlay.classList.remove('show')
          overlay.style.display = 'none'
        }
      }

      // Delete file from TOC and Drive
      async function deleteFile(resultsId, filename) {
        // Show spinner to block access
        showSpinner()
        
        // Force a reflow to ensure spinner is visible
        void document.getElementById('spinner-overlay')?.offsetHeight
        
        try {
          const response = await fetch('/appdata/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              results_id: resultsId
            })
          })
          
          const data = await response.json()
          
          if (response.ok) {
            showToast((window.I18N ? window.I18N.t('fileDeletedSuccess') : 'הקובץ נמחק בהצלחה'), 'success')
            // Invalidate client-side cache and refresh the files list
            lastKnownEntries = null
            loadSavedFiles(true)
          } else {
            showToast(translateServerError(data) || (window.I18N ? window.I18N.t('deleteError') : 'שגיאה במחיקת הקובץ'), 'error')
          }
        } catch (error) {
          console.error('Delete error:', error)
          showToast((window.I18N ? window.I18N.t('deleteError') : 'שגיאה במחיקת הקובץ'), 'error')
        } finally {
          // Always hide spinner when done
          hideSpinner()
        }
      }

      // Helper function to decompress gzipped data
      async function decompressGzip(arrayBuffer) {
        const stream = new DecompressionStream('gzip')
        const writer = stream.writable.getWriter()
        writer.write(new Uint8Array(arrayBuffer))
        writer.close()
        
        const reader = stream.readable.getReader()
        const chunks = []
        while (true) {
          const { done, value } = await reader.read()
          if (done) break
          chunks.push(value)
        }
        
        const decompressed = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0))
        let offset = 0
        for (const chunk of chunks) {
          decompressed.set(chunk, offset)
          offset += chunk.length
        }
        
        return new TextDecoder().decode(decompressed)
      }

      // View saved file from TOC entry
      async function viewSavedFileFromTOC(entry) {
        // Show spinner to block access while loading
        showSpinner(window.I18N ? window.I18N.t('loadingFile') : 'טוען קובץ...')
        
        // Force a reflow to ensure spinner is visible
        void document.getElementById('spinner-overlay')?.offsetHeight
        
        try {
          // Fetch results (gzipped)
          const response = await fetch(`/appdata/results/${entry.results_id}`)
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }))
            showToast(translateServerError(errorData) || (window.I18N ? window.I18N.t('filesLoadError') : 'שגיאה בטעינת הקובץ'), 'error')
            hideSpinner()
            return
          }
          
          // Decompress gzipped data
          const arrayBuffer = await response.arrayBuffer()
          const decompressed = await decompressGzip(arrayBuffer)
          const data = JSON.parse(decompressed)

          // Store data for viewer (results file now contains full payload)
          currentViewerData = { results: data.results || [] }
          currentViewerLanguage = data.language || entry.language || 'he'
          currentViewerEntry = entry
          
          // Load edits if they exist
          await loadEdits(entry.results_id)
          
          // Show view mode button (available in both edit and non-edit modes)
          document.getElementById('viewer-edit-mode-toggle').style.display = 'inline-block'
          updateViewModeButtonUI()
          
          // Hide processing state if it was showing
          hideViewerProcessingState()
          pendingViewerFilename = null

          // Set filename in viewer
          document.getElementById('viewer-file-name').textContent = entry.source_filename

          // Update transcription display
          updateViewerTranscriptionDisplay()

          // Update viewer toggle UI states
          updateViewerTextFormatToggleUI()
          updateViewerTimestampsToggleUI()
          updateViewerDiarizationToggleUI()

          // Load audio player if audio file exists
          await loadViewerAudioPlayer(entry.results_id)

          // Show viewer tab
          document.getElementById('viewer-tab-btn').style.display = 'block'
          switchTab('viewer')

          // Refresh Lucide icons
          if (window.lucide && typeof window.lucide.createIcons === 'function') {
            window.lucide.createIcons()
          }

        } catch (error) {
          console.error('Error viewing file:', error)
          showToast((window.I18N ? window.I18N.t('filesLoadError') : 'שגיאה בטעינת הקובץ'), 'error')
        } finally {
          // Always hide spinner when done
          hideSpinner()
        }
      }

      // Load audio player for viewer tab
      async function loadViewerAudioPlayer(resultsId) {
        const playerContainer = document.getElementById('viewer-audio-player-container')
        const audioPlayer = document.getElementById('viewer-audio-player')
        const audioSource = document.getElementById('viewer-audio-source')
        
        // Hide player by default
        playerContainer.classList.remove('visible')
        
        // Remove existing timeupdate listener if any
        audioPlayer.removeEventListener('timeupdate', handleAudioTimeUpdate)
        
        // Reset playing segment index
        currentPlayingSegmentIndex = -1
        
        try {
          // Check if audio file exists by making a HEAD request
          const checkResponse = await fetch(`/appdata/audio/stream/${resultsId}`, {
            method: 'HEAD'
          })
          
          if (checkResponse.ok) {
            // Audio file exists, set up player
            audioSource.src = `/appdata/audio/stream/${resultsId}`
            audioPlayer.load()
            playerContainer.classList.add('visible')
            
            // Add timeupdate listener to sync text with audio
            audioPlayer.addEventListener('timeupdate', handleAudioTimeUpdate)
          }
        } catch (error) {
          // Audio file doesn't exist or error occurred, keep player hidden
          console.log('Audio file not available for this transcription')
        }
      }
      
      // Store current playing segment index for efficient lookup
      let currentPlayingSegmentIndex = -1
      
      // Handle audio time update to highlight current segment
      function handleAudioTimeUpdate(event) {
        const currentTime = event.target.currentTime
        
        // Use viewer data segments for efficient lookup
        if (!currentViewerData || !currentViewerData.results) return
        
        const segments = currentViewerData.results
        
        // Find the segment containing currentTime
        const segmentIndex = segments.findIndex(seg => currentTime >= seg.start && currentTime <= seg.end)
        
        // If we're in the same segment as before, no need to update
        if (segmentIndex === currentPlayingSegmentIndex) {
          return
        }
        
        // Determine the correct selector based on current mode
        const segmentClass = isEditMode ? 'tiptap-segment' : 'transcript-segment'
        
        // Clear previous playing segment
        if (currentPlayingSegmentIndex !== -1) {
          const prevElement = document.querySelector(`.${segmentClass}[data-segment-index="${currentPlayingSegmentIndex}"]`)
          if (prevElement) {
            prevElement.classList.remove('playing')
          }
        }
        
        // Update current playing segment
        currentPlayingSegmentIndex = segmentIndex
        
        if (segmentIndex !== -1) {
          const currentElement = document.querySelector(`.${segmentClass}[data-segment-index="${segmentIndex}"]`)
          if (currentElement) {
            currentElement.classList.add('playing')
            
            // Optionally scroll to the playing segment
            if (!isElementInViewport(currentElement)) {
              currentElement.scrollIntoView({ behavior: 'smooth', block: 'center' })
            }
          }
        }
      }
      
      // Check if element is in viewport
      function isElementInViewport(el) {
        const rect = el.getBoundingClientRect()
        return (
          rect.top >= 0 &&
          rect.left >= 0 &&
          rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
          rect.right <= (window.innerWidth || document.documentElement.clientWidth)
        )
      }

      // Download in specified format
      function downloadInFormat(segments, originalFileName, format, language) {
        const baseName = originalFileName.replace(/\.[^/.]+$/, '')
        
        if (format === 'json') {
          // Segments already have edits applied
          const blob = new Blob([JSON.stringify(segments, null, 2)], { type: 'application/json' })
          triggerDownload(blob, `${baseName}.json`)
        } else if (format === 'vtt') {
          let vttContent = "WEBVTT\n\n"
          segments.forEach((segment, index) => {
            const startTime = formatTime(segment.start)
            const endTime = formatTime(segment.end)
            const text = segment.text.trim()
            vttContent += `${index + 1}\n${startTime} --> ${endTime}\n${text}\n\n`
          })
          const blob = new Blob([vttContent], { type: 'text/vtt' })
          triggerDownload(blob, `${baseName}.vtt`)
        } else if (format === 'srt') {
          let srtContent = ""
          segments.forEach((segment, index) => {
            const start = formatTime(segment.start).replace(".", ",")
            const end = formatTime(segment.end).replace(".", ",")
            const text = segment.text.trim()
            srtContent += `${index + 1}\n${start} --> ${end}\n${text}\n\n`
          })
          const blob = new Blob([srtContent], { type: 'text/plain' })
          triggerDownload(blob, `${baseName}.srt`)
        } else if (format === 'docx') {
          if (!window.htmlDocx || typeof window.htmlDocx.asBlob !== "function") {
            showToast((window.I18N ? window.I18N.t('docxLibMissing') : 'ספריית יצירת המסמך לא נטענה'), 'error')
            return
          }
          const html = buildDocxHTMLFromSegmentsParam(segments, language)
          const blob = window.htmlDocx.asBlob(html)
          triggerDownload(blob, `${baseName}.docx`)
        }

        showToast((window.I18N ? window.I18N.t('filesDownloadSuccess') : 'הקובץ הורד בהצלחה'), 'success')
      }

      function triggerDownload(blob, filename) {
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = filename
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
      }

      // Update viewer transcription display
      function updateViewerTranscriptionDisplay() {
        if (!currentViewerData || !currentViewerData.results) return

        const viewerTranscription = document.getElementById('viewer-transcription')
        
        // Determine which data to use based on edit mode view
        let segments
        if (editModeView === 'original') {
          // Show original data without any edits
          segments = currentViewerData.results
        } else if (editModeView === 'compared') {
          // Show effective data but getSegmentDisplayText will handle the comparison
          segments = currentViewerData.results
        } else {
          // Show effective data with all edits applied (default and 'new' view)
          segments = getEffectiveTranscriptionData()
        }

        // Use same display logic as main transcription
        let result
        if (displaySettings.timestampFormat === "segments") {
          result = formatWithTimecodesForSegments(segments, editModeView !== 'new')
        } else {
          const continuousSeparator = displaySettings.textFormat === "continuous" ? " " : "<br>"
          const segmentSeparator = "<br>"
          result = joinSegmentsWithSpeakerChangesForSegments(segments, continuousSeparator, segmentSeparator, true, editModeView !== 'new')
        }

        result = result + "<br><br>" + (window.I18N ? window.I18N.t('transcriptFooter') : "תומלל באמצעות שירות התמלול של ivrit.ai")

        viewerTranscription.innerHTML = result
        updateViewerTranscriptionDirectionUI()
        
        // Reset playing segment index when regenerating display
        currentPlayingSegmentIndex = -1
        
        // Add click handlers to segments for seeking audio
        addSegmentClickHandlers()
        
        // Update transcription statistics
        updateTranscriptionStatistics()
      }
      
      // Calculate and display transcription statistics
      let speakerTimeChart = null
      
      // Setup statistics toggle
      document.addEventListener('DOMContentLoaded', () => {
        const statsToggle = document.getElementById('stats-toggle')
        const statsContent = document.getElementById('stats-content')
        
        if (statsToggle && statsContent) {
          statsToggle.addEventListener('click', () => {
            const isExpanded = statsToggle.classList.contains('expanded')
            
            if (isExpanded) {
              statsToggle.classList.remove('expanded')
              statsContent.classList.remove('show')
            } else {
              statsToggle.classList.add('expanded')
              statsContent.classList.add('show')
            }
          })
        }
      })
      
      function updateTranscriptionStatistics() {
        if (!currentViewerData || !currentViewerData.results) {
          document.getElementById('transcription-stats').classList.remove('show')
          return
        }
        
        // Get effective data with all edits applied
        const segments = getEffectiveTranscriptionData()
        if (segments.length === 0) {
          document.getElementById('transcription-stats').classList.remove('show')
          return
        }
        
        // Calculate total time
        const totalTime = segments[segments.length - 1].end
        const totalMinutes = totalTime / 60
        
        // Calculate speaker times
        const speakerTimes = {}
        const speakerColors = {
          'SPEAKER_01': '#2196F3',
          'SPEAKER_02': '#4CAF50',
          'SPEAKER_03': '#FF9800',
          'SPEAKER_04': '#E91E63',
          'SPEAKER_05': '#9C27B0',
          'SPEAKER_06': '#F44336',
          'SPEAKER_07': '#00BCD4',
          'SPEAKER_08': '#8BC34A',
          'SPEAKER_09': '#FFC107',
          'SPEAKER_10': '#607D8B'
        }
        
        segments.forEach(segment => {
          const speaker = segment.speakers && segment.speakers.length > 0 ? segment.speakers[0] : 'UNKNOWN'
          const duration = segment.end - segment.start
          speakerTimes[speaker] = (speakerTimes[speaker] || 0) + duration
        })
        
        // Calculate gaps between different speakers
        const gaps = []
        for (let i = 0; i < segments.length - 1; i++) {
          const currentSegment = segments[i]
          const nextSegment = segments[i + 1]
          
          const currentSpeaker = currentSegment.speakers && currentSegment.speakers.length > 0 ? currentSegment.speakers[0] : null
          const nextSpeaker = nextSegment.speakers && nextSegment.speakers.length > 0 ? nextSegment.speakers[0] : null
          
          // Only calculate gap if speakers are different
          if (currentSpeaker !== nextSpeaker) {
            const gap = nextSegment.start - currentSegment.end
            if (gap >= 0) {
              gaps.push(gap)
            }
          }
        }
        
        // Calculate average gap
        const avgGap = gaps.length > 0 ? gaps.reduce((a, b) => a + b, 0) / gaps.length : 0
        
        // Calculate word and letter counts
        let totalWords = 0
        let totalLetters = 0
        
        segments.forEach(segment => {
          const text = segment.text.trim()
          const words = text.split(/\s+/).filter(w => w.length > 0)
          totalWords += words.length
          totalLetters += text.replace(/\s/g, '').length
        })
        
        // Calculate rates
        const wpm = totalMinutes > 0 ? Math.round(totalWords / totalMinutes) : 0
        const lpm = totalMinutes > 0 ? Math.round(totalLetters / totalMinutes) : 0
        
        // Update DOM
        document.getElementById('stat-total-time').textContent = formatTimeForDisplay(totalTime)
        document.getElementById('stat-total-words').textContent = totalWords.toLocaleString()
        document.getElementById('stat-total-letters').textContent = totalLetters.toLocaleString()
        document.getElementById('stat-wpm').textContent = wpm.toLocaleString()
        document.getElementById('stat-lpm').textContent = lpm.toLocaleString()
        document.getElementById('stat-avg-gap').textContent = avgGap.toFixed(2)
        
        // Create pie chart
        const chartCanvas = document.getElementById('speaker-time-chart')
        if (chartCanvas) {
          // Destroy existing chart if it exists
          if (speakerTimeChart) {
            speakerTimeChart.destroy()
          }
          
          const ctx = chartCanvas.getContext('2d')
          const labels = []
          const data = []
          const colors = []
          
          Object.entries(speakerTimes).sort((a, b) => b[1] - a[1]).forEach(([speaker, time]) => {
            let speakerLabel
            if (speaker === 'UNKNOWN') {
              speakerLabel = translateSpeakerUnknownText(currentViewerLanguage)
            } else {
              const speakerNumber = parseInt(speaker.replace('SPEAKER_', ''), 10) || 0
              speakerLabel = translateSpeakerLabelText(currentViewerLanguage, speakerNumber)
            }
            
            labels.push(speakerLabel)
            data.push(time)
            colors.push(speakerColors[speaker] || '#999999')
          })
          
          speakerTimeChart = new Chart(ctx, {
            type: 'pie',
            data: {
              labels: labels,
              datasets: [{
                data: data,
                backgroundColor: colors,
                borderWidth: 2,
                borderColor: getComputedStyle(document.documentElement).getPropertyValue('--container-bg').trim()
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'right',
                  labels: {
                    color: getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim(),
                    font: {
                      size: 11
                    },
                    generateLabels: function(chart) {
                      const data = chart.data
                      if (data.labels.length && data.datasets.length) {
                        const dataset = data.datasets[0]
                        const total = dataset.data.reduce((a, b) => a + b, 0)
                        return data.labels.map((label, i) => {
                          const value = dataset.data[i]
                          const percentage = ((value / total) * 100).toFixed(1)
                          return {
                            text: label + ' (' + percentage + '%)',
                            fillStyle: dataset.backgroundColor[i],
                            hidden: false,
                            index: i
                          }
                        })
                      }
                      return []
                    }
                  }
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const label = context.label || ''
                      const value = context.parsed || 0
                      const percentage = ((value / totalTime) * 100).toFixed(1)
                      return label + ': ' + formatTimeForDisplay(value) + ' (' + percentage + '%)'
                    }
                  }
                }
              }
            }
          })
        }
        
        // Show the statistics section
        document.getElementById('transcription-stats').classList.add('show')
      }
      
      // Add click handlers to transcript segments for audio seeking or editing
      function addSegmentClickHandlers() {
        const segments = document.querySelectorAll('.transcript-segment')
        const audioPlayer = document.getElementById('viewer-audio-player')
        
        segments.forEach(segment => {
          segment.addEventListener('click', (e) => {
            const segmentIndex = parseInt(segment.dataset.segmentIndex)
            const start = parseFloat(segment.dataset.start)
            
            if (!isNaN(start) && audioPlayer && audioPlayer.currentSrc) {
              // Clicking seeks audio (not in edit mode since segments aren't shown)
              audioPlayer.currentTime = start
              audioPlayer.play().catch(err => {
                console.log('Play failed:', err)
              })
            }
          })
        })
        
        // Add handlers for individual segments within edit areas
        const editSegments = document.querySelectorAll('.edit-segment')
        editSegments.forEach(segmentSpan => {
          // Right-click handler for speaker modification
          segmentSpan.addEventListener('contextmenu', (e) => {
            e.preventDefault()
            e.stopPropagation()
            
            const segmentIndex = parseInt(segmentSpan.dataset.segmentIndex)
            
            // Highlight only this segment
            segmentSpan.classList.add('highlighted')
            
            // Show context menu for this single segment
            showEditSegmentContextMenu(e.clientX, e.clientY, segmentIndex, segmentSpan)
          })
        })
        
        // Add context menu handlers to speaker labels in edit mode
        addSpeakerContextMenuHandlers()
      }

      function addSpeakerContextMenuHandlers() {
        if (!isEditMode) return
        
        const speakerLabels = document.querySelectorAll('.speaker')
        speakerLabels.forEach(label => {
          label.addEventListener('contextmenu', (e) => {
            e.preventDefault()
            e.stopPropagation()
            
            // Get speaker number from class
            const classes = Array.from(label.classList)
            const speakerClass = classes.find(c => c.startsWith('speaker-'))
            if (!speakerClass) return
            
            const speakerNumber = speakerClass.replace('speaker-', '')
            const speakerId = `SPEAKER_${speakerNumber.padStart(2, '0')}`
            
            // Find the segment index by looking at the next sibling transcript-segment
            let firstSegmentIndex = -1
            const nextElement = label.nextElementSibling
            if (nextElement && nextElement.classList.contains('transcript-segment')) {
              firstSegmentIndex = parseInt(nextElement.dataset.segmentIndex)
            }
            
            // Find all consecutive segments with the same speaker
            const segmentIndices = findConsecutiveSpeakerSegments(firstSegmentIndex, speakerId)
            
            showSpeakerContextMenu(e.clientX, e.clientY, speakerId, segmentIndices)
          })
        })
      }

      /**
       * Find all consecutive segment indices that belong to the same speaker block
       */
      function findConsecutiveSpeakerSegments(startIndex, speakerId) {
        if (startIndex < 0 || !currentViewerData || !currentViewerData.results) {
          return []
        }
        
        const effectiveSegments = getEffectiveTranscriptionData()
        const indices = []
        
        // Start from the given index and collect all consecutive segments with the same speaker
        for (let i = startIndex; i < effectiveSegments.length; i++) {
          const segment = effectiveSegments[i]
          const segmentSpeaker = segment.speakers && segment.speakers.length > 0 ? segment.speakers[0] : null
          
          // Check if this segment belongs to the same speaker
          if (segmentSpeaker === speakerId) {
            indices.push(i)
          } else {
            // Speaker changed, stop here
            break
          }
        }
        
        return indices
      }

      let currentRenamingSpeakerId = null
      let currentContextSegmentIndices = []
      
      function showSpeakerContextMenu(x, y, speakerId, segmentIndices) {
        const contextMenu = document.getElementById('speaker-context-menu')
        currentRenamingSpeakerId = speakerId
        currentContextSegmentIndices = segmentIndices
        
        // Populate speaker swap submenu
        populateSpeakerSwapSubmenu()
        
        // Position the menu
        contextMenu.style.left = x + 'px'
        contextMenu.style.top = y + 'px'
        contextMenu.classList.add('show')
        
        // Hide menu when clicking outside
        const hideMenu = (e) => {
          if (!contextMenu.contains(e.target)) {
            contextMenu.classList.remove('show')
            document.removeEventListener('click', hideMenu)
          }
        }
        setTimeout(() => {
          document.addEventListener('click', hideMenu)
        }, 0)
      }

      function populateSpeakerSwapSubmenu() {
        if (!currentViewerData || !currentViewerData.results) return
        
        const submenu = document.getElementById('speaker-swap-submenu')
        submenu.innerHTML = ''
        
        // Get all unique speakers from the effective transcription
        const effectiveSegments = getEffectiveTranscriptionData()
        const speakers = new Set()
        effectiveSegments.forEach(segment => {
          if (segment.speakers && segment.speakers.length > 0) {
            speakers.add(segment.speakers[0])
          }
        })
        
        // Convert to sorted array
        const speakerList = Array.from(speakers).sort()
        
        // Create submenu items
        speakerList.forEach(speakerId => {
          const speakerNumber = parseInt(speakerId.replace('SPEAKER_', ''))
          const speakerLabel = translateSpeakerLabelText(currentViewerLanguage, speakerNumber)
          
          const item = document.createElement('div')
          item.className = 'context-submenu-item'
          item.textContent = speakerLabel
          item.dataset.speakerId = speakerId
          
          // Highlight current speaker
          if (speakerId === currentRenamingSpeakerId) {
            item.style.fontWeight = 'bold'
          }
          
          item.addEventListener('click', (e) => {
            e.stopPropagation()
            swapSegmentsSpeaker(currentContextSegmentIndices, speakerId)
            document.getElementById('speaker-context-menu').classList.remove('show')
          })
          
          submenu.appendChild(item)
        })
      }

      function showSpeakerRenameDialog() {
        const modal = document.getElementById('speaker-rename-modal')
        const input = document.getElementById('speaker-new-name')
        
        // Set current name if exists
        const currentName = speakerNameMappings[currentRenamingSpeakerId] || ''
        input.value = currentName
        
        modal.classList.add('show')
        input.focus()
      }

      /**
       * Swap speaker for multiple segments in a speaker block
       */
      function swapSegmentsSpeaker(segmentIndices, newSpeakerId) {
        if (!segmentIndices || segmentIndices.length === 0) {
          console.error('No segment indices provided for speaker swap')
          return
        }
        
        if (!currentViewerData || !currentViewerData.results) {
          console.error('No viewer data available')
          return
        }
        
        // If TipTap is active, extract edits before swap (to preserve text changes)
        if (tiptapEditor) {
          extractEditsFromTipTap()
        }
        
        let swappedCount = 0
        let removedCount = 0
        
        segmentIndices.forEach(segmentIndex => {
          if (segmentIndex < 0 || segmentIndex >= currentViewerData.results.length) {
            return
          }
          
          const originalSpeaker = currentViewerData.results[segmentIndex].speakers?.[0]
          
          // If swapping back to original, remove the mapping
          if (originalSpeaker === newSpeakerId) {
            delete speakerSegmentSwaps[segmentIndex]
            removedCount++
          } else {
            speakerSegmentSwaps[segmentIndex] = newSpeakerId
            swappedCount++
          }
        })
        
        console.log(`Speaker swap: ${swappedCount} segments swapped, ${removedCount} reverted to original`)
        
        // Refresh the display - recreate TipTap if in edit mode with TipTap
        if (isEditMode && tiptapEditor) {
          // Destroy old editor
          destroyTipTapEditor()
          
          // Recreate with updated data
          const transcriptionDiv = document.getElementById('viewer-transcription')
          transcriptionDiv.innerHTML = ''
          const segments = getEffectiveTranscriptionData()
          tiptapEditor = createTipTapEditor(transcriptionDiv, segments)
        } else {
          updateViewerTranscriptionDisplay()
        }
      }

      /**
       * Show context menu for a single segment
       */
      let currentContextSegmentIndex = -1
      
      function showSegmentContextMenu(x, y, segmentIndex) {
        const contextMenu = document.getElementById('segment-context-menu')
        currentContextSegmentIndex = segmentIndex
        
        // Populate speaker submenu
        populateSegmentSpeakerSubmenu(segmentIndex)
        
        // Position the menu
        contextMenu.style.left = x + 'px'
        contextMenu.style.top = y + 'px'
        contextMenu.classList.add('show')
        
        // Hide menu when clicking outside
        const hideMenu = (e) => {
          if (!contextMenu.contains(e.target)) {
            contextMenu.classList.remove('show')
            document.removeEventListener('click', hideMenu)
            
            // Remove highlight from segment
            const segment = document.querySelector(`.transcript-segment[data-segment-index="${currentContextSegmentIndex}"]`)
            if (segment) {
              segment.classList.remove('highlighted')
            }
          }
        }
        setTimeout(() => {
          document.addEventListener('click', hideMenu)
        }, 0)
      }

      /**
       * Show context menu for an individual edit segment
       */
      let currentEditSegmentElement = null
      
      function showEditSegmentContextMenu(x, y, segmentIndex, segmentElement) {
        const contextMenu = document.getElementById('segment-context-menu')
        currentContextSegmentIndices = [segmentIndex]
        currentEditSegmentElement = segmentElement
        
        // Populate speaker submenu for this segment
        populateSegmentSpeakerSubmenu(segmentIndex)
        
        // Position the menu
        contextMenu.style.left = x + 'px'
        contextMenu.style.top = y + 'px'
        contextMenu.classList.add('show')
        
        // Hide menu when clicking outside
        const hideMenu = (e) => {
          if (!contextMenu.contains(e.target)) {
            contextMenu.classList.remove('show')
            document.removeEventListener('click', hideMenu)
            
            // Remove highlight from segment
            if (currentEditSegmentElement) {
              currentEditSegmentElement.classList.remove('highlighted')
              currentEditSegmentElement = null
            }
          }
        }
        setTimeout(() => {
          document.addEventListener('click', hideMenu)
        }, 0)
      }

      /**
       * Populate the speaker submenu for segment context menu
       */
      function populateSegmentSpeakerSubmenu(segmentIndex) {
        if (!currentViewerData || !currentViewerData.results) return
        
        const submenu = document.getElementById('segment-speaker-submenu')
        submenu.innerHTML = ''
        
        // Get current speaker for this segment
        const effectiveSegments = getEffectiveTranscriptionData()
        const currentSegmentSpeaker = effectiveSegments[segmentIndex]?.speakers?.[0]
        
        // Get all unique speakers from the effective transcription
        const speakers = new Set()
        effectiveSegments.forEach(segment => {
          if (segment.speakers && segment.speakers.length > 0) {
            speakers.add(segment.speakers[0])
          }
        })
        
        // Convert to sorted array
        const speakerList = Array.from(speakers).sort()
        
        // Create submenu items
        speakerList.forEach(speakerId => {
          const speakerNumber = parseInt(speakerId.replace('SPEAKER_', ''))
          const speakerLabel = translateSpeakerLabelText(currentViewerLanguage, speakerNumber)
          
          const item = document.createElement('div')
          item.className = 'context-submenu-item'
          item.textContent = speakerLabel
          item.dataset.speakerId = speakerId
          
          // Highlight current speaker
          if (speakerId === currentSegmentSpeaker) {
            item.style.fontWeight = 'bold'
          }
          
          item.addEventListener('click', (e) => {
            e.stopPropagation()
            // Swap speaker for this single segment or all segments in the context
            const indices = currentContextSegmentIndices.length > 0 ? currentContextSegmentIndices : [segmentIndex]
            swapSegmentsSpeaker(indices, speakerId)
            document.getElementById('segment-context-menu').classList.remove('show')
            
            // Remove highlight and underline from edit segment (old contentEditable or TipTap)
            if (currentEditSegmentElement) {
              currentEditSegmentElement.classList.remove('highlighted')
              currentEditSegmentElement = null
            }
            if (currentTipTapHighlightedSegment) {
              currentTipTapHighlightedSegment.classList.remove('highlighted')
              currentTipTapHighlightedSegment.classList.remove('underlined')
              currentTipTapHighlightedSegment = null
            }
            const segment = document.querySelector(`.transcript-segment[data-segment-index="${segmentIndex}"]`)
            if (segment) {
              segment.classList.remove('highlighted')
            }
          })
          
          submenu.appendChild(item)
        })
      }

      function saveSpeakerName() {
        const input = document.getElementById('speaker-new-name')
        const newName = input.value.trim()
        
        if (newName) {
          // Check if another speaker already has this name
          const existingSpeaker = Object.entries(speakerNameMappings).find(
            ([speakerId, name]) => speakerId !== currentRenamingSpeakerId && name === newName
          )
          
          if (existingSpeaker) {
            showToast("שם זה כבר בשימוש עבור דובר אחר", "error")
            return
          }
          
          speakerNameMappings[currentRenamingSpeakerId] = newName
          console.log(`Renamed ${currentRenamingSpeakerId} to ${newName}`)
        } else {
          // Remove mapping if empty
          delete speakerNameMappings[currentRenamingSpeakerId]
          console.log(`Removed custom name for ${currentRenamingSpeakerId}`)
        }
        
        // Close modal
        document.getElementById('speaker-rename-modal').classList.remove('show')
        
        // Refresh the display - recreate TipTap if in edit mode with TipTap
        if (isEditMode && tiptapEditor) {
          // Extract current text edits
          extractEditsFromTipTap()
          // Destroy old editor
          destroyTipTapEditor()
          // Recreate with updated data
          const transcriptionDiv = document.getElementById('viewer-transcription')
          transcriptionDiv.innerHTML = ''
          const segments = getEffectiveTranscriptionData()
          tiptapEditor = createTipTapEditor(transcriptionDiv, segments)
        } else {
          updateViewerTranscriptionDisplay()
        }
      }

      function enterSegmentEditMode(segmentIndex, clickEvent = null) {
        // Save current segment if editing another one
        if (currentEditingSegmentIndex !== -1 && currentEditingSegmentIndex !== segmentIndex) {
          saveCurrentEditingSegment()
        }
        
        currentEditingSegmentIndex = segmentIndex
        const segment = document.querySelector(`.transcript-segment[data-segment-index="${segmentIndex}"]`)
        if (!segment) return
        
        // Make the segment editable
        segment.contentEditable = 'true'
        segment.classList.add('editing')
        segment.focus()
        
        // Place cursor based on click position or at start if no click event
        const sel = window.getSelection()
        sel.removeAllRanges()
        
        if (clickEvent) {
          // Place cursor at click position
          let range
          if (document.caretRangeFromPoint) {
            // Chrome, Safari
            range = document.caretRangeFromPoint(clickEvent.clientX, clickEvent.clientY)
          } else if (clickEvent.rangeParent) {
            // Firefox
            range = document.createRange()
            range.setStart(clickEvent.rangeParent, clickEvent.rangeOffset)
          }
          
          if (range) {
            sel.addRange(range)
          }
        } else {
          // No click event - place cursor at start (e.g., keyboard navigation)
          const range = document.createRange()
          if (segment.firstChild) {
            range.setStart(segment.firstChild, 0)
            range.collapse(true)
            sel.addRange(range)
          }
        }
      }

      function saveCurrentEditingSegment() {
        if (currentEditingSegmentIndex === -1) return
        
        const segment = document.querySelector(`.transcript-segment[data-segment-index="${currentEditingSegmentIndex}"]`)
        if (!segment) return
        
        const newText = segment.innerText.trim()
        const originalText = currentViewerData.results[currentEditingSegmentIndex].text.trim()
        
        if (newText !== originalText) {
          currentEdits[currentEditingSegmentIndex] = newText
        } else {
          // Remove edit if text is same as original
          delete currentEdits[currentEditingSegmentIndex]
        }
        
        segment.contentEditable = 'false'
        segment.classList.remove('editing')
      }

      function getSegmentDisplayText(segment, index) {
        const hasEdit = currentEdits.hasOwnProperty(index)
        const originalText = segment.text.trim()
        const editedText = hasEdit ? currentEdits[index] : originalText
        
        if (!hasEdit || editModeView === 'new') {
          return editedText
        } else if (editModeView === 'original') {
          return originalText
        } else if (editModeView === 'compared') {
          if (originalText === editedText) {
            return editedText
          }
          return generateWordLevelDiff(originalText, editedText)
        }
        
        return editedText
      }

      function generateWordLevelDiff(originalText, editedText) {
        // Use jsdiff library for word-level diff
        if (!window.Diff || !window.Diff.diffWords) {
          // Fallback if library not loaded
          return `<del style="color: #999;">${originalText}</del> ${editedText}`
        }
        
        const diff = window.Diff.diffWords(originalText, editedText)
        let result = []
        
        for (let i = 0; i < diff.length; i++) {
          const part = diff[i]
          const value = part.value
          
          if (part.added) {
            // Text was added in the edit
            result.push(`<ins style="background-color: rgba(76, 175, 80, 0.2); text-decoration: none;">${value}</ins>`)
          } else if (part.removed) {
            // Text was removed in the edit
            result.push(`<del style="color: #999; text-decoration: line-through;">${value}</del>`)
          } else {
            // Text is unchanged
            result.push(value)
          }
        }
        
        return result.join('')
      }

      // Keyboard navigation for edit mode
      // Helper function to get global text position
      function getGlobalCursorPosition() {
        const segment = document.querySelector(`.transcript-segment[data-segment-index="${currentEditingSegmentIndex}"]`)
        if (!segment) return 0
        
        const sel = window.getSelection()
        if (!sel.rangeCount) return 0
        
        const range = sel.getRangeAt(0)
        
        // Get cursor position within current segment
        const preCaretRange = range.cloneRange()
        preCaretRange.selectNodeContents(segment)
        preCaretRange.setEnd(range.endContainer, range.endOffset)
        const offsetInSegment = preCaretRange.toString().length
        
        // Add length of all previous segments (plus spaces between them)
        let globalOffset = 0
        const effectiveData = getEffectiveTranscriptionData()
        for (let i = 0; i < currentEditingSegmentIndex && i < effectiveData.length; i++) {
          const segmentText = currentEdits.hasOwnProperty(i) ? currentEdits[i] : effectiveData[i].text.trim()
          globalOffset += segmentText.length
          // Add 1 for the space after this segment
          globalOffset += 1
        }
        
        return globalOffset + offsetInSegment
      }
      
      // Helper function to set cursor at global position
      function setCursorAtGlobalPosition(globalPos) {
        const effectiveData = getEffectiveTranscriptionData()
        let currentPos = 0
        let targetSegmentIndex = -1
        let offsetInSegment = 0
        
        // Find which segment contains this global position
        for (let i = 0; i < effectiveData.length; i++) {
          const segmentText = currentEdits.hasOwnProperty(i) ? currentEdits[i] : effectiveData[i].text.trim()
          const segmentLength = segmentText.length
          
          // Check if position is within this segment
          if (currentPos + segmentLength > globalPos) {
            targetSegmentIndex = i
            offsetInSegment = globalPos - currentPos
            break
          }
          
          // Move past this segment
          currentPos += segmentLength
          
          // Check if position is at the end of this segment or on the space after
          if (i < effectiveData.length - 1) {
            if (currentPos === globalPos) {
              // Position is right at the end of this segment (before the space)
              targetSegmentIndex = i
              offsetInSegment = segmentLength
              break
            } else if (currentPos + 1 === globalPos) {
              // Position is on the space after this segment - go to start of next segment
              targetSegmentIndex = i + 1
              offsetInSegment = 0
              break
            }
            // Add 1 for the space after this segment
            currentPos += 1
          } else if (currentPos === globalPos) {
            // At the end of the last segment
            targetSegmentIndex = i
            offsetInSegment = segmentLength
            break
          }
        }
        
        // If position is beyond all segments, place at end of last segment
        if (targetSegmentIndex === -1 && effectiveData.length > 0) {
          targetSegmentIndex = effectiveData.length - 1
          const lastSegmentText = currentEdits.hasOwnProperty(targetSegmentIndex) 
            ? currentEdits[targetSegmentIndex] 
            : effectiveData[targetSegmentIndex].text.trim()
          offsetInSegment = lastSegmentText.length
        }
        
        if (targetSegmentIndex === -1) return
        
        // Switch to target segment if different
        if (targetSegmentIndex !== currentEditingSegmentIndex) {
          saveCurrentEditingSegment()
          currentEditingSegmentIndex = targetSegmentIndex
          const segment = document.querySelector(`.transcript-segment[data-segment-index="${targetSegmentIndex}"]`)
          if (!segment) return
          
          segment.contentEditable = 'true'
          segment.classList.add('editing')
          segment.focus()
        }
        
        // Set cursor position within the segment
        const segment = document.querySelector(`.transcript-segment[data-segment-index="${targetSegmentIndex}"]`)
        if (!segment || !segment.firstChild) return
        
        const range = document.createRange()
        const sel = window.getSelection()
        sel.removeAllRanges()
        
        // Clamp offset to valid range
        const maxOffset = segment.firstChild.textContent ? segment.firstChild.textContent.length : 0
        offsetInSegment = Math.min(Math.max(0, offsetInSegment), maxOffset)
        
        range.setStart(segment.firstChild, offsetInSegment)
        range.collapse(true)
        sel.addRange(range)
      }
      
      // Helper function to find next word boundary
      function findNextWordBoundary(text, position, direction) {
        if (direction > 0) {
          // Moving right - find start of next word
          let pos = position
          
          // If we're in a word, skip to end of current word
          if (pos < text.length && /\S/.test(text[pos])) {
            while (pos < text.length && /\S/.test(text[pos])) {
              pos++
            }
          }
          
          // Skip whitespace to find start of next word
          while (pos < text.length && /\s/.test(text[pos])) {
            pos++
          }
          
          return pos
        } else {
          // Moving left - find start of current or previous word
          let pos = position
          
          // Check if we're currently in the middle of a word
          const inMiddleOfWord = pos > 0 && pos < text.length && 
                                 /\S/.test(text[pos - 1]) && /\S/.test(text[pos])
          
          if (inMiddleOfWord) {
            // If in middle of word, go to start of current word
            while (pos > 0 && /\S/.test(text[pos - 1])) {
              pos--
            }
          } else {
            // Otherwise, skip whitespace then go to start of previous word
            while (pos > 0 && /\s/.test(text[pos - 1])) {
              pos--
            }
            while (pos > 0 && /\S/.test(text[pos - 1])) {
              pos--
            }
          }
          
          return pos
        }
      }

      // Old keyboard navigation code - no longer needed with speaker edit areas
      // Native contentEditable handles text selection, Ctrl+Arrow word jumping, etc.
      document.addEventListener('keydown', (e) => {
        // This handler is kept for potential future use but currently disabled
        // since we're using native contentEditable behavior in speaker edit areas
        if (false && !isEditMode || currentEditingSegmentIndex === -1) return
        
        // Enter key accepts the change and exits segment edit mode
        if (e.key === 'Enter') {
          e.preventDefault()
          saveCurrentEditingSegment()
          return
        }
        
        // Arrow navigation (regular and Ctrl+Arrow for word jumps)
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
          const rtlLangs = ['he', 'yi']
          const isRTL = rtlLangs.includes(currentViewerLanguage)
          
          // Determine logical direction (independent of RTL/LTR)
          let logicalDirection = 0
          if (isRTL) {
            // In RTL: left=forward, right=backward
            logicalDirection = e.key === 'ArrowLeft' ? 1 : -1
          } else {
            // In LTR: right=forward, left=backward
            logicalDirection = e.key === 'ArrowRight' ? 1 : -1
          }
          
          // Get current global position
          const currentGlobalPos = getGlobalCursorPosition()
          
          // Build full text for word boundary detection (with spaces between segments)
          const effectiveData = getEffectiveTranscriptionData()
          let fullText = ''
          for (let i = 0; i < effectiveData.length; i++) {
            const segmentText = currentEdits.hasOwnProperty(i) ? currentEdits[i] : effectiveData[i].text.trim()
            fullText += segmentText
            // Add space after segment (except for the last one)
            if (i < effectiveData.length - 1) {
              fullText += ' '
            }
          }
          
          let newGlobalPos
          if (e.ctrlKey) {
            // Word jump
            newGlobalPos = findNextWordBoundary(fullText, currentGlobalPos, logicalDirection)
          } else {
            // Character jump
            newGlobalPos = currentGlobalPos + logicalDirection
          }
          
          // Clamp to valid range
          newGlobalPos = Math.max(0, Math.min(fullText.length, newGlobalPos))
          
          // Only move if position actually changed
          if (newGlobalPos !== currentGlobalPos) {
            e.preventDefault()
            setCursorAtGlobalPosition(newGlobalPos)
          }
        } else if (e.key === 'Escape') {
          // Escape to exit segment editing
          e.preventDefault()
          saveCurrentEditingSegment()
          currentEditingSegmentIndex = -1
          updateViewerTranscriptionDisplay()
        }
      })

      function formatWithTimecodesForSegments(segments, useViewMode = false) {
        if (!segments || segments.length === 0) return ""

        const separator = displaySettings.textFormat === "continuous" ? " " : "<br>"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          const shouldEndGroup =
            (segment.start <= currentTimeMarker && segment.end >= currentTimeMarker) ||
            i === segments.length - 1 ||
            (i < segments.length - 1 && segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            let groupText
            if (displaySettings.diarizationDisplay !== "disabled") {
              groupText = joinSegmentsWithSpeakerChangesForSegments(currentGroup, separator, "<br>", true, useViewMode)
            } else {
              // Wrap each segment with timing data
              groupText = currentGroup.map((seg, idx) => {
                const actualIndex = segments.indexOf(seg)
                const displayText = useViewMode ? getSegmentDisplayText(seg, actualIndex) : seg.text.trim()
                const editableAttr = isEditMode ? '' : ''
                return `<span class="transcript-segment" data-start="${seg.start}" data-end="${seg.end}" data-segment-index="${actualIndex}"${editableAttr}>${displayText}</span>`
              }).join(separator)
            }

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push("[" + formattedStartTime + "-" + formattedEndTime + "]<br>" + groupText)

            currentGroup = []
            currentTimeMarker += 30

            while (i < segments.length - 1 && segments[i + 1].start > currentTimeMarker) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("<br><br>")
      }


      /**
       * Groups consecutive segments by speaker
       * Returns array of groups, each with speaker ID and segment indices
       */
      function groupSegmentsBySpeaker(segments) {
        if (!segments || segments.length === 0) return []
        
        const groups = []
        let currentGroup = null
        
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          const segmentSpeaker = segment.speakers && segment.speakers.length > 0 ? segment.speakers[0] : null
          
          if (!currentGroup || currentGroup.speaker !== segmentSpeaker) {
            // Start new group
            currentGroup = {
              speaker: segmentSpeaker,
              startIndex: i,
              endIndex: i,
              segments: [i]
            }
            groups.push(currentGroup)
          } else {
            // Continue current group
            currentGroup.endIndex = i
            currentGroup.segments.push(i)
          }
        }
        
        return groups
      }

      function joinSegmentsWithSpeakerChangesForSegments(segments, continuousSeparator, segmentSeparator, isHTML = true, useViewMode = false) {
        if (!segments || segments.length === 0) return ""
        
        const result = []
        let currentSpeaker = null
        const diarizationEnabled = displaySettings.diarizationDisplay !== "disabled"
        
        // In edit mode, create editable divs per speaker group
        if (isEditMode && isHTML) {
          const groups = groupSegmentsBySpeaker(segments)
          
          for (const group of groups) {
            const showSpeakerLabel = diarizationEnabled && group.speaker !== currentSpeaker
            
            // Wrap each segment in a span for individual targeting
            const segmentSpans = group.segments.map((idx, i) => {
              const seg = segments[idx]
              const text = seg.text.trim()
              // Add space before segment (except first)
              const space = i > 0 ? ' ' : ''
              return `${space}<span class="edit-segment" data-segment-index="${idx}">${text}</span>`
            }).join('')
            
            // Create speaker label if needed
            const labelHTML = showSpeakerLabel ? getSpeakerLabelForLanguage(segments[group.startIndex], currentViewerLanguage) : ''
            
            // Create editable div for this speaker group
            const segmentIndices = group.segments.join(',')
            const editableDiv = `<div class="speaker-edit-area" contenteditable="true" data-segment-indices="${segmentIndices}" data-speaker="${group.speaker || ''}">${segmentSpans}</div>`
            
            if (result.length === 0) {
              result.push(labelHTML + editableDiv)
            } else if (showSpeakerLabel) {
              result.push('<br><br>' + labelHTML + editableDiv)
            } else {
              result.push(continuousSeparator + editableDiv)
            }
            
            currentSpeaker = group.speaker
          }
          
          return result.join("")
        }
        
        // Normal mode (not editing) - use original logic
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          const segmentSpeaker = segment.speakers && segment.speakers.length > 0 ? segment.speakers[0] : null
          
          const showSpeakerLabel = diarizationEnabled && segmentSpeaker !== currentSpeaker
          
          let segmentText
          if (isHTML) {
            const labelHTML = showSpeakerLabel ? getSpeakerLabelForLanguage(segment, currentViewerLanguage) : ''
            const displayText = useViewMode ? getSegmentDisplayText(segment, i) : segment.text.trim()
            segmentText = labelHTML + `<span class="transcript-segment" data-start="${segment.start}" data-end="${segment.end}" data-segment-index="${i}">${displayText}</span>`
          } else {
            const displayText = useViewMode ? getSegmentDisplayText(segment, i) : segment.text.trim()
            segmentText = showSpeakerLabel 
              ? getSpeakerLabelPlainForLanguage(segment, currentViewerLanguage) + displayText
              : displayText
          }
          
          if (i === 0) {
            result.push(segmentText)
            currentSpeaker = segmentSpeaker
          } else if (diarizationEnabled && segmentSpeaker !== currentSpeaker) {
            result.push('<br><br>' + segmentText)
            currentSpeaker = segmentSpeaker
          } else {
            result.push(continuousSeparator + segmentText)
            if (diarizationEnabled) {
              currentSpeaker = segmentSpeaker
            }
          }
        }
        
        return result.join("")
      }


      /**
       * Returns the effective transcription data with all edits applied.
       * This creates a modified copy of the original data, applying:
       * - Text edits from currentEdits
       * - Speaker swaps from speakerSegmentSwaps
       * 
       * @returns {Array} Array of segment objects with edits applied
       */
      function getEffectiveTranscriptionData() {
        if (!currentViewerData || !currentViewerData.results) {
          return []
        }
        
        // Deep clone the segments to avoid modifying original data
        const segments = currentViewerData.results.map((segment, index) => {
          const cloned = {
            ...segment,
            speakers: segment.speakers ? [...segment.speakers] : [],
            text: segment.text
          }
          
          // Apply text edit if exists
          if (currentEdits.hasOwnProperty(index)) {
            cloned.text = currentEdits[index]
          }
          
          // Apply speaker swap if exists
          if (speakerSegmentSwaps.hasOwnProperty(index) && cloned.speakers.length > 0) {
            cloned.speakers[0] = speakerSegmentSwaps[index]
          }
          
          return cloned
        })
        
        return segments
      }
      
      /**
       * Helper function to get the effective speaker for a specific segment.
       * Uses the effective transcription data.
       */
      function getEffectiveSpeaker(segment, segmentIndex) {
        // Check if this segment has a speaker swap
        if (speakerSegmentSwaps.hasOwnProperty(segmentIndex)) {
          return speakerSegmentSwaps[segmentIndex]
        }
        // Otherwise return the original speaker
        return segment.speakers && segment.speakers.length > 0 ? segment.speakers[0] : null
      }

      function getSpeakerLabelForLanguage(segment, lang) {
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(segment.speakers[0].replace("SPEAKER_", ""))
          const speakerLabelText = translateSpeakerLabelText(lang, speakerNumber)
          return `<span class="speaker speaker-${speakerNumber}">${speakerLabelText}: </span>`
        }
        return `<span class="speaker">${translateSpeakerUnknownText(lang)}: </span>`
      }

      function getSpeakerLabelPlainForLanguage(segment, lang) {
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(segment.speakers[0].replace("SPEAKER_", ""))
          return `${translateSpeakerLabelText(lang, speakerNumber)}: `
        }
        return `${translateSpeakerUnknownText(lang)}: `
      }

      function updateViewerTranscriptionDirectionUI() {
        const lang = currentViewerLanguage
        const rtlLangs = ['he', 'yi']
        const isRTL = rtlLangs.includes(lang)
        const viewerTranscription = document.getElementById('viewer-transcription')
        if (viewerTranscription) {
          viewerTranscription.style.direction = isRTL ? 'rtl' : 'ltr'
          viewerTranscription.style.textAlign = isRTL ? 'right' : 'left'
        }
      }

      // Wire up viewer controls
      document.getElementById('back-to-files-btn').addEventListener('click', () => {
        document.getElementById('viewer-tab-btn').style.display = 'none'
        // Stop processing poll if active
        stopViewerProcessingPoll()
        pendingViewerFilename = null
        hideViewerProcessingState()
        
        // Reset edit mode
        isEditMode = false
        currentEditingSegmentIndex = -1
        currentEdits = {}
        speakerNameMappings = {}
        speakerSegmentSwaps = {}
        editModeView = 'new'
        document.getElementById('viewer-edit-mode-toggle').style.display = 'none'
        const editBtn = document.getElementById('viewer-edit-toggle-btn')
        editBtn.innerHTML = '<i data-lucide="pen"></i>'
        editBtn.title = 'ערוך'
        editBtn.classList.remove('toggle-active')
        if (window.lucide && typeof window.lucide.createIcons === 'function') {
          window.lucide.createIcons()
        }
        
        // Hide and reset audio player
        const playerContainer = document.getElementById('viewer-audio-player-container')
        const audioPlayer = document.getElementById('viewer-audio-player')
        playerContainer.classList.remove('visible')
        audioPlayer.pause()
        audioPlayer.currentTime = 0
        // Remove timeupdate listener
        audioPlayer.removeEventListener('timeupdate', handleAudioTimeUpdate)
        // Clear any playing segments
        document.querySelectorAll('.transcript-segment.playing').forEach(seg => {
          seg.classList.remove('playing')
        })
        // Reset playing segment index
        currentPlayingSegmentIndex = -1
        switchTab('files')
      })

      document.getElementById('viewer-text-format-toggle').addEventListener('click', () => {
        displaySettings.textFormat = displaySettings.textFormat === "segments" ? "continuous" : "segments"
        localStorage.setItem("displaySettings", JSON.stringify(displaySettings))
        updateViewerTextFormatToggleUI()
        updateViewerTranscriptionDisplay()
      })

      document.getElementById('viewer-timestamps-toggle').addEventListener('click', () => {
        displaySettings.timestampFormat = displaySettings.timestampFormat === 'segments' ? 'none' : 'segments'
        localStorage.setItem('displaySettings', JSON.stringify(displaySettings))
        updateViewerTimestampsToggleUI()
        updateViewerTranscriptionDisplay()
      })

      document.getElementById('viewer-diarization-toggle').addEventListener('click', () => {
        displaySettings.diarizationDisplay = displaySettings.diarizationDisplay !== 'disabled' ? 'disabled' : 'enabled'
        localStorage.setItem('displaySettings', JSON.stringify(displaySettings))
        updateViewerDiarizationToggleUI()
        updateViewerTranscriptionDisplay()
      })

      function updateViewerTextFormatToggleUI() {
        const btn = document.getElementById('viewer-text-format-toggle')
        const svg = document.getElementById('viewer-text-format-icon')
        const isSegments = displaySettings.textFormat === "segments"
        
        if (svg) {
          while (svg.firstChild) svg.removeChild(svg.firstChild)
          if (isSegments) {
            svg.insertAdjacentHTML("afterbegin",
              '<circle cx="20" cy="6" r="2" fill="currentColor" stroke="none" />\n' +
              '<circle cx="20" cy="12" r="2" fill="currentColor" stroke="none" />\n' +
              '<circle cx="20" cy="18" r="2" fill="currentColor" stroke="none" />\n' +
              '<path d="M17 6H4" />\n' +
              '<path d="M17 12H7" />\n' +
              '<path d="M17 18H4" />'
            )
          } else {
            svg.insertAdjacentHTML("afterbegin",
              '<path d="M4 6h16"/>\n' + '<path d="M10 12h10"/>\n' + '<path d="M4 18h16"/>'
            )
          }
        }
        
        btn.title = isSegments ? (window.I18N ? window.I18N.t('textFormatSegmentsTitle') : 'פורמט הטקסט: פסקאות נפרדות') : (window.I18N ? window.I18N.t('textFormatContinuousTitle') : 'פורמט הטקסט: טקסט רציף')
        btn.classList.toggle('toggle-active', isSegments)
      }

      function updateViewerTimestampsToggleUI() {
        const btn = document.getElementById('viewer-timestamps-toggle')
        const enabled = displaySettings.timestampFormat === "segments"
        btn.classList.toggle('toggle-active', enabled)
        btn.title = enabled ? (window.I18N ? window.I18N.t('timestampsSegments') : 'כולל קודי זמן') : (window.I18N ? window.I18N.t('timestampsNone') : 'ללא קודי זמן')
      }

      function updateViewerDiarizationToggleUI() {
        const btn = document.getElementById('viewer-diarization-toggle')
        const enabled = displaySettings.diarizationDisplay !== "disabled"
        btn.classList.toggle('toggle-active', enabled)
        btn.title = enabled ? (window.I18N ? window.I18N.t('diarizationEnabled') : 'הצג דוברים') : (window.I18N ? window.I18N.t('diarizationDisabled') : 'הסתר דוברים')
      }

      // Copy button in viewer
      document.getElementById('viewer-copy-btn').addEventListener('click', () => {
        if (!currentViewerData || !currentViewerData.results) return
        // Get effective data with all edits applied
        const effectiveSegments = getEffectiveTranscriptionData()
        const plainText = getPlainTextFromSegmentsForViewer(effectiveSegments)
        navigator.clipboard.writeText(plainText).then(() => {
          showToast((window.I18N ? window.I18N.t('copySuccess') : "הטקסט הועתק ללוח בהצלחה"), "success")
        }).catch(() => {
          showToast((window.I18N ? window.I18N.t('copyError') : "שגיאה בהעתקה"), "error")
        })
      })

      // Edit mode toggle button (becomes cancel in edit mode)
      document.getElementById('viewer-edit-toggle-btn').addEventListener('click', async () => {
        if (!currentViewerData || !currentViewerData.results) return
        
        if (isEditMode) {
          // Cancel editing - exit without saving
          exitEditMode(false)
        } else {
          // Enter edit mode
          enterEditMode()
        }
      })
      
      // Save edit button
      document.getElementById('viewer-save-edit-btn').addEventListener('click', async () => {
        if (!isEditMode) return
        
        // Save edits and exit
        await saveEdits()
        exitEditMode()
      })

      function enterEditMode() {
        isEditMode = true
        const editBtn = document.getElementById('viewer-edit-toggle-btn')
        const saveBtn = document.getElementById('viewer-save-edit-btn')
        const viewModeBtn = document.getElementById('viewer-edit-mode-toggle')
        
        // Always set to 'new' view mode when entering edit mode
        editModeView = 'new'
        
        // Lock display settings for editing mode
        displaySettings.diarizationDisplay = 'enabled'
        displaySettings.textFormat = 'continuous'
        displaySettings.timestampFormat = 'none'
        localStorage.setItem('displaySettings', JSON.stringify(displaySettings))
        
        // Update toggle UI to reflect locked settings
        updateViewerDiarizationToggleUI()
        updateViewerTextFormatToggleUI()
        updateViewerTimestampsToggleUI()
        
        // Disable toggle buttons during edit mode
        document.getElementById('viewer-text-format-toggle').disabled = true
        document.getElementById('viewer-timestamps-toggle').disabled = true
        document.getElementById('viewer-diarization-toggle').disabled = true
        
        // Show view mode button but disable it
        viewModeBtn.style.display = 'inline-block'
        viewModeBtn.disabled = true
        updateViewModeButtonUI()
        
        // Change edit button to cancel icon
        editBtn.innerHTML = '<i data-lucide="x"></i>'
        editBtn.title = 'ביטול'
        editBtn.classList.add('toggle-active')
        
        // Show save button
        saveBtn.style.display = 'inline-block'
        
        if (window.lucide && typeof window.lucide.createIcons === 'function') {
          window.lucide.createIcons()
        }
        
        // Add edit mode class to transcription container for styling
        const transcriptionDiv = document.getElementById('viewer-transcription')
        if (transcriptionDiv) {
          transcriptionDiv.classList.add('edit-mode-active')
        }
        
        // Create TipTap editor if ready, otherwise fall back to old method
        if (tiptapReady && currentViewerData && currentViewerData.results) {
          // Clear the container
          transcriptionDiv.innerHTML = ''
          
          // Get effective data with edits applied
          const segments = getEffectiveTranscriptionData()
          
          // Create TipTap editor
          tiptapEditor = createTipTapEditor(transcriptionDiv, segments)
          
          if (!tiptapEditor) {
            console.error('Failed to create TipTap editor, falling back to old method')
            updateViewerTranscriptionDisplay()
          }
        } else {
          // Fall back to old contentEditable method
          console.log('TipTap not ready, using fallback edit mode')
          updateViewerTranscriptionDisplay()
        }
      }

      function exitEditMode(saveChanges = true) {
        isEditMode = false
        currentEditingSegmentIndex = -1
        
        // Extract edits from TipTap or speaker edit areas before exiting if saving
        if (saveChanges) {
          if (tiptapEditor) {
            extractEditsFromTipTap()
          } else {
            extractEditsFromSpeakerAreas()
          }
        }
        
        // Destroy TipTap editor if it exists
        if (tiptapEditor) {
          destroyTipTapEditor()
        }
        
        const editBtn = document.getElementById('viewer-edit-toggle-btn')
        const saveBtn = document.getElementById('viewer-save-edit-btn')
        const viewModeBtn = document.getElementById('viewer-edit-mode-toggle')
        
        // Re-enable toggle buttons
        document.getElementById('viewer-text-format-toggle').disabled = false
        document.getElementById('viewer-timestamps-toggle').disabled = false
        document.getElementById('viewer-diarization-toggle').disabled = false
        
        // Re-enable view mode button
        viewModeBtn.disabled = false
        
        // Change button back to pen icon
        editBtn.innerHTML = '<i data-lucide="pen"></i>'
        editBtn.title = 'ערוך'
        editBtn.classList.remove('toggle-active')
        
        // Hide save button
        saveBtn.style.display = 'none'
        
        if (window.lucide && typeof window.lucide.createIcons === 'function') {
          window.lucide.createIcons()
        }
        
        // Remove edit mode class from transcription container
        const transcriptionDiv = document.getElementById('viewer-transcription')
        if (transcriptionDiv) {
          transcriptionDiv.classList.remove('edit-mode-active')
        }
        
        // Refresh display
        updateViewerTranscriptionDisplay()
      }

      // View mode toggle (original/compared/new)
      document.getElementById('viewer-edit-mode-toggle').addEventListener('click', (e) => {
        // Don't allow toggle if button is disabled
        if (e.target.disabled || e.currentTarget.disabled) {
          return
        }
        
        // Cycle through modes: new -> compared -> original -> new
        if (editModeView === 'new') {
          editModeView = 'compared'
        } else if (editModeView === 'compared') {
          editModeView = 'original'
        } else {
          editModeView = 'new'
        }
        
        updateViewModeButtonUI()
        updateViewerTranscriptionDisplay()
      })

      function updateViewModeButtonUI() {
        const btn = document.getElementById('viewer-edit-mode-toggle')
        if (editModeView === 'original') {
          btn.title = 'מקור'
          btn.innerHTML = '<i data-lucide="file-text"></i>'
        } else if (editModeView === 'compared') {
          btn.title = 'השוואה'
          btn.innerHTML = '<i data-lucide="git-compare"></i>'
        } else {
          btn.title = 'חדש'
          btn.innerHTML = '<i data-lucide="eye"></i>'
        }
        if (window.lucide && typeof window.lucide.createIcons === 'function') {
          window.lucide.createIcons()
        }
      }

      /**
       * Extract edits from speaker edit areas and update currentEdits
       */
      function extractEditsFromSpeakerAreas() {
        const editAreas = document.querySelectorAll('.speaker-edit-area')
        
        editAreas.forEach(area => {
          const segmentIndices = area.dataset.segmentIndices.split(',').map(i => parseInt(i))
          const editedText = area.innerText.trim()
          
          if (segmentIndices.length === 0) return
          
          // Get original text for comparison
          let originalText = ''
          segmentIndices.forEach((idx, i) => {
            if (i > 0) originalText += ' '
            originalText += currentViewerData.results[idx].text.trim()
          })
          
          // Check if text was actually edited
          if (editedText !== originalText) {
            // Store the edited text in the first segment
            currentEdits[segmentIndices[0]] = editedText
            
            // Clear the remaining segments in the group (they're now merged into the first)
            for (let i = 1; i < segmentIndices.length; i++) {
              currentEdits[segmentIndices[i]] = ''
            }
          } else {
            // No changes, remove any existing edits for this group
            segmentIndices.forEach(idx => {
              delete currentEdits[idx]
            })
          }
        })
      }

      async function saveEdits() {
        if (!currentViewerEntry || !currentViewerData) return
        
        // Extract edits from TipTap or speaker edit areas if in edit mode
        if (isEditMode) {
          if (tiptapEditor) {
            extractEditsFromTipTap()
          } else {
            extractEditsFromSpeakerAreas()
          }
        }
        
        if (Object.keys(currentEdits).length === 0 && 
            Object.keys(speakerNameMappings).length === 0 && 
            Object.keys(speakerSegmentSwaps).length === 0) {
          showToast("אין שינויים לשמירה", "info")
          return
        }
        
        try {
          const response = await fetch(`/appdata/edits/${currentViewerEntry.results_id}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              edits: currentEdits,
              speakerNames: speakerNameMappings,
              speakerSwaps: speakerSegmentSwaps
            })
          })
          
          if (response.ok) {
            showToast("השינויים נשמרו בהצלחה", "success")
          } else {
            throw new Error('Failed to save edits')
          }
        } catch (error) {
          console.error('Error saving edits:', error)
          showToast("שגיאה בשמירת השינויים", "error")
        }
      }

      async function loadEdits(uuid) {
        try {
          const response = await fetch(`/appdata/edits/${uuid}`)
          if (response.ok) {
            const data = await response.json()
            currentEdits = data.edits || {}
            speakerNameMappings = data.speakerNames || {}
            speakerSegmentSwaps = data.speakerSwaps || {}
            
            // Show view mode button if any edits exist (text, speaker names, or speaker swaps)
            if (Object.keys(currentEdits).length > 0 || 
                Object.keys(speakerNameMappings).length > 0 || 
                Object.keys(speakerSegmentSwaps).length > 0) {
              document.getElementById('viewer-edit-mode-toggle').style.display = 'inline-block'
              updateViewModeButtonUI()
            }
          } else if (response.status === 404) {
            // No edits file exists yet
            currentEdits = {}
            speakerNameMappings = {}
            speakerSegmentSwaps = {}
          }
        } catch (error) {
          console.error('Error loading edits:', error)
          currentEdits = {}
          speakerNameMappings = {}
          speakerSegmentSwaps = {}
        }
      }

      function getPlainTextFromSegmentsForViewer(segments) {
        let result
        if (displaySettings.timestampFormat === "segments") {
          result = formatWithTimecodesPlainForViewer(segments)
        } else {
          const continuousSeparator = displaySettings.textFormat === "continuous" ? " " : "\n"
          const segmentSeparator = "\n"
          result = joinSegmentsWithSpeakerChangesForSegments(segments, continuousSeparator, segmentSeparator, false)
        }
        return result + "\n\n" + (window.I18N ? window.I18N.t('transcriptFooter') : "תומלל באמצעות שירות התמלול של ivrit.ai")
      }

      function formatWithTimecodesPlainForViewer(segments) {
        if (!segments || segments.length === 0) return ""

        const separator = displaySettings.textFormat === "continuous" ? " " : "\n"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          const shouldEndGroup =
            (segment.start <= currentTimeMarker && segment.end >= currentTimeMarker) ||
            i === segments.length - 1 ||
            (i < segments.length - 1 && segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            const groupText = displaySettings.diarizationDisplay !== "disabled"
              ? joinSegmentsWithSpeakerChangesForSegments(currentGroup, separator, "\n", false)
              : currentGroup.map((seg) => seg.text.trim()).join(separator)

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push("[" + formattedStartTime + "-" + formattedEndTime + "]\n" + groupText)

            currentGroup = []
            currentTimeMarker += 30

            while (i < segments.length - 1 && segments[i + 1].start > currentTimeMarker) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("\n\n")
      }

      // Viewer download menu - all formats enabled
      document.getElementById('viewer-menu-json').addEventListener('click', () => {
        if (!currentViewerData) return
        const fileName = document.getElementById('viewer-file-name').textContent
        // Download with all edits applied
        const effectiveSegments = getEffectiveTranscriptionData()
        downloadInFormat(effectiveSegments, fileName, 'json', currentViewerLanguage)
      })
      
      document.getElementById('viewer-menu-vtt').addEventListener('click', () => {
        if (!currentViewerData) return
        const fileName = document.getElementById('viewer-file-name').textContent
        // Download with all edits applied
        const effectiveSegments = getEffectiveTranscriptionData()
        downloadInFormat(effectiveSegments, fileName, 'vtt', currentViewerLanguage)
      })
      
      document.getElementById('viewer-menu-srt').addEventListener('click', () => {
        if (!currentViewerData) return
        const fileName = document.getElementById('viewer-file-name').textContent
        // Download with all edits applied
        const effectiveSegments = getEffectiveTranscriptionData()
        downloadInFormat(effectiveSegments, fileName, 'srt', currentViewerLanguage)
      })
      
      document.getElementById('viewer-menu-docx').addEventListener('click', () => {
        if (!currentViewerData) return
        const fileName = document.getElementById('viewer-file-name').textContent
        // Download with all edits applied
        const effectiveSegments = getEffectiveTranscriptionData()
        downloadInFormat(effectiveSegments, fileName, 'docx', currentViewerLanguage)
      })

      // ========== MICROPHONE RECORDING FUNCTIONALITY ==========
      
      let mediaRecorder = null
      let audioChunks = []
      let recordingStream = null
      let audioContext = null
      let analyser = null
      let animationFrameId = null
      let recordingStartTime = null
      let recordingTimerInterval = null
      let recordedBlob = null

      const recordMenuBtn = document.getElementById('record-menu-btn')
      const recordDropdown = document.querySelector('.record-dropdown')
      const recordMenu = document.querySelector('.record-menu')
      const recordMicOnlyBtn = document.getElementById('record-mic-only-btn')
      const recordMicScreenBtn = document.getElementById('record-mic-screen-btn')
      const recordScreenOnlyBtn = document.getElementById('record-screen-only-btn')
      const stopRecordingBtn = document.getElementById('stop-recording-btn')
      const recordingInterface = document.getElementById('recording-interface')
      const recordedAudioPreview = document.getElementById('recorded-audio-preview')
      const recordedAudioPlayer = document.getElementById('recorded-audio-player')
      const waveformCanvas = document.getElementById('waveform-canvas')
      const recordingTimer = document.getElementById('recording-timer')
      
      // Toggle dropdown menu
      recordMenuBtn.addEventListener('click', (e) => {
        e.stopPropagation()
        recordDropdown.style.display = recordDropdown.style.display === 'none' ? 'block' : 'none'
      })
      
      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!recordMenu.contains(e.target)) {
          recordDropdown.style.display = 'none'
        }
      })
      
      // Helper to close dropdown after selection
      const closeDropdown = () => {
        recordDropdown.style.display = 'none'
      }

      // Start recording from microphone only
      recordMicOnlyBtn.addEventListener('click', async () => {
        closeDropdown()
        try {
          // Request microphone access
          recordingStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              channelCount: 1,
              sampleRate: 48000,
              echoCancellation: true,
              noiseSuppression: true
            } 
          })

          // Set up Web Audio API for visualization
          audioContext = new (window.AudioContext || window.webkitAudioContext)()
          const source = audioContext.createMediaStreamSource(recordingStream)
          analyser = audioContext.createAnalyser()
          analyser.fftSize = 2048
          analyser.smoothingTimeConstant = 0.8
          source.connect(analyser)

          // Create MediaRecorder with opus codec if available
          const options = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
            ? { mimeType: 'audio/webm;codecs=opus' }
            : { mimeType: 'audio/webm' }
          
          mediaRecorder = new MediaRecorder(recordingStream, options)
          audioChunks = []

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data)
            }
          }

          mediaRecorder.onstop = () => {
            recordedBlob = new Blob(audioChunks, { type: 'audio/webm' })
            const audioUrl = URL.createObjectURL(recordedBlob)
            recordedAudioPlayer.src = audioUrl
            
            // Stop all tracks
            if (recordingStream) {
              recordingStream.getTracks().forEach(track => track.stop())
              recordingStream = null
            }

            // Stop audio context
            if (audioContext) {
              audioContext.close()
              audioContext = null
            }

            // Convert blob to file and add to file list
            const fileName = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.webm`
            const file = new File([recordedBlob], fileName, { type: 'audio/webm' })
            
            selectedFile = file
            selectedFiles = []
            batchMode = false
            transcribeBtn.disabled = false

            // Show file preview
            showFilePreview(file)

            // Show both player and normal UI
            recordingInterface.style.display = 'none'
            recordedAudioPreview.style.display = 'block'
            dropArea.style.display = 'block'
            recordMenu.style.display = 'inline-block'

            // Refresh icons
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
              window.lucide.createIcons()
            }

            showToast((window.I18N ? window.I18N.t('recordingReadyToTranscribe') : 'ההקלטה מוכנה לתמלול. לחץ על "תמלל" להמשך.'), 'success')
          }

          // Start recording
          mediaRecorder.start(100) // Collect data every 100ms
          recordingStartTime = Date.now()

          // Show recording interface
          dropArea.style.display = 'none'
          recordMenu.style.display = 'none'
          recordingInterface.style.display = 'block'

          // Start visualization and timer
          drawWaveform()
          startRecordingTimer()

          // Refresh icons
          if (window.lucide && typeof window.lucide.createIcons === 'function') {
            window.lucide.createIcons()
          }

        } catch (error) {
          console.error('Error accessing microphone:', error)
          if (error.name === 'NotAllowedError') {
            showToast((window.I18N ? window.I18N.t('micPermissionDenied') : 'הגישה למיקרופון נדחתה. אנא אפשר גישה למיקרופון בהגדרות הדפדפן.'), 'error')
          } else {
            showToast((window.I18N ? window.I18N.t('micError') : 'שגיאה בגישה למיקרופון. אנא ודא שהמיקרופון מחובר ומופעל.'), 'error')
          }
        }
      })

      // Start recording from screen/system audio only (no microphone)
      recordScreenOnlyBtn.addEventListener('click', async () => {
        closeDropdown()
        try {
          // Request system audio only
          let systemStream = null
          try {
            systemStream = await navigator.mediaDevices.getDisplayMedia({
              video: true, // Required for picker dialog
              audio: true, // Makes audio sharing available
              preferCurrentTab: false,
              surfaceSwitching: "include",
              systemAudio: "include"
            })
            
            // Stop all video tracks immediately - we only want audio
            systemStream.getVideoTracks().forEach(track => track.stop())
            
            // Check if audio was actually captured
            if (!systemStream.getAudioTracks().length) {
              throw new Error('No audio track available')
            }
          } catch (displayError) {
            console.warn('Could not capture system audio:', displayError)
            showToast((window.I18N ? window.I18N.t('screenAudioNotSelected') : 'לא נבחר אודיו מערכת'), 'error')
            return
          }

          // Set up Web Audio API for visualization
          audioContext = new (window.AudioContext || window.webkitAudioContext)()
          const source = audioContext.createMediaStreamSource(systemStream)
          analyser = audioContext.createAnalyser()
          analyser.fftSize = 2048
          analyser.smoothingTimeConstant = 0.8
          source.connect(analyser)

          // Use the system stream for recording
          recordingStream = systemStream

          // Create MediaRecorder with opus codec if available
          const options = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
            ? { mimeType: 'audio/webm;codecs=opus' }
            : { mimeType: 'audio/webm' }
          
          mediaRecorder = new MediaRecorder(recordingStream, options)
          audioChunks = []

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data)
            }
          }

          mediaRecorder.onstop = () => {
            recordedBlob = new Blob(audioChunks, { type: 'audio/webm' })
            const audioUrl = URL.createObjectURL(recordedBlob)
            recordedAudioPlayer.src = audioUrl
            
            // Stop all tracks
            if (recordingStream) {
              recordingStream.getTracks().forEach(track => track.stop())
              recordingStream = null
            }

            // Stop audio context
            if (audioContext) {
              audioContext.close()
              audioContext = null
            }

            // Convert blob to file and add to file list
            const fileName = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.webm`
            const file = new File([recordedBlob], fileName, { type: 'audio/webm' })
            
            selectedFile = file
            selectedFiles = []
            batchMode = false
            transcribeBtn.disabled = false

            // Show file preview
            showFilePreview(file)

            // Show both player and normal UI
            recordingInterface.style.display = 'none'
            recordedAudioPreview.style.display = 'block'
            dropArea.style.display = 'block'
            recordMenu.style.display = 'inline-block'

            // Refresh icons
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
              window.lucide.createIcons()
            }

            showToast((window.I18N ? window.I18N.t('recordingReadyToTranscribe') : 'ההקלטה מוכנה לתמלול. לחץ על "תמלל" להמשך.'), 'success')
          }

          // Start recording
          mediaRecorder.start(100)
          recordingStartTime = Date.now()

          // Show recording interface
          dropArea.style.display = 'none'
          recordMenu.style.display = 'none'
          recordingInterface.style.display = 'block'

          // Start visualization and timer
          drawWaveform()
          startRecordingTimer()

          // Refresh icons
          if (window.lucide && typeof window.lucide.createIcons === 'function') {
            window.lucide.createIcons()
          }

        } catch (error) {
          console.error('Error accessing screen audio:', error)
          showToast((window.I18N ? window.I18N.t('screenAudioError') : 'שגיאה בגישה לאודיו המערכת'), 'error')
        }
      })

      // Start recording from microphone and system audio
      recordMicScreenBtn.addEventListener('click', async () => {
        closeDropdown()
        try {
          // Request microphone access
          const micStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              channelCount: 1,
              sampleRate: 48000,
              echoCancellation: true,
              noiseSuppression: true
            } 
          })

          // Request system audio (screen/tab/window audio)
          // Note: We need to request video for the browser to show the picker dialog
          // We'll immediately stop the video track and only use audio
          // Note: Browsers don't allow programmatically checking "Share audio" for security,
          // but including audio constraints makes it available in the dialog
          let systemStream = null
          try {
            systemStream = await navigator.mediaDevices.getDisplayMedia({
              video: true, // Required for picker dialog
              audio: true, // Makes audio sharing available (user must manually check)
              preferCurrentTab: false,
              surfaceSwitching: "include",
              systemAudio: "include" // Hint to include system audio option if supported
            })
            
            // Stop all video tracks immediately - we only want audio
            systemStream.getVideoTracks().forEach(track => track.stop())
          } catch (displayError) {
            console.warn('Could not capture system audio:', displayError)
            // Show warning but continue with microphone only
            showToast((window.I18N ? window.I18N.t('recordingMicOnlyWarning') : 'הקלטה ממיקרופון בלבד (אודיו מערכת לא נבחר)'), 'error')
          }

          // Set up Web Audio API to mix both streams
          audioContext = new (window.AudioContext || window.webkitAudioContext)()
          const destination = audioContext.createMediaStreamDestination()
          
          // Connect microphone
          const micSource = audioContext.createMediaStreamSource(micStream)
          const micGain = audioContext.createGain()
          micGain.gain.value = 1.0
          micSource.connect(micGain)
          micGain.connect(destination)

          // Connect system audio if available
          if (systemStream) {
            const systemSource = audioContext.createMediaStreamSource(systemStream)
            const systemGain = audioContext.createGain()
            systemGain.gain.value = 1.0
            systemSource.connect(systemGain)
            systemGain.connect(destination)
          }

          // Set up analyzer for visualization (connected to mixed output)
          analyser = audioContext.createAnalyser()
          analyser.fftSize = 2048
          analyser.smoothingTimeConstant = 0.8
          micGain.connect(analyser)
          if (systemStream) {
            const systemSource = audioContext.createMediaStreamSource(systemStream)
            systemSource.connect(analyser)
          }

          // Use the mixed stream for recording
          recordingStream = destination.stream

          // Store original streams for cleanup
          recordingStream._originalStreams = [micStream]
          if (systemStream) {
            recordingStream._originalStreams.push(systemStream)
          }

          // Create MediaRecorder with opus codec if available
          const options = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
            ? { mimeType: 'audio/webm;codecs=opus' }
            : { mimeType: 'audio/webm' }
          
          mediaRecorder = new MediaRecorder(recordingStream, options)
          audioChunks = []

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data)
            }
          }

          mediaRecorder.onstop = () => {
            recordedBlob = new Blob(audioChunks, { type: 'audio/webm' })
            const audioUrl = URL.createObjectURL(recordedBlob)
            recordedAudioPlayer.src = audioUrl
            
            // Stop all tracks from original streams
            if (recordingStream && recordingStream._originalStreams) {
              recordingStream._originalStreams.forEach(stream => {
                stream.getTracks().forEach(track => track.stop())
              })
            }
            
            // Stop destination stream tracks
            if (recordingStream) {
              recordingStream.getTracks().forEach(track => track.stop())
              recordingStream = null
            }

            // Stop audio context
            if (audioContext) {
              audioContext.close()
              audioContext = null
            }

            // Convert blob to file and add to file list
            const fileName = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.webm`
            const file = new File([recordedBlob], fileName, { type: 'audio/webm' })
            
            selectedFile = file
            selectedFiles = []
            batchMode = false
            transcribeBtn.disabled = false

            // Show file preview
            showFilePreview(file)

            // Show both player and normal UI
            recordingInterface.style.display = 'none'
            recordedAudioPreview.style.display = 'block'
            dropArea.style.display = 'block'
            recordMenu.style.display = 'inline-block'

            // Refresh icons
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
              window.lucide.createIcons()
            }

            showToast((window.I18N ? window.I18N.t('recordingReadyToTranscribe') : 'ההקלטה מוכנה לתמלול. לחץ על "תמלל" להמשך.'), 'success')
          }

          // Start recording
          mediaRecorder.start(100) // Collect data every 100ms
          recordingStartTime = Date.now()

          // Show recording interface
          dropArea.style.display = 'none'
          recordMenu.style.display = 'none'
          recordingInterface.style.display = 'block'

          // Start visualization and timer
          drawWaveform()
          startRecordingTimer()

          // Refresh icons
          if (window.lucide && typeof window.lucide.createIcons === 'function') {
            window.lucide.createIcons()
          }

        } catch (error) {
          console.error('Error accessing audio:', error)
          if (error.name === 'NotAllowedError') {
            showToast((window.I18N ? window.I18N.t('micPermissionDenied') : 'הגישה למיקרופון נדחתה. אנא אפשר גישה למיקרופון בהגדרות הדפדפן.'), 'error')
          } else {
            showToast((window.I18N ? window.I18N.t('micError') : 'שגיאה בגישה למיקרופון. אנא ודא שהמיקרופון מחובר ומופעל.'), 'error')
          }
        }
      })

      // Stop recording
      stopRecordingBtn.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop()
          stopRecordingTimer()
          cancelAnimationFrame(animationFrameId)
        }
      })

      // Draw waveform animation (WhatsApp-style scrolling volume bars)
      function drawWaveform() {
        if (!analyser || !waveformCanvas) return

        const canvasContext = waveformCanvas.getContext('2d')
        const dataArray = new Uint8Array(analyser.frequencyBinCount)
        
        // Volume history - stores past volume readings
        const volumeHistory = []
        let lastDrawTime = 0
        const drawInterval = 80 // Update every 80ms for smooth scrolling

        const barWidth = 3
        const barSpacing = 2
        const maxBars = Math.floor(waveformCanvas.width / (barWidth + barSpacing))

        const draw = (currentTime) => {
          animationFrameId = requestAnimationFrame(draw)

          // Throttle drawing
          if (currentTime - lastDrawTime < drawInterval) {
            return
          }
          lastDrawTime = currentTime

          // Get volume data
          analyser.getByteFrequencyData(dataArray)
          
          // Calculate average volume
          let sum = 0
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i]
          }
          const avgVolume = sum / dataArray.length
          const normalizedVolume = Math.min(avgVolume / 128, 1.0)
          
          // Add new volume reading to history (at the end, will be drawn on right)
          volumeHistory.push(normalizedVolume)
          
          // Remove old readings if we exceed max bars
          if (volumeHistory.length > maxBars) {
            volumeHistory.shift()
          }

          const width = waveformCanvas.width
          const height = waveformCanvas.height

          // Get theme colors
          const computedStyle = getComputedStyle(document.documentElement)
          const bgColor = computedStyle.getPropertyValue('--secondary-color').trim()
          const primaryColor = computedStyle.getPropertyValue('--primary-color').trim()

          // Clear canvas
          canvasContext.fillStyle = bgColor || '#f8f9fa'
          canvasContext.fillRect(0, 0, width, height)

          // Draw volume bars scrolling from right to left
          const maxBarHeight = height * 0.7
          const centerY = height / 2

          canvasContext.fillStyle = primaryColor || '#4caf50'

          // Draw each bar in history, from left to right (oldest to newest)
          for (let i = 0; i < volumeHistory.length; i++) {
            const volume = volumeHistory[i]
            
            // Calculate bar height based on volume
            let barHeight = Math.max(volume * maxBarHeight, 4)
            
            // Position: bars fill from right to left as history grows
            const x = width - ((volumeHistory.length - i) * (barWidth + barSpacing))
            const y = centerY - (barHeight / 2)
            
            // Draw rounded rectangle (with fallback for older browsers)
            if (typeof canvasContext.roundRect === 'function') {
              canvasContext.beginPath()
              canvasContext.roundRect(x, y, barWidth, barHeight, 1.5)
              canvasContext.fill()
            } else {
              // Fallback: draw regular rectangle
              canvasContext.fillRect(x, y, barWidth, barHeight)
            }
          }
        }

        draw(0)
      }

      // Start recording timer
      function startRecordingTimer() {
        recordingTimerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000)
          const minutes = Math.floor(elapsed / 60)
          const seconds = elapsed % 60
          recordingTimer.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`
        }, 1000)
      }

      // Stop recording timer
      function stopRecordingTimer() {
        if (recordingTimerInterval) {
          clearInterval(recordingTimerInterval)
          recordingTimerInterval = null
        }
      }

      // ========== STATISTICS FUNCTIONALITY ==========

      let statsTabOpened = false

      function openStatsTab() {
        statsTabOpened = true
        if (statsTabBtn) {
          statsTabBtn.style.display = 'inline-block'
        }
        switchTab('stats')
      }

      function formatMinutesAsHM(minutes) {
        if (minutes === null || minutes === undefined || isNaN(minutes)) {
          return '-'
        }
        const totalSeconds = Math.round(minutes * 60)
        const hours = Math.floor(totalSeconds / 3600)
        const mins = Math.floor((totalSeconds % 3600) / 60)
        return `${hours}:${String(mins).padStart(2, '0')}`
      }

      // Load statistics when stats tab is activated
      async function loadStatistics() {
        const statsLoading = document.getElementById('stats-loading')
        const statsContent = document.getElementById('stats-content')
        const statsError = document.getElementById('stats-error')

        // Show loading, hide content and error
        statsLoading.style.display = 'block'
        statsContent.style.display = 'none'
        statsError.style.display = 'none'

        try {
          const response = await fetch('/stats')
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
          }

          const data = await response.json()

          // Update uptime
          document.getElementById('stats-uptime').textContent = data.uptime

          // Update queued jobs
          document.getElementById('queued-short-count').textContent = `${data.queued_jobs.short.count} (${formatMinutesAsHM(data.queued_jobs.short.total_duration_minutes)})`
          document.getElementById('queued-long-count').textContent = `${data.queued_jobs.long.count} (${formatMinutesAsHM(data.queued_jobs.long.total_duration_minutes)})`
          document.getElementById('queued-private-count').textContent = `${data.queued_jobs.private.count} (${formatMinutesAsHM(data.queued_jobs.private.total_duration_minutes)})`

          // Update running jobs
          document.getElementById('running-short-count').textContent = `${data.running_jobs.short.count} (${formatMinutesAsHM(data.running_jobs.short.total_duration_minutes)})`
          document.getElementById('running-long-count').textContent = `${data.running_jobs.long.count} (${formatMinutesAsHM(data.running_jobs.long.total_duration_minutes)})`
          document.getElementById('running-private-count').textContent = `${data.running_jobs.private.count} (${formatMinutesAsHM(data.running_jobs.private.total_duration_minutes)})`

          // Update transcribed statistics
          document.getElementById('transcribed-short-jobs').textContent = data.transcribed_since_launch.short.jobs_count
          document.getElementById('transcribed-short-minutes').textContent = data.transcribed_since_launch.short.total_minutes_formatted
          document.getElementById('transcribed-long-jobs').textContent = data.transcribed_since_launch.long.jobs_count
          document.getElementById('transcribed-long-minutes').textContent = data.transcribed_since_launch.long.total_minutes_formatted
          document.getElementById('transcribed-private-jobs').textContent = data.transcribed_since_launch.private.jobs_count
          document.getElementById('transcribed-private-minutes').textContent = data.transcribed_since_launch.private.total_minutes_formatted
          document.getElementById('transcribed-total-jobs').textContent = data.transcribed_since_launch.total.jobs_count
          document.getElementById('transcribed-total-minutes').textContent = data.transcribed_since_launch.total.total_minutes_formatted

          // Update system info
          document.getElementById('max-parallel-short').textContent = data.system_info.max_parallel_jobs.short
          document.getElementById('max-parallel-long').textContent = data.system_info.max_parallel_jobs.long
          document.getElementById('max-parallel-private').textContent = data.system_info.max_parallel_jobs.private
          // Update transcoding stats
          document.getElementById('transcoding-total-jobs').textContent = data.transcoding.jobs
          document.getElementById('transcoding-total-gb').textContent = data.transcoding.total_gb.toFixed(2)
          document.getElementById('transcoding-total-duration').textContent = data.transcoding.total_duration_formatted

          // Update errors
          const driveErrors = data.errors?.google_drive || {}
          document.getElementById('gdrive-toc-upload-errors').textContent = driveErrors.toc_upload ?? '-'
          document.getElementById('gdrive-toc-download-errors').textContent = driveErrors.toc_download ?? '-'
          document.getElementById('gdrive-audio-upload-errors').textContent = driveErrors.audio_upload ?? '-'
          document.getElementById('gdrive-audio-download-errors').textContent = driveErrors.audio_download ?? '-'
          document.getElementById('gdrive-rename-errors').textContent = driveErrors.rename ?? '-'
          document.getElementById('gdrive-delete-errors').textContent = driveErrors.delete ?? '-'
          document.getElementById('quota-denied-errors').textContent = data.errors?.quota_denied ?? '-'

          // Show content, hide loading
          statsLoading.style.display = 'none'
          statsContent.style.display = 'block'

        } catch (error) {
          console.error('Error loading statistics:', error)
          statsLoading.style.display = 'none'
          statsError.style.display = 'block'
        }
      }

      // Auto-refresh stats when stats tab is active
      let statsRefreshInterval = null
      function startStatsAutoRefresh() {
        // Refresh every 30 seconds
        statsRefreshInterval = setInterval(() => {
          const statsTab = document.getElementById('tab-stats')
          if (statsTab && statsTab.classList.contains('active')) {
            loadStatistics()
          }
        }, 30000)
      }

      function stopStatsAutoRefresh() {
        if (statsRefreshInterval) {
          clearInterval(statsRefreshInterval)
          statsRefreshInterval = null
        }
      }

      // Hook into tab switching to load stats when needed
      const originalSwitchTab = switchTab
      switchTab = function(tabName) {
        if ((tabName === 'stats' || statsTabOpened) && statsTabBtn) {
          statsTabBtn.style.display = 'inline-block'
        }
        // Call original function
        originalSwitchTab(tabName)

        // Handle stats tab activation
        if (tabName === 'stats') {
          loadStatistics()
          startStatsAutoRefresh()
        } else {
          stopStatsAutoRefresh()
        }
      }
    </script>
  </body>
</html>
